
; ******** Source: editrom.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; This is the main Assembler file. It brings in the USER-DEFINED variables and acts on them to build a
     4                          ; functional EDITOR ROM.
     5                          ;
     6                          ;---------------------- Get User Variables and validate some settings, and set output file
     7                          

; ******** Source: edit.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; A Project to create replacement EDIT ROMs for the PET/CBM line of computers.
     4                          ; Use MAKE.BAT to assemble (ACME.EXE must be in same folder or in search path).
     5                          ; For complete documentation see:
     6                          ;      http://www.6502.org/users/sjgray/projects/editrom/index.html
     7                          ;
     8                          ; Edit these settings to choose which features are included.
     9                          ;
    10                          ; The most important is the CODEBASE setting. It determines which main code to use, which will determine
    11                          ; how many features are available:
    12                          ;
    13                          ;   CODEBASE=0 for 40-column (30xx/40xx) machines with Universal Dynamic Motherboard. Line Linking.
    14                          ;   CODEBASE=1 for 80-column (80xx/82xx/9000) machines with Universal Dynamic Motherboard. No Line Linking.
    15                          ;   CODEBASE=2 for 80-column (8296/8296D) machines (mostly DIN keyboard versions). No Line Linking.
    16                          ;
    17                          ; If there are no options listed it means that support has not been added yet!
    18                          ;
    19                          ; NOTE!: Not all combinations may be valid!!
    20                          ; NOTE!: SuperPET's require a special adapter to use EPROMS and have compatibility issues with 4K edit roms (see web page)
    21                          ;
    22                          ;----------------------------------------------------------------------------------------------------------------------------
    23                          ; The following DATE and COMMENT strings will be placed in the IO area (if used).
    24                          ; Take care that comments do not overflow into code space!
    25                          
    26                          !macro DATE      { !pet "2022-04-18" }
    27                          !macro COMMENT   { !pet "sjg-editrom" }
    28                          
    29                          ;----------------------------------------------------------------------------------------------------------------------------
    30                          
    31                          ; NAME		FEATURE				VALID OPTIONS			NOTES / FUTURE OPTIONS
    32                          ;---------	-------				-------------			----------------------
    33                          CODEBASE  = 1   ; Code Base			0=4000, 1=8000, 2=8296		
    34                          OPTROM    = 0   ; Location of EXT code		0=$E800-EFFF, 1=$9000, 2=$A000  Normal is 0.
    35                          
    36                          KEYSCAN   = 1   ; Keyboard Scanner		0=Normal,1=Business,2=DIN
    37                          KEYBOARD  = 1	; Keyboard type:		0=N-QWERTY,1=B-QWERTY,2=DIN,3=C64,4=B-SJG,5=N-SJG,6=B-QWERTZ,7=B-AZERTY,8=CBM-II (req hw mod)
    38                          REFRESH   = 1	; Screen refresh:		0=Euro,1=N.America,2=PAL,3=NTSC,4=9",82=8296D#1,83=8296D#2,90=32-line,91=35-line,92=90x35,99=Custom
    39                          REPEATOPT = 0	; Key Repeat Option		0=No (Always ON), 1=Yes
    40                          COLUMNS   = 80	; Screen Width			40,80,90,32 columns		Special cases 32 or 90.
    41                          ROWS      = 25  ; Screen Height			25,35,16 rows			Special cases 16 or 35.
    42                          HERTZ     = 50	; Line Frequency (Clock):	50=Euro,60=N.America
    43                          IRQFIX    = 0   ; Fix Jiffy Clock		0=No, 1=Yes			Still needs investigating.
    44                          FONTSET   = 1	; Initial Screen Font		0=Text/Lower, 1=Upper/Graphics	Generally: 40xx machines=1, 8xxx machines=0
    45                          
    46                          ESCCODES  = 1	; Add ESC codes? 		0=No, 1=Yes			Enable when using COLOURPET or SS40.
    47                          VIDSWITCH = 0   ; Video Switching               0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+9 to Switch CRTC parameters.
    48                          
    49                          AUTORUN   = 1   ; Set for BANNER and/or WEDGE	0=No, 1=Yes			Enable if you use EITHER banner,wedge, or disk boot
    50                          BYPASS    = 0   ; Check for key to bypass 	0=No, 1=Yes			Valid when AUTORUN=1. Hold key on ROW9 to bypass.
    51                          BANNER    = 5   ; Custom Banner (power on msg)	0=No, N=Banner# (1-19,98,99)    Valid when AUTORUN=1. Refer to docs or source. 99=custom message
    52                          WEDGE     = 1	; DOS Wedge			0=No, 1=Yes			Valid when AUTORUN=1.
    53                          WEDGEMSG  = 0	; Show wedge message?		0=No, 1=Yes			Valid when AUTORUN=1 and WEDGE>0.
    54                          DISKBOOT  = 0	; Boot first file on disk?	0=No, 1=Yes			Valid when AUTORUN=1.
    55                          
    56                          SOFT40    = 0	; 40 columns on 8032s?		0=No, 1=Yes			Do NOT enable SOFT40 and SS40 at the same time!
    57                          SS40      = 0	; Software Switchable Soft-40	0=No, 1=Yes			Also set ESCCODES=1. Also if BACKARROW>0 and BACKACTION=1.
    58                          SS40MODE  = 80  ; Initial SS40 Mode		40 or 80 columns		Valid when SS40=1.
    59                          HARD4080  = 0   ; Hardware 40/80 Board          0=No, 1=Yes			Valid when SS40=1.
    60                          
    61                          KEYRESET  = 1	; Add keyboard reset? 		0=No, 1=Yes
    62                          SILENT    = 0	; Disable BELL/CHIME		0=Normal, 1=Disabled
    63                          CRUNCH    = 1   ; Remove unneeded code?		0=No, 1=Yes			Removes NOPs, filler, and unreachable code.
    64                          BACKARROW = 1   ; SHIFT-Backarrow Hack code?	0=NO, 1=Yes, 2=Yes EXT		Enable Shift-Backarrow, and where to put the code.
    65                          BACKACTION= 0   ; Backarrow Action		0=Text/Graphic, 1=40/80		Which Backarrow Action? NOTE: 40/80 requires ESC Codes!
    66                          
    67                          EXECUDESK = 0	; Add Execudesk Menu?		0=No, 1=Yes, 2=Yes/OPTROM	Note: Requires BOOT to TEXT mode!
    68                          COLOURPET = 1	; ColourPET additions?		0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+? to set Colour (unless VIDSWITCH=1).
    69                          UPET      = 1   ; Is a Ultra-PET/Micro-PET?     0=No, 1=Yes                     For special Reboot - Andre Fachat's project
    70                          
    71                          COLOURVER = 1	; ColourPET Hardware Version	0=Beta,1=Normal/uPET		0=ColourRAM at $8400, 1=$8800 (use for VICE).
    72                          COLOURMODE= 0	; ColourPET Hardware Type	0=Digital, 1=Analog
    73                          DEFAULTFG = 2	; ColourPET Foreground colour   0 to 15 RGBI 			0=black,1=DkGry,2=DkBlu ,3=LtBlu, 4=DkGrn, 5=Grn,   6=DkCyan,7=LtCyan
    74                          DEFAULTBG = 2	; ColourPET Background colour   0 to 15 RGBI 			8=DKred,9=LTred,10=DKpur,11=LTpur,12=DkYel,13=LtYel,14=LtGry,15=White
    75                          DEFAULTBO = 2   ; ColourPET Border colour       0 to 15 RGBI
    76                          BYPASSFG  = 5   ; ColourPET Bypass FG     	0 to 15 RGBI			Colours when AUTOSTART is bypassed.
    77                          BYPASSBG  = 0   ; ColourPET Bypass BG     	0 to 15 RGBI
    78                          
    79                          MOT6845   = 0   ; Is CRTC a Motorola6845?       0=No, 1=Yes			Probably 0=No for compatibility.
    80                          INFO      = 0   ; Add project info to code area 0=NO, 1=Yes,2=Yes+FONT		INFO=2 shows character set at top of screen
    81                          BUGFIX    = 1   ; Correct Known bugs		0=No, 1=Yes			Fix known bugs
    82                          DEBUG 	  = 0	; Add debugging			0=No, 1=Yes			Add code to display debug info on screen

; ******** Source: editrom.asm
     8                          					; Include USER-DEFINED variables
     9                          	!IF COLOURPET>0 { ESCCODES=1 }					; Make sure ESC Codes is ON if SS40 or COLOURPET is enabled
    10                          	!IF SS40=1      { SOFT40=0 }                         		; Make sure SOFT40 is OFF if SS40 is enabled
    11                          
    12                          	!IF COLOURPET=0 { !TO "editrom.bin",plain }			; Generic output file with no load address
    13                          	!IF COLOURPET>0 { !TO "cpetrom.bin",plain }			; ColourPET output file with no load address
    14                          
    15                          ;---------------------- These are the symbol definitions for PET/CBM memory and IO chips
    16                          

; ******** Source: memzeropage.asm
     1                          ; PET/CBM EDIT ROM - Standard Zero Page locations/variables/storage
     2                          ; ================
     3                          ; Descriptions are from Butterfield's memory maps from Transactor
     4                          
     5                          ;		--------------- Common Usage (All Codebases)
     6                          
     7                          Basic_USR 	= $00		; USR Jump
     8                          USRADD 		= $01		; USR Jump
     9                          CHARAC 		= $03		; Search Character
    10                          ENDCHR 		= $04		; Scan between Quotes Flag
    11                          COUNT 		= $05		; Input buffer pointer. # of subscripts
    12                          DIMFLG 		= $06		; Default DIM flag
    13                          VALTYP 		= $07		; Type: FF=string, 00=numeric
    14                          INTFLG 		= $08		; Type: 80=integer, 00=floating point
    15                          GARBFL 		= $09		; Flag: DATA scan; List quote; memory
    16                          SUBFLG 		= $0a		; Flag: Subscript; FNX flag
    17                          INPFLG 		= $0b		; 0=input; $40=GET; $98=READ
    18                          TANSGN 		= $0c		; ATN sign/Comparison Evaluation Flag
    19                          DS_1 		= $0d		; Disk Status DS$ descriptor
    20                          DS_2 		= $0e		; Disk Status DS$ descriptor
    21                          DS_3 		= $0f		; Disk Status DS$ descriptor
    22                          IOPMPT 		= $10		; Current i/o device for prompt suppress
    23                          LINNUM 		= $11		; Integer value (for SYS, GOTO etc)
    24                          TEMPPT 		= $13		; Pointers for descriptor stack
    25                          LASTPT 		= $14	 	
    26                          TEMPST 		= $16		; Descriptor stack (temp strings)
    27                          INDEXA 		= $1f		; Utility pointer area
    28                          INDEXB 		= $21
    29                          FAC3EX 		= $23		; Product area for multiplication
    30                          FAC3M1 		= $24		
    31                          FAC3M2 		= $25
    32                          FAC3M3 		= $26
    33                          FAC3M4 		= $27
    34                          TXTTAB 		= $28		; Pointer: Start of BASIC
    35                          VARTAB 		= $2a		; Pointer: Start of Variables
    36                          ARYTAB 		= $2c		; Pointer: Start of Arrays
    37                          STREND 		= $2e		; Pointer: End of Arrays
    38                          FRETOP 		= $30		; Pointer: String Storage (moving down)
    39                          FRESPC 		= $32		; Pointer: Utility string
    40                          MEMSIZ 		= $34		; Pointer: Limit of Memory
    41                          CURLIN 		= $36		; Current BASIC line number
    42                          OLDLIN 		= $38		; Previous BASIC line number
    43                          OLDTXT 		= $3a		; Pointer: BASIC statement for CONT
    44                          DATLIN 		= $3c		; Current DATA line number
    45                          DATPTR 		= $3e		; Current DATA address
    46                          INPPTR 		= $40		; Input Vector
    47                          VARNAM 		= $42		; Current variable name
    48                          VARPTR 		= $44		; Current variable address
    49                          FORPNT 		= $46		; Variable pointer for FOR/NEXT
    50                          YSAVE 		= $48		; Y-Save; op-save; BASIC pointer save
    51                          ACCSYM 		= $4a		; Comparison symbol accumulator
    52                          FUNCPT 		= $4b		; Misc work area/pointers
    53                          DESCPT 		= $4d
    54                          GARBSS 		= $50
    55                          JUMPER 		= $51		; Jump vector for functions
    56                          FUNJMP 		= $52		
    57                          FACTPA 		= $54		; Misc numeric work area
    58                          TMPPTA 		= $55
    59                          TMPPTB 		= $57
    60                          FACTPB 		= $59
    61                          TMPVA2 		= $5a
    62                          TMPPTC 		= $5c
    63                          FAC1EX 		= $5e		; Accum#1: Exponent
    64                          FAC1M1 		= $5f		; Accum#1: Mantissa
    65                          FAC1M2 		= $60
    66                          FAC1M3 		= $61
    67                          FAC1M4 		= $62
    68                          FAC1SI 		= $63		; Accum#1: Sign
    69                          SGNFLG 		= $64		; Series evaluation constant pointer
    70                          BITS 		= $65		; Accum#1: hi-order (overflow)
    71                          FAC2EX 		= $66	
    72                          FAC2M1 		= $67
    73                          FAC2M2 		= $68
    74                          FAC2M3 		= $69
    75                          FAC2M4 		= $6a
    76                          FAC2SI 		= $6b
    77                          STRPTR		= $6c
    78                          FAC1M5 		= $6d
    79                          TMPPTD 		= $6e
    80                          CHRGET 		= $70
    81                          CHRGETX		= $73		; UNUSED
    82                          CHRGOT 		= $76
    83                          TXTPTR 		= $77
    84                          ISNUM 		= $7d
    85                          RNDX 		= $88
    86                          JIFFY_CLOCK 	= $8d
    87                          CINV 		= $90
    88                          CBINV 		= $92
    89                          NMINV 		= $94
    90                          STATUS		= $96
    91                          KEYPRESSED	= $97		; Which KEY down - $FF = no key
    92                          KEYFLAGS	= $98		; SHIFT KEY - $01 = Pressed
    93                          JIFFY_CORR	= $99		; Correction for JIFFY clock
    94                          STKEY		= $9b		; Keyswitch PIA - Stop and Reverse Flag
    95                          SVXT		= $9c		; Timing Constant for TAPE
    96                          VERCK		= $9d		; Tape mode: 0=Load, 1=Verify
    97                          CharsInBuffer 	= $9e		; Number of characters in keyboard buffer
    98                          ReverseFlag 	= $9f		; Screen Reverse Flag
    99                          C3PO 		= $a0		; IEEE Output - $FF=character pending
   100                          LastInputCol	= $a1		; End of Line for input pointer
   101                          InputRow 	= $a3		; Cursor Log: Row
   102                          InputCol 	= $a4		; Cursor Log: Column
   103                          BSOUR 		= $a5		; IEEE output buffer
   104                          Key_Image	= $a6		; Key Image
   105                          Blink		= $a7		; Cursor Flag: 0=Flash Cursor
   106                          BLNCT		= $a8		; Cursor Timing Countdown
   107                          CursorChar	= $a9		; Character Under Cursor
   108                          BlinkPhase	= $aa		; Cursor in Blink phase
   109                          SYNO		= $ab		; EOT (End of Tape) received from Tape
   110                          CRSW		= $ac		; Input from Screen or Keyboard
   111                          TEMPX		= $ad		; Save X
   112                          LDTND		= $ae		; How many open files?
   113                          DFLTN		= $af		; Input Device - Normally 0
   114                          DFLTO		= $b0		; Output CMD Device - Normally 3
   115                          PRTY		= $b1		; TAPE character parity
   116                          DPSW		= $b2		; Byte Received FLAG
   117                          SAVELA		= $b3		; Logical Address temporary save
   118                          TIMCMD		= $b4		; Tape buffer character / MLM command
   119                          MONCNT		= $b5		; Filename pointer / MLM Flag, counter
   120                          TMPZB7		= $b7
   121                          TMPZB9		= $b9
   122                          TMPZBA		= $ba
   123                          BUFPNT		= $bb
   124                          INBIT		= $bd
   125                          BITCI		= $be
   126                          RINONE		= $bf
   127                          PTR1		= $c0
   128                          PTR2		= $c1
   129                          RIDATA		= $c2
   130                          RIPRTY		= $c3
   131                          ScrPtr		= $c4		; Pointer to character screen line
   132                          CursorCol	= $c6		; Position of cursor on above line
   133                          SAL		= $c7		; Utility Pointer - Tape or Scrolling
   134                          EAL		= $c9		; Tape end address / End of current program
   135                          CMP0		= $cb		; Tape Timing Constants (ColourPET pointer to colour line)
   136                          BLNSW		= $cc		; Tape Timing Constants (ColourPET pointer to colour line)
   137                          QuoteMode	= $cd		; 0=Direct Cursor, else programmed
   138                          BITTS		= $ce		; Tape read timer 1 enabled
   139                          EOT		= $cf		; EOT recieved from TAPE
   140                          READERR		= $d0		; Read Character error
   141                          FNLEN		= $d1		; Number of characters in filename
   142                          LA		= $d2		; Current file Logical Address
   143                          SA		= $d3		; Current file Secondary Address
   144                          FA		= $d4		; Current file Device number
   145                          RightMargin	= $d5		; Window RIGHT margin
   146                          TAPE1		= $d6		; Pointer: Start of Tape Buffer
   147                          CursorRow	= $d8		; Line where cursor lives
   148                          DATAX		= $d9		; Last Key / Checksum / Misc
   149                          FNADR		= $da		; Filename pointer
   150                          INSRT		= $dc		; Number of inserts outstanding
   151                          ROPRTY		= $dd		; Write shift word / read character in
   152                          FSBLK		= $de		; Tape blocks remaining to write
   153                          MYCH		= $df		; Serial word buffer
   154                          CAS1		= $f9		; Cassette #1 status
   155                          CAS2		= $fa		; Cassette #2 status
   156                          STAL		= $fb		; Tape start address/ MLM
   157                          MEMUSS		= $fd		; MLM / DOS pointer / Misc
   158                          
   159                          ;		---------------- 40-Column Only Usage (Codebase 0)
   160                          ;		*** Currently, We cannot use ESC codes with CODEBASE 0 because this area is used for line linking!
   161                          ;		*** The line link table uses 24 bytes, 1 for each line (line 25 can never be linked)
   162                          ;		*** The line link table also holds the HI byte for the 40-col screen line table. It may be possible to
   163                          ;		*** Move the HI byte back into ROM like in the 80 column code, then pack the 24 bytes down to 3 using
   164                          ;		*** BITS instead. This would free 21 bytes that could be used for 80-column plus enhanced features.
   165                          ;		*** However, the code to handle BIT-based line linking would be more complicated and take more code.
   166                          
   167                          !IF CODEBASE=0 {
   168                          LineLinkTable   = $e0		; 40-Col Line Link Table (to $F8)
   169                          
   170                          } ELSE {
   171                          
   172                          ;		---------------- 80-Column Only Usage (Codebase 1 or 2)
   173                          ;		*** These are the normal 80-column screen editor locations. Since we have 80 columns there is no need
   174                          ;		*** for a line-link table, therefor we can use this for enhanced 80-column functions (windowing).
   175                          
   176                          TopMargin	= $e0		; Window TOP line
   177                          BotMargin	= $e1		; Window BOTTOM line
   178                          LeftMargin	= $e2		; Window LEFT margin
   179                          XMAX		= $e3		; Maximum characters in input buffer
   180                          RPTFLG		= $e4		; Key REPEAT flag
   181                          KOUNT		= $e5		; Repeat countdown
   182                          DELAY		= $e6		; New key marker
   183                          CHIME		= $e7		; Chime Time
   184                          HOMECT		= $e8		; Home count
   185                          SCRIV		= $e9		; Screen Input Vector  (E9/EA)
   186                          SCROV		= $eb		; Screen Output Vector (EB/EC)
   187                          ; $ED-F7 			; UNUSED
   188                          JIFFY6DIV5	= $f8		; TI clock adjust (speed by 6/5)
   189                          }
   190                          
   191                          ;		---------------- These are Customized Locations
   192                          ;      		*** With Codebase 1 the area from $ED-$F7 are unused
   193                          ;      		*** With Codebase 0 the area is part of the LineWrap Table
   194                          ;		***  ( can these move to TAPE BUFFER#1? - will conflict with tape and some ML programs)
   195                          
   196                          ; If ESC codes are not active but Backarrow Hack is set to Toggle 40/80
   197                          ; then define Screen Width Location
   198                          !IF (ESCCODES = 0) AND (BACKARROW>0) AND (BACKACTION=1) {
   199                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   200                          }
   201                          
   202                          !IF ESCCODES = 1 {
   203                            !IF CODEBASE = 0 {
   204                          
   205                          ;               *** CODEBASE 0 must avoid line-link table! We will use TAPE#2 buffer (which DOS uses)
   206                          
   207                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   208                          LASTCHAR	= $0382		; Last Key Pressed - used to remember ESC key
   209                          BELLMODE	= $0383		; 0=Disable, 1=Enable BELL/CHIME
   210                          EUROFLAG        = $0384		; 0=ASCII, 1=DIN
   211                          SCN4080BOARD    = $0385		; Flag for Hardware 40/80 Column Switcher board
   212                          
   213                          MYZP            = $00           ; LO General ZP pointer (we don't have a good location for this!)
   214                          ;                 $01           ; HI                    (we will take over the USR jump vector which is rarely used)
   215                          
   216                            } ELSE {
   217                          ;               *** CODEBASE 1/2 can safely go where line-link table would be
   218                          
   219                          SCNWIDTH	= $f0		; Screen Mode (40 or 80) for SS40
   220                          LASTCHAR	= $f1		; Last Key Pressed - used to remember ESC key
   221                          BELLMODE	= $f2		; 0=Disable, 1=Enable BELL/CHIME
   222                          EUROFLAG        = $f3		; 0=ASCII, 1=DIN
   223                          SCN4080BOARD    = $f4		; Flag for Hardware 40/80 Column Switcher board
   224                          MYZP            = $f5           ; LO General ZP pointer
   225                          ;                 $f6           ; HI
   226                          ;                 $f7		; not used
   227                          
   228                            }
   229                          }

; ******** Source: editrom.asm
    17                          				; $0000-00FF	Zero Page 

; ******** Source: memlow.asm
     1                          ; PET/CBM EDIT ROM - Standard Low Mem locations/variables/storage
     2                          ; ================
     3                          
     4                          ;------------------------ Common Usage
     5                          
     6                          STACK 			= $0100	;Processor Stack
     7                          BUF 			= $0200	;MLM work area; Input buffer
     8                          LAT 			= $0251	;File Logical Address Table
     9                          FAT 			= $025b	;File Device Number Table
    10                          SAT 			= $0265	;File Secondary Address Table
    11                          KEYD 			= $026f	;Keyboard input buffer
    12                          TAPEB1 			= $027a	;TAPE#1 input buffer
    13                          TAPEB2                  = $033a ;TAPE#2 input buffer (to $03F9)
    14                          
    15                          ;------------------------ Shared with TAPE#2 buffer
    16                          
    17                          NextTab 		= $033a	;DOS character pointer
    18                          DOS_Drive_1 		= $033b	;DOS drive 1 flag
    19                          DOS_Drive_2 		= $033c	;DOS drive 2 flag
    20                          DOS_Length 		= $033d	;DOS length/write flag
    21                          DOS_Syntax 		= $033e	;DOS syntax flags
    22                          DOS_Id 			= $033f	;DOS disk ID
    23                          DOS_Command_Length 	= $0341	;DOS command string count
    24                          DOS_Filename 		= $0342	;DOS filename buffer
    25                          DOS_Command_Buffer 	= $0353	;DOS command string buffer (to $0380)
    26                          ;			  $0381-03e8 ???
    27                          
    28                          ;------------------------ 40-Column Usage
    29                          
    30                          !IF CODEBASE=0 {
    31                          DELAY			= $03e9 ;Repeat Key countdown delay 	(40 col)
    32                          KOUNT			= $03ea ;Delay between repeats 		(40 col)
    33                          XMAX			= $03eb ;Max keyboard buffer size 	(40 col)
    34                          CHIME			= $03ec ;Chime Time 0=off 		(40 col)
    35                          JIFFY6DIV5		= $03ed ;TI clock adjust (speed by 6/5) (40 col) Was: TIADJ
    36                          RPTFLG			= $03ee ;Repeat Flag                    (40 col)
    37                          TABS			= $03ef ;TAB-STOP table			(40 col)
    38                          }
    39                          
    40                          ;------------------------ Common Usage
    41                          
    42                          TABS_SET 		= $03ee	;80 column TAB stop table ($03ee-03f7) ** Should this be $03ef ???? **
    43                          ;			  $03f8 ???
    44                          ; 			  $03f9 ???
    45                          
    46                          ;------------------------ End of TAPE#2 bufer
    47                          
    48                          Reset_Vector 		= $03fa	;Monitor extension vector
    49                          Reset_Param 		= $03fc	;IEEE timeout defeat; $FF=disable
    50                          ;			  $03fd ???
    51                          ;			  $03fe ???
    52                          ;			  $03ff ???
    53                          
    54                          ;------------------------ BASIC Program Area
    55                          

; ******** Source: editrom.asm
    18                          					; $0100-03FC	Low Memory

; ******** Source: memchips.asm
     1                          ; PET/CBM EDIT ROM - Standard Chip Registers and Screen Ram
     2                          ; ================
     3                          
     4                          ;--------------------------- Screen RAM $8000-$8FFF
     5                          
     6                          SCREEN_RAM = $8000					; 40 Col = $8000-83FF, 80 Col = $8000-87FF
     7                          
     8                          !IF COLUMNS = 80 { KBD_MATRIX = $87d0 }			; Used with Extended DIN ROM keyboard scanning routine
     9                          !IF COLUMNS = 40 { KBD_MATRIX = $83e8 }			; First unused byte in SCREEN_RAM
    10                          
    11                          
    12                          ;--------------------------- PIA #1 - 6520 Chip
    13                          
    14                          PIA1_Port_A = $e810					; Keyboard ROW select
    15                          PIA1_Cont_A = $e811
    16                          PIA1_Port_B = $e812					; Keyboard COLUMN read
    17                          PIA1_Cont_B = $e813
    18                          
    19                          ;--------------------------- PIA #2 - 6520 Chip
    20                          
    21                          PIA2_Port_A = $e820
    22                          PIA2_Cont_A = $e821
    23                          PIA2_Port_B = $e822
    24                          PIA2_Cont_B = $e823
    25                          
    26                          ;--------------------------- VIA - 6522 Chip
    27                          
    28                          VIA_Port_B = $e840					; IEEE, Screen Retrace, Cassette motor
    29                          VIA_Port_A = $e841					; Parallel Port (User Port) with handshaking
    30                          VIA_DDR_B = $e842					; Data Direction Register for PORT B
    31                          VIA_DDR_A = $e843					; Data Direction Register for PORT A
    32                          VIA_Timer_1_Lo = $e844				; Timer 1
    33                          VIA_Timer_1_Hi = $e845
    34                          VIA_Timer_1_Latch_Lo = $e846			; Timer 1 Latch
    35                          VIA_Timer_1_Latch_Hi = $e847
    36                          VIA_Timer_2_Lo = $e848				; Timer 2
    37                          VIA_Timer_2_Hi = $e849
    38                          VIA_Shift = $e84a					; Shift Register
    39                          VIA_ACR = $e84b						; Shift Register Control
    40                          VIA_PCR = $e84c
    41                          VIA_IFR = $e84d
    42                          VIA_IER = $e84e
    43                          VIA_Port_A_no_HS = $e84f				; Parallel Port, no handshaking
    44                          
    45                          ;--------------------------- CTRC - 6545 CRT Controller
    46                          
    47                          CRT_Address = $e880					; Register Select Port
    48                          CRT_Status = $e881					; Register DATA port

; ******** Source: editrom.asm
    19                          					; $E800-E8FF	Chips

; ******** Source: memkernal.asm
     1                          ; PET/CBM EDIT ROM - Standard Kernal calls
     2                          ; ================
     3                          ; These are calls from the EDIT ROM to KERNAL entry points
     4                          ;---------------------------------------------------------
     5                          ; Non-vectored calls (direct - caution: could change if KERNAL is changed)
     6                          
     7                          CHKSTOP 	= $F335 ; Check for STOP key
     8                          
     9                          ;----------------- Standard KERNAL Entry Points
    10                          
    11                          BASIN		= $ffcf ; read char from input channel -> A
    12                          BSOUT		= $ffd2	; Write A to stdout
    13                          GETIN		= $ffe4	; read char from keyboard buffer -> A
    14                          UDTIME		= $FFEA	; Update Time
    15                          
    16                          ACPTR		= $f1c0	; input IEEE -> A
    17                          CHKIN		= $ffc6	; stdin from logical file # in X
    18                          CIOUT		= $f19e	; output A -> IEEE
    19                          CKOUT		= $ffc9	; stdout to logical file # in X
    20                          CLOSE		= $f2e0	; close file
    21                          CLSEI		= $f72f	; close and unlisten
    22                          CLRCH		= $ffcc	; reset stdio to defaults
    23                          LISTN		= $f0d5	; send LISTEN
    24                          LOAD		= $f408	; LOAD
    25                          LOADOP		= $f356	; LOAD without pointer change
    26                          FILENOTFOUND	= $f425	; FILE NOT FOUND, return to BASIC
    27                          OPEN		= $f563	; open file
    28                          OPENI		= $f4a5	; open file on IEEE device
    29                          SCNT		= $f2c1	; prepare SETT for logical file A
    30                          SECND		= $f143	; send secondary address A
    31                          SETT		= $f2cd	; set LF,DN,SA from table
    32                          TALK		= $f0d2	; send TALK
    33                          TWAIT		= $f92b	; 
    34                          UNLSN		= $f1b9	; send UNLISTEN
    35                          UNTLK		= $f1ae	; send UNTALK
    36                          RESET		= $fd16	; basic cold start
    37                          STOPEQ		= $f335	; set Z flag if stop key pressed
    38                          STOPR		= $ffe1	; return to basic if stop key pressed

; ******** Source: editrom.asm
    20                          					; $F000-FFFF	Kernal

; ******** Source: membasic4.asm
     1                          ; --------- BASIC 4 ROM ROUTINES
     2                          
     3                          SCROUT	= $e202	; output A to screen
     4                          RDOA	= $d754	; read hex address -> $FB,$FC
     5                          RDOB	= $d763	; read hex byte -> A
     6                          CLRSCR	= $e015	; clear screen
     7                          CRLF	= $d534	; move cursor to next line
     8                          FPOUT	= $cf8d	; write floating point
     9                          INTOUT	= $cf83	; write integer 0-65535 X=LSB,A=MSB
    10                          SCROLD	= $e021	; scroll down
    11                          SCROLU	= $e024	; scroll up
    12                          SPAC2	= $d52e	; write 2 spaces
    13                          SPACE	= $d531	; write space
    14                          STROUTZ	= $bb1d	; A=LSB, Y=MSB			; BASIC4 STROUTZ is broken!
    15                          STROUT	= $bb24	; X=len, STRADR=ptr
    16                          WROA	= $d717	; write hex address
    17                          HEXOUT	= $d722	; write A as hex
    18                          WROB	= $d731	; write hex byte
    19                          WRTWO	= $d731	; write XA to screen
    20                          
    21                          ADRFP	= $cd7f	; uint LSB=$5f, MSB=$60 -> FAC1
    22                          ASCII	= $d73a	; hex digit -> ascii hex digit
    23                          FPINT	= $cdd1	; FAC1 -> uint $61=MSB, $62=LSB
    24                          FPSTR	= $cf93	; fp -> str $0100..NUL
    25                          HEXIT	= $d78d	; hex ascii digit A -> hex digit A
    26                          INTFP	= $c4bc	; int Y=LSB, A=MSB -> FAC1
    27                          STRFP	= $c8eb	; string -> fp
    28                          RDINT	= $b8f6	; read basic text -> LINNUM
    29                          
    30                          ABS	= $cd8e	; FAC1 = ABS(FAC1)
    31                          ADD	= $c9a0	; FAC1 = FAC1 + FAC2
    32                          ATN	= $d32C	; FAC1 = ATN(FAC1)
    33                          COS	= $d282	; FAC1 = COS(FAC1)
    34                          DIV	= $cc48	; FAC1 = FAC2 / FAC1
    35                          EXP	= $d184	; FAC1 = EXP(FAC1)
    36                          FAC12	= $cd45	; FAC2 := FAC1
    37                          
    38                          READY	= $b3ff	; basic warm start
    39                          NEWSTT	= $b74a	; set up next statement for execution
    40                          MOVBLK	= $b357	; move block
    41                          
    42                          LINKPRG	= $b4b6	; rechain lines
    43                          RSTXCLR	= $b5e9	; reset TXTPTR and perform CLR
    44                          STXTPT	= $b622	; reset TXTPTR
    45                          CLR	= $b5f0	; perform CLR
    46                          SCRTCH	= $b5d4	; perform NEW
    47                          
    48                          MAINS	= $b40f	; MAIN's return addr on stack for CHRGET routine

; ******** Source: editrom.asm
    21                          					; BASIC
    22                          

; ******** Source: colourpet.asm
     1                          ; PET/CBM EDIT ROM - ColourPET - Add colour to a standard PET/CBM machine
     2                          ; ================
     3                          ; The EVEN ram is re-defined for use as colour RAM. There are 8 bits (one byte) that corresponds
     4                          ; to each character on the screen. These 8 bits are defined differently according to the hardware.
     5                          ;
     6                          ; DIGITAL VERSION (development in progress):
     7                          ; ---------------
     8                          ; Supports 16 colours
     9                          ; The 4 bits are arranged like: RGBI (1 level for RGB plus INTENSITY)
    10                          ; The foreground colour is stored in the lower nibble
    11                          ; The background colour is stored in the upper nibble
    12                          ; The border colour is set via a register (to be determined)
    13                          ;
    14                          ; ANALOG VERSION (future development):
    15                          ; --------------
    16                          ; Supports 256 colours
    17                          ; The 8 bits arrangment is to be determined:
    18                          ;	Option 1: RRRGGGBB  (8 levels for RED, 8 for GREEN, and 4 for BLUE. May result in unbalanced colours)
    19                          ;	Option 2: RRGGBBII  (4 levels for RED/GREEN/BLUE (64 colours), then 4 intensity levels for that colour)
    20                          ;
    21                          ; The foreground colour is definable as above
    22                          ; The background colour is selectable for the entire screen using a register (to be determined)
    23                          ; The border colour is set via a register (to be determined)
    24                          ; ---------------------------------------------------------------------------------------------
    25                          
    26                          ;---------------- Zero Page Storage
    27                          ; NOTE: These locations were used for TAPE. Do not use TAPE on ColourPET!!!!!!!!
    28                          
    29                          COLOURPTR	= $C0		; Pointer for screen writes (WAS: Tape Pointer)
    30                          COLOURPTR2	= $C2		; Pointer for scrolling etc (WAS: Tape Pointer)
    31                          CURSORCOLOUR    = $ED		; Storage for Colour at Cursor position
    32                          
    33                          ;---------------- Colour Screen RAM
    34                          
    35                          !if COLOURVER = 0 { COLOUR_RAM = $8400 }		; 40 Col = $8400-87FF, 80 Col = $8800-8FFF
    36                          !if COLOURVER = 1 { COLOUR_RAM = $8800 }		; 40 Col = $8800-8BFF, 80 Col = $8800-8FFF
    37                          
    38                          
    39                          ;---------------- Storage (Currently in Screen RAM - To be moved?)
    40                          
    41                          COLOURSTOR = COLOUR_RAM + 25 * COLUMNS + 9	; Calculate Last visible colour mem then add offset for safety
    42                          
    43                          COLOURV 	= COLOURSTOR+1	; Combined FG and BG value
    44                          COLOURFG	= COLOURSTOR+2	; Foreground Colour
    45                          COLOURBG	= COLOURSTOR+3	; Background Colour
    46                          COLOURBORDER	= COLOURSTOR+4	; Border Colour
    47                          COLOURCOUNT	= COLOURSTOR+5	; Count to track colour change codes 	(1=FG,2=BG,3=BORDER)
    48                          
    49                          COLOURREGBG	= COLOURSTOR+6	; Colour Background Register		(dummy location for now)
    50                          COLOURREGBORDER = COLOURSTOR+7	; Colour Border Register		(dummy location for now)
    51                          COLOURREGMODE   = COLOURSTOR+8	; Colour Mode Register 			(For future use)
    52                          

; ******** Source: editrom.asm
    23                          }			; Non-standard memory usage (may change without notice)
    24                          
    25                          ;---------------------- Debug stuff
    26                          
    27                          	DBLINE = SCREEN_RAM + 24 * COLUMNS				; Calculate bottom line of screen for debug
    28                          
    29                          ;=======================================================================
    30                          ; Standard 2K Edit ROM code starts here
    31                          ;=======================================================================
    32                          ; $E000-E7FF are for normal Edit ROMS.
    33                          ; The CODEBASE setting determines which BASE features are included,
    34                          ; which roughly determines which machine they were targetted to.
    35                          ; This area MAY include NEW code depending on SETTINGS. Some new code may
    36                          ; require standard code to be relocated to EXT code area.
    37                          
    38                          	!IF CODEBASE=0 {!SOURCE "editrom40.asm"}			; 40-column CODEBASE

; ******** Source: editrom80.asm
     1                          ; PET/CBM EDIT ROM  - Commented and Adapted by Steve J. Gray, Dec 14, 2015
     2                          ; ================    sjgray@rogers.com
     3                          ;
     4                          ; ***** THIS IS 80-COLUMN CODEBASE *****
     5                          ; 
     6                          ; This is reverse engineered source code for the EDIT ROMs of the Commodore PET/CBM computers.
     7                          ; The "324243-04" ROM was used as a base as it was (AFAIK) the LAST EDIT ROM that Commodore made
     8                          ; for the PET/CBM line; 8296 computer, 50HZ, 80 column, DIN keyboard, 4K size. Addresses inside
     9                          ; [brackets] are original code addresses. This disassembly is a combination of my own disassembly
    10                          ; plus a disassembly from Edilbert Kirk. Both were adapted by me for use with the ACME assembler.
    11                          ;
    12                          ; The EDIT ROM is mapped from $E000 to EFFF (4K). Many Early versions used only $E000-E7FF (2K).
    13                          ; Note that the area from $E800 to $E8FF (256 bytes) is not available due to the I/O chips in this range.
    14                          ;
    15                          ; PET/CBM machines come in several flavours:
    16                          ;    * 40 or 80 column screens
    17                          ;    * Normal, Business, or DIN keyboards
    18                          ;    * 50 or 60 Hz power frequency
    19                          ;    * Specialized options, ie: Execudesk
    20                          ;
    21                          ; In addition I am adapting the EDIT roms to these additional options:
    22                          ;    * ColourPET - My own project to add colour capabilities
    23                          ;    * Alternate Keyboards - Such as the VIC/C64 keyboard
    24                          ;    * Soft40 - Simulate a 40 column screen on 80 column hardware
    25                          ;    * Soft-switchable SOFT40
    26                          ;    * Soft-switchable real 40/80 columns (requires hardware mod)
    27                          ;    * Extended screen editor - C128 or CBM-II compatible ESC sequences
    28                          ;    * Keyboard soft-reset (like CTRL-ALT-DEL on PC's)
    29                          ;    * Autoboot from default drive
    30                          ;    * DOS Wedge
    31                          ;
    32                          ; See EDIT.ASM for assemble OPTIONS!
    33                          ; Use MAKE.BAT to assemble a binary file with the current options.
    34                          ;
    35                          ;-----------------------------------------------------------------------------------------------
    36                          ; BUG!: the 80-column screen editor does not support line-linking. This means that you are
    37                          ;       limited to entering BASIC lines to the maximum width of one screen line.
    38                          ;       This ALSO applies when you have defined a window... you will be limited to the width
    39                          ;       of the window. Take caution when editing BASIC lines inside a window; any line that
    40                          ;       wraps around to the next line will be TRUNCATED if you edit it inside a window!!!!!
    41                          
    42                          ;-----------------------------------------------------------------------------------------------
    43                          * = $e000	; Normal start address for EDIT ROM is $E000
    44                          
    45                          ;*********************************************************************************************************
    46                          ;** Edit ROM Jump Table  [E000]
    47                          ;** Note: Not all KERNAL and BASIC calls go through this table.
    48                          ;** There are FIVE hard-coded entry points: $E0A7, $E116, $E202, $E442, $E600
    49                          ;*********************************************************************************************************
    50                          
    51  e000 4c37e0             EDITOR		JMP RESET_EDITOR	; [E000] Main Initialization (called from Kernal power up reset at $FD16) 
    52  e003 4ca7e0             		JMP GETKEY		; [E003] Get Character From Keyboard Buffer	(FIXED ENTRY POINT. Must not move!)
    53  e006 4c16e1             		JMP INPUT_CHARACTER	; [E006] Input From Screen or Keyboard		(FIXED ENTRY POINT. Must not move!)
    54  e009 4c02e2             		JMP CHROUT_SCREEN	; [E009] Output to Screen			(FIXED ENTRY POINT. Must not move!)
    55  e00c 4c42e4             		JMP IRQ_MAIN		; [E00C] Main IRQ Handler			(FIXED ENTRY POINT. Must not move!)
    56  e00f 4c55e4             		JMP IRQ_NORMAL		; [E00F] Actual IRQ (clock, keyboard scan)
    57  e012 4c00e6             		JMP IRQ_END		; [E012] Return From Interrupt			(FIXED ENTRY POINT. Must not move!)
    58  e015 4c3de0             		JMP WIN_CLEAR		; [E015] Clear Window
    59  e018 4c62e0             		JMP CRT_SET_TEXT	; [E018] Set CRTC to TEXT mode
    60  e01b 4c6ae0             		JMP CRT_SET_GRAPHICS	; [E01B] Set CRTC to GRAPHICS mode
    61  e01e 4c70e0             		JMP CRT_PROGRAM		; [E01E] Program CRTC (Table pointer in A/X, chr set in Y)
    62  e021 4ccae3             		JMP WIN_SCROLL_DN	; [E021] Scroll Window DOWN
    63  e024 4ce2e3             		JMP WIN_SCROLL_UP	; [E024] Scroll Window UP
    64  e027 4cbbe4             		JMP SCAN_KEYBOARD	; [E027] Scan Keyboard
    65  e02a 4caee6             		JMP BEEP		; [E02A] Ring BELL/CHIME
    66  e02d 4c36e0             		JMP SET_REPEAT_MODE	; [E02D] Set REPEAT MODE
    67  e030 4cd7e1             		JMP WIN_SET_TOP		; [E030] Set Window Top
    68  e033 4cd2e1             		JMP WIN_SET_BOT		; [E033] Set Window Bottom
    69                          
    70                          ;*********************************************************************************************************
    71                          ;** SET_REPEAT_MODE  [E036]  (Called from Jump Table)
    72                          ;** Sets Repeat mode to 'A'. Flag: $80 = Repeat, $40 = disable
    73                          ;*********************************************************************************************************
    74                          
    75                          SET_REPEAT_MODE
    76                          		!IF REPEATOPT = 1 {
    77                          			STA RPTFLG				;$E4
    78                          		} else {
    79                          			!IF CRUNCH=0 {
    80                          				NOP
    81                          				NOP
    82                          			}
    83                          		}
    84  e036 60                 		RTS
    85                          
    86                          !IF CRUNCH=0 {	!FILL $e04b-*,$aa }			;#################################################
    87                          
    88                          ;*********************************************************************************************************
    89                          ;** RESET_EDITOR  [E04B]  (Called from Jump Table)
    90                          ;** Initializes Editor, then sets the screen to TEXT or GRAPHICS mode.
    91                          ;*********************************************************************************************************
    92                          
    93                          RESET_EDITOR
    94                          
    95                          !IF COLOURPET=0 {
    96                          		JSR INIT_EDITOR				; Initialize Editor
    97                          } ELSE {
    98  e037 2020ee             		JSR ColourPET_Init			; Initialize ColourPET settings, then INIT_EDITOR
    99                          }
   100                          
   101                          !IF FONTSET=0	{ JSR CRT_SET_TEXT }			; Set Screen to TEXT mode
   102  e03a 206ae0             !IF FONTSET=1	{ JSR CRT_SET_GRAPHICS }			; Set Screen to GRAPHICS mode
   103                          
   104                          ;*********************************************************************************************************
   105                          ;** WIN_CLEAR  [E051]  (Called from Jump Table)
   106                          ;** This routine Clears the current window. It clears ONLY the screen memory specified.
   107                          ;** Since this is the 80-column codebase there is no line-linking code. Both LO and HI
   108                          ;** screen address tables are in ROM.
   109                          ;*********************************************************************************************************
   110                          
   111  e03d a6e0               WIN_CLEAR	LDX TopMargin				; Window Top line
   112  e03f ca                 		DEX					; prep for loop
   113  e040 e8                 WC_LOOP		INX					; LOOP[  Next line
   114  e041 2058e0             		JSR UPDATE_CURSOR_R2			;   was: CURSOR_LM  ; Was: Cursor_BOL
   115  e044 20d7ee             		JSR ERASE_TO_EOL			;   Erase the line
   116  e047 e4e1               		CPX BotMargin				;   Check if at the last line
   117  e049 90f5               		BCC WC_LOOP				; ] No, go do next line
   118                          
   119                          ;*********************************************************************************************************
   120                          ;** CURSOR_HOME  [E05F]
   121                          ;** Moves the cursor to the HOME position of the current WINDOW.
   122                          ;*********************************************************************************************************
   123                          
   124  e04b a6e0               CURSOR_HOME	LDX TopMargin				; Go to TOP of window
   125  e04d 86d8               		STX CursorRow				; put cursor there too
   126                          
   127                          ;*********************************************************************************************************
   128                          ;** CURSOR_LM  [E063]
   129                          ;** Moves cursor to LEFT MARGIN of the current WINDOW.
   130                          ;*********************************************************************************************************
   131                          
   132  e04f a4e2               CURSOR_LM	LDY LeftMargin				; Get Left margin
   133  e051 84c6               		STY CursorCol				; Set cursor there
   134                          
   135                          ;*********************************************************************************************************
   136                          ;** Update Cursor ROW [E067] - Get pointer from Screen Line Address Tables (and Colour)
   137                          ;*********************************************************************************************************
   138                          
   139                          UPDATE_CURSOR_ROW
   140  e053 a6d8               		LDX CursorRow				; Current Cursor Physical Line Number
   141  e055 4c5be0             		JMP UPDATE_CURSOR_R3			;
   142                          UPDATE_CURSOR_R2
   143  e058 a4e2               		LDY LeftMargin				; First column of window
   144  e05a 88                 		DEY
   145                          UPDATE_CURSOR_R3
   146  e05b bd61e7             		LDA Line_Addr_Lo,X			; Screen Line Addresses LO
   147                          
   148                          ;*********************************************************************************************************
   149                          ;** Update Screen Pointers
   150                          ;*********************************************************************************************************
   151                          
   152                          UPDATE_SCREEN_PTR
   153                          	!IF COLOURPET=1 {
   154  e05e 2069ee             		JSR ColourPET_SyncPointersX		; Sync Pointers to Current Line
   155                          	} ELSE {
   156                          		!IF SS40=1 {
   157                          			JSR SS40_SyncPointersX		; Update screen pointers based on current screen width
   158                          		} ELSE {
   159                          			STA ScrPtr			; Pointer: Current Screen Line Address LO
   160                          			LDA Line_Addr_Hi,X		; Screen Line Addresses HI
   161                          			STA ScrPtr+1         		; Pointer: Current Screen Line Address HI
   162                          		}
   163                          	}
   164  e061 60                 		RTS
   165                          
   166                          ;*********************************************************************************************************
   167                          ;** CRTC Programming and Screen Modes  [E07A]
   168                          ;*********************************************************************************************************
   169                          

; ******** Source: crtc.asm
     1                          ; PET/CBM EDIT ROM - CRTC Programming for Text/Graphics Screen Modes
     2                          ; ================
     3                          ; Programms the CRTC controller chip for various screen timings and Text/Graphic modes.
     4                          ; This code requires two CRTC Register tables - One for Text and one for Graphics modes.
     5                          
     6                          
     7                          ;************** Set Screen to TEXT or GRAPHICS MODE
     8                          ;
     9                          ; TEXT/GRAPHICS mode determines which font is displayed.
    10                          ; - GRAPHICS mode has uppercase and full graphics. Characters take 8 scanlines
    11                          ; - TEXT mode has lower case, upper case and limited graphics. Characters take 10 scanlines (normally)
    12                          ; 
    13                          ; OPTIONS: 'EXTENDED' and 'SS40'
    14                          
    15                          ;-------------- Initialize CRTC to TEXT Mode (Called from Jump Table)
    16                          
    17                          CRT_SET_TEXT
    18                          
    19                          !if CODEBASE<2 {
    20                          	!IF SS40=0 {
    21  e062 a936               		LDA #<CRT_CONFIG_TEXT			; Point to CRTC Table
    22  e064 a2e7               		LDX #>CRT_CONFIG_TEXT			; Point to CRTC Table
    23  e066 a00e               		LDY #$0E				; Character Set = TEXT
    24  e068 d006               		BNE CRT_PROGRAM
    25                          	} ELSE {
    26                          		JMP CRT_SET_TEXT_SS40			; Jump to SS40 version (upper rom)
    27                          	}
    28                          }
    29                          
    30                          !IF CODEBASE=2 {
    31                          	JMP CRT_SET_TEXT_EXT				; Jump to EXTENDED version (upper rom)
    32                          
    33                          	!if CRUNCH=0 {	
    34                          		NOP
    35                          		NOP
    36                          		NOP
    37                          		NOP
    38                          		NOP
    39                          	}
    40                          }
    41                          
    42                          ;-------------- Initialize CRTC to GRAPHICS Mode (Called from Jump Table)
    43                          
    44                          CRT_SET_GRAPHICS
    45                          
    46                          !if CODEBASE<2 {
    47                          	!IF SS40=0 {
    48  e06a a948               		LDA #<CRT_CONFIG_GRAPHICS       	; Point to CRTC Table
    49  e06c a2e7               		LDX #>CRT_CONFIG_GRAPHICS       	; Point to CRTC Table
    50  e06e a00c               		LDY #$0C				; Character Set = GRAPHICS
    51                          	} ELSE {
    52                          		JMP CRT_SET_GRAPHICS_SS40		; Jump to SS40 version (upper rom)
    53                          	}
    54                          }
    55                          !IF CODEBASE=2 {
    56                          	JMP CRT_SET_GRAPHICS_EXT		; Jump to EXTENDED version (upper rom)
    57                          
    58                          	!if CRUNCH=0 {
    59                          		NOP
    60                          		NOP
    61                          		NOP
    62                          	}
    63                          }
    64                          
    65                          ;************** Program CRTC chip for selected screen MODE (Called from Jump Table)
    66                          ;
    67                          ; The CRTC controller controls the parameters for generating the display on the monitor. The CRTC chip has
    68                          ; several registers that must be set properly according to the type of connected display. These set characters on the line,
    69                          ; left and right margins, lines on the screen, height of each line and positioning of the top of the screen.
    70                          ; The parameters are read from a table and written to the CRTC controller chip. The VIA chip is used to select which of the
    71                          ; two fonts from the CHARACTER ROM is used.
    72                          ;
    73                          ; Parameters: Table pointer in A/X, CHRSET in Y
    74                          ; OPTIONS: 'SS40' uses new routine in upper rom
    75                          
    76                          CRT_PROGRAM
    77                          
    78                          !IF SS40=0 {
    79                          ;		--------------------- Set 'Character Set'
    80                          
    81  e070 85c7               		STA SAL					; Pointer LO: Tape Buffer/ Screen Scrolling
    82  e072 86c8               		STX SAL+1				; Pointer HI
    83  e074 ad4ce8             		LDA VIA_PCR				; Get current register byte VIA Register C - CA2	CHIP 
    84  e077 29f0               		AND #$f0				; mask out lower nibble
    85  e079 85d1               		STA FNLEN				; save it to Temp Variable
    86  e07b 98                 		TYA					; Move 'Character Set' byte to A
    87  e07c 05d1               		ORA FNLEN				; update lower nibble in Temp Variable
    88  e07e 8d4ce8             		STA VIA_PCR				; write it back to VIA Register C - CA2			CHIP
    89                          
    90                          ;		--------------------- Write to the CRTC controller
    91                          
    92  e081 a011               		LDY #$11				; Number of bytes to copy = 17
    93                          
    94  e083 b1c7               CRT_LOOP	LDA (SAL),Y				; Pointer: Tape Buffer/ Screen Scrolling
    95  e085 8c80e8             		STY CRT_Address				; Select the register to update 6545/6845 CRT		CHIP
    96  e088 8d81e8             		STA CRT_Status				; Write to the register
    97  e08b 88                 		DEY
    98  e08c 10f5               		BPL CRT_LOOP				; loop for more
    99  e08e 60                 		RTS
   100                          } ELSE {
   101                          		JMP CRT_PROGRAM_SS40			; Jump to Switchable Soft-40 version (upper rom)
   102                          }

; ******** Source: editrom80.asm
   170                          
   171                          
   172                          ;*********************************************************************************************************
   173                          ;** GETKEY  [E0A7]  (Called from Jump Table)
   174                          ;** Get a KEY from keyboard buffer. Reads a character from 'KEYD' then shifts remaining buffer characters
   175                          ;** If there is NO key it will return $FF.
   176                          ;*********************************************************************************************************
   177  e08f aaaaaaaaaaaaaaaa...!FILL $e0a7-*,$aa ; FIXED ENTRY POINT! This must not move!
   178                          ;#########################################################################################################
   179                          
   180                          GETKEY
   181                          !IF DEBUG=1 { INC DBLINE+2,X }			; DEBUG
   182  e0a7 ac6f02             		LDY KEYD				; Get key at start of buffer
   183  e0aa a200               		LDX #0 					; Start at 0
   184                          
   185  e0ac bd7002             GK_LOOP		LDA KEYD+1,X				; LOOP[ START - Now shift the next keys in line
   186  e0af 9d6f02             		STA KEYD,X				;   to the front of the buffer
   187                          !IF DEBUG=1 { STA DBLINE+10,X }				;   DEBUG - update screen
   188  e0b2 e8                 		INX
   189  e0b3 e49e               		CPX CharsInBuffer			;   Num Chars in Keyboard Buffer
   190  e0b5 d0f5               		BNE GK_LOOP				; ] Done? No, loop for another
   191                          
   192  e0b7 c69e               		DEC CharsInBuffer			; Reduce Num Chars in Keyboard Buffer
   193                          
   194  e0b9 98                 		TYA					; Put the character in Accumulator
   195                          !IF DEBUG=1 { STA DBLINE+3 }				; DEBUG - 4th chr on bottom line
   196  e0ba 58                 		CLI
   197  e0bb 60                 		RTS
   198                          
   199                          ;*********************************************************************************************************
   200                          ;** GETLINE  [E0BC]
   201                          ;** The PET is usually in this routine, waiting for keypresses and printing them or acting on them.
   202                          ;** This routine continually loops until a <RETURN> is pressed. When <RETURN> is pressed then the line
   203                          ;** where the cursor is, is processed. If the <RUN> key is pressed then the string is stuffed into
   204                          ;** the keyboard buffer (overwriting whatever might be there)
   205                          ;*********************************************************************************************************
   206                          
   207  e0bc 2093e6             GETLINE		JSR ChrOutMarginBeep			; 
   208                          GETLINE2	!IF DEBUG=1 { INC DBLINE+5 }		; DEBUG - 6th chr on bottom line
   209  e0bf a59e               		LDA CharsInBuffer			; Are there any keys waiting?
   210  e0c1 85a7               		STA Blink 				; 0 chars -> blink cursor
   211  e0c3 f0fa               		BEQ GETLINE2 				; loop until char in buffer
   212                          
   213                          !IF DEBUG=1 { INC DBLINE+6 }				; DEBUG - 7th chr on bottom line
   214                          
   215                          ;[E0C5]		--------------- Got a character, so process it
   216                          
   217  e0c5 78                 		SEI
   218  e0c6 a5aa               		LDA BlinkPhase				; Check if cursor in blink phase
   219  e0c8 f009               		BEQ GL_1				; no, so no need to restore original character
   220  e0ca a5a9               		LDA CursorChar				; yes, get character under Cursor
   221  e0cc a000               		LDY #0					; 
   222  e0ce 84aa               		STY BlinkPhase				; Reset blinkphase
   223  e0d0 2006e6             		JSR RESTORE_CHR_AT_CRSR		; Restore OLD character under cursor before processing new one
   224  e0d3 20a7e0             GL_1		JSR GETKEY				; Get Character From Keyboard Buffer
   225  e0d6 c983               		CMP #$83				; Is it the <RUN> key?
   226  e0d8 d010               		BNE GL_3				; No, skip ahead
   227                          
   228                          ;[E0DA]		---------------- Stuff the <RUN> string to the keyboard buffer
   229                          
   230  e0da 78                 		SEI
   231  e0db a209               		LDX #9					; Length of string
   232  e0dd 869e               		STX CharsInBuffer			; Set number of characters in buffer
   233  e0df bd2ce7             GL_2		LDA RUN_STRING-1,X			; Normally:  dL"*<RETURN>run<RETURN>
   234  e0e2 9d6e02             		STA KEYD-1,X				; stuff it into the buffer
   235  e0e5 ca                 		DEX
   236  e0e6 d0f7               		BNE GL_2				; loop back for more
   237  e0e8 f0d5               		BEQ GETLINE2
   238                          
   239                          ;[E0EA]		--------------- Check for RETURN key
   240                          
   241  e0ea c90d               GL_3		CMP #$0D 				; Check if <RETURN> pressed
   242  e0ec d0ce               		BNE GETLINE				; if not go get more keys
   243                          
   244                          ;*********************************************************************************************************
   245                          ;** PARSE_LINE  [E0EE]
   246                          ;** When the <RETURN> key is pressed the line where the cursor lives is executed
   247                          ;*********************************************************************************************************
   248                          
   249                          PARSE_LINE
   250                          		!IF DEBUG=1 { INC DBLINE+7 }		; DEBUG - 8th chr on bottom line
   251                          
   252  e0ee a4d5               		LDY RightMargin				; Physical Screen Line Length
   253  e0f0 84ac               		STY CRSW 				; # 0 -> Screen Input
   254                          
   255  e0f2 b1c4               PL_LOOP		LDA (ScrPtr),Y				; LOOP[  Read Character from Screen RAM
   256  e0f4 c920               		CMP #$20 				;   Is it <SPACE> Ignore trailing blanks
   257  e0f6 d003               		BNE PL_SKIP				; 	No, exit out
   258  e0f8 88                 		DEY					; 	Yes, move to previous position
   259  e0f9 d0f7               		BNE PL_LOOP				; ] At start of line? No, loop back for more
   260                          
   261                          ;[E0FB]		------------------------ Process line
   262                          
   263  e0fb c8                 PL_SKIP 	INY					; last was not <SPACE> so move ahead one
   264  e0fc 84a1               		STY LastInputCol			; record the position
   265  e0fe 20c1e1             		JSR CURSOR_TO_LM			; Move to the start of the line [80] 
   266                          !IF CRUNCH=0 {	NOP }					; (this is a patch)		[80] 
   267  e101 84cd               		STY QuoteMode 				; Turn off quote mode
   268  e103 a5a3               		LDA InputRow				; Cursor Y-X Pos. at Start of INPUT
   269  e105 301a               		BMI Screen_Input
   270  e107 c5d8               		CMP CursorRow				; Current Cursor Physical Line Number
   271  e109 d016               		BNE Screen_Input
   272  e10b a5a4               		LDA InputCol
   273  e10d 85c6               		STA CursorCol				; Cursor Column on Current Line
   274  e10f c5a1               		CMP LastInputCol			; Pointer: End of Logical Line for INPUT
   275  e111 900e               		BCC Screen_Input
   276  e113 b02f               		BCS Screen_Input2
   277                          
   278                          ;*********************************************************************************************************
   279                          ;** INPUT_CHARACTER  [E116]  (Called from Jump Table) - FIXED ENTRY POINT!!!!!
   280                          ;** Push X and Y to stack then call Input a Character routine via pointer
   281                          ;*********************************************************************************************************
   282  e115 aa                 !FILL $e116-*,$aa ; FIXED ENTRY POINT! This must not move!
   283                          ;#########################################################################################################
   284                          
   285  e116 98                 INPUT_CHARACTER	TYA
   286  e117 48                 		PHA
   287  e118 8a                 		TXA
   288  e119 48                 		PHA
   289  e11a 6ce900             		JMP (SCRIV)	; Jump to Input from Screen routine (Vector normally points to DEFAULT_SCREEN_VECTOR)
   290                          
   291                          ;*********************************************************************************************************
   292                          ;** DEFAULT_SCREEN_VECTOR  [E11D]
   293                          ;** Input from Screen Routine
   294                          ;*********************************************************************************************************
   295                          
   296                          DEFAULT_SCREEN_VECTOR
   297  e11d a5ac               		LDA CRSW				; Flag: INPUT or GET from Keyboard
   298  e11f f09e               		BEQ GETLINE2
   299                          
   300                          ;		--------------------------------------- Screen Input
   301                          
   302  e121 a4c6               Screen_Input	LDY CursorCol				; Cursor Column on Current Line
   303  e123 b1c4               		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   304  e125 85d9               		STA DATAX				; Current Character to Print
   305  e127 293f               		AND #$3f 				; '?'
   306  e129 06d9               		ASL DATAX				; Current Character to Print
   307  e12b 24d9               		BIT DATAX				; Current Character to Print
   308  e12d 1002               		BPL SI_SKIP1
   309  e12f 0980               		ORA #$80
   310  e131 9004               SI_SKIP1	BCC SI_SKIP2
   311  e133 a6cd               		LDX QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   312  e135 d004               		BNE SI_SKIP3
   313  e137 7002               SI_SKIP2	BVS SI_SKIP3
   314  e139 0940               		ORA #$40 				; '@'
   315  e13b e6c6               SI_SKIP3	INC CursorCol				; Cursor Column on Current Line
   316  e13d 206ae1             		JSR CheckQuote				; ?? Was: INCREASE_COL ??
   317  e140 c4a1               		CPY LastInputCol			; Pointer: End of Logical Line for INPUT
   318  e142 d017               		BNE SI_SKIP6
   319                          
   320                          ;		--------------------------------------- Screen Input 2
   321                          
   322  e144 a900               Screen_Input2	LDA #0
   323  e146 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   324  e148 a90d               		LDA #13
   325  e14a a6af               		LDX DFLTN				; Default Input Device (0)
   326  e14c e003               		CPX #3
   327  e14e f006               		BEQ SI_SKIP4
   328  e150 a6b0               		LDX DFLTO				; Default Output (CMD) Device (3)
   329  e152 e003               		CPX #3
   330  e154 f003               		BEQ SI_SKIP5
   331  e156 2002e2             SI_SKIP4	JSR CHROUT_SCREEN			; Output to Screen
   332  e159 a90d               SI_SKIP5	LDA #13
   333  e15b 85d9               SI_SKIP6	STA DATAX				; Current Character to Print
   334  e15d 68                 		PLA
   335  e15e aa                 		TAX
   336  e15f 68                 		PLA
   337  e160 a8                 		TAY
   338  e161 a5d9               		LDA DATAX				; Current Character to Print
   339  e163 c9de               		CMP #$de				; PI symbol
   340  e165 d002               		BNE SI_DONE
   341  e167 a9ff               		LDA #$ff				; replace with $FF (PI in alt set)
   342  e169 60                 SI_DONE 	RTS
   343                          
   344                          ;[E16A]		--------------------------------------- Check Quote Mode
   345                          
   346  e16a c922               CheckQuote	CMP #$22 				; Is it <QUOTE>?
   347  e16c d008               		BNE CQ_DONE				; No, we're done
   348  e16e a5cd               		LDA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   349  e170 4901               		EOR #1					; toggle the BIT
   350  e172 85cd               		STA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   351  e174 a922               		LDA #$22 				; reload the <QUOTE>
   352  e176 60                 CQ_DONE		RTS
   353                          
   354                          ;*********************************************************************************************************
   355                          ;** CHAR_TO_SCREEN  [E177]
   356                          ;** This puts a character in 'A' to screen. The character is handled differently according to the entry
   357                          ;** point. For example, when QUOTE mode is ON special characters are printed in RVS using CHAR_TO_SCREEN3
   358                          ;*********************************************************************************************************
   359                          
   360  e177 0940               CHAR_TO_SCREEN	ORA #$40 				; '@'
   361  e179 a69f               CHAR_TO_SCREEN2 LDX ReverseFlag				; Flag: Print Reverse Chars. -1=Yes
   362  e17b f002               		BEQ CTS_SKIP1
   363                          
   364  e17d 0980               CHAR_TO_SCREEN3	ORA #$80				; Toggle the upper bit (reverse characters)
   365                          
   366  e17f a6dc               CTS_SKIP1	LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   367  e181 f002               		BEQ CTS_SKIP2
   368  e183 c6dc               		DEC INSRT				; Flag: Insert Mode, >0 = # INSTs
   369                          CTS_SKIP2
   370                          
   371                          !IF COLOURPET=0 {
   372                          		JSR RESTORE_CHR_AT_CRSR			; Put character on screen
   373                          } ELSE {
   374  e185 20efee             		JSR Put_ColourChar_at_Cursor		; Put character AND Colour on screen
   375                          }
   376                          ;		--------------------------------------- Handle screen wrap
   377                          
   378  e188 e6c6               		INC CursorCol				; Cursor Column on Current Line
   379  e18a a4d5               		LDY RightMargin				; Physical Screen Line Length
   380  e18c c4c6               		CPY CursorCol				; Is it at RIGHT margin?
   381  e18e b009               		BCS IRQ_EPILOG				; No, we're done
   382  e190 a6d8               		LDX CursorRow				; Yes, prepare to wrap to next line
   383  e192 20a3e3             CHAR_TO_SCREEN4	JSR CURSOR_DOWN				; Go to next line
   384  e195 a4e2               		LDY LeftMargin				; Get column for Left Margin of window
   385  e197 84c6               		STY CursorCol				; Set Cursor Column on Current Line
   386                          
   387                          ;*********************************************************************************************************
   388                          ;** IRQ_EPILOG  [E199]
   389                          ;** IRQ Completion. We jump here when printing is complete.
   390                          ;*********************************************************************************************************
   391                          
   392  e199 a900               IRQ_EPILOG	LDA #0
   393  e19b 85e8               		STA HOMECT				; Home Count
   394  e19d 68                 IRQ_EPILOG2 	PLA
   395  e19e a8                 		TAY
   396  e19f a5dc               		LDA INSRT				; Flag: Insert Mode, >0 = # INSTs
   397  e1a1 f002               		BEQ IRQE_SKIP
   398  e1a3 46cd               		LSR QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   399  e1a5 68                 IRQE_SKIP	PLA
   400  e1a6 aa                 		TAX
   401  e1a7 68                 		PLA
   402  e1a8 58                 		CLI					; Allow interrupts again
   403  e1a9 60                 		RTS
   404                          
   405                          ;*********************************************************************************************************
   406                          ;** CURSOR_TO_EOPL  [E1AA]
   407                          ;** Move Cursor to End of Previous Line
   408                          ;*********************************************************************************************************
   409                          
   410  e1aa a4d5               CURSOR_TO_EOPL	LDY RightMargin				; Physical Screen Line Length
   411  e1ac a6e0               		LDX TopMargin
   412  e1ae e4d8               		CPX CursorRow				; Current Cursor Physical Line Number
   413  e1b0 9008               		BCC CEPL_SKIP
   414  e1b2 a4e2               		LDY LeftMargin				; First column of window
   415  e1b4 84c6               		STY CursorCol				; Cursor Column on Current Line
   416  e1b6 68                 		PLA
   417  e1b7 68                 		PLA
   418  e1b8 d0df               		BNE IRQ_EPILOG
   419  e1ba c6d8               CEPL_SKIP	DEC CursorRow				; Current Cursor Physical Line Number
   420  e1bc 84c6               		STY CursorCol				; Cursor Column on Current Line
   421  e1be 4c53e0             		JMP UPDATE_CURSOR_ROW			; Set Screen Pointers
   422                          
   423                          ;*********************************************************************************************************
   424                          ;** ERASE_TO_ELO  [E1C1] 
   425                          ;** Erases from cursor to end of line
   426                          ;** Called from WIN_CLEAR. This routine is relocated/updated for COLOURPET
   427                          ;*********************************************************************************************************
   428                          
   429                          !IF COLOURPET=0 {
   430                          ERASE_TO_EOL
   431                          		LDA #$20 				; <SPACE>
   432                          EEOL_LOOP	INY
   433                          		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
   434                          		CPY RightMargin
   435                          		BCC EEOL_LOOP
   436                          		RTS
   437                          }
   438                          
   439                          ;*********************************************************************************************************
   440                          ;** CURSOR_TO_LM / ESCAPE_J  [E1CB]
   441                          ;** Move Cursor to Left Margin
   442                          ;*********************************************************************************************************
   443                          
   444                          ESCAPE_J
   445                          CURSOR_TO_LM
   446  e1c1 a4e2               		LDY LeftMargin				; First column of window
   447  e1c3 84c6               		STY CursorCol				; Cursor Column on Current Line
   448  e1c5 a000               		LDY #0
   449  e1c7 60                 		RTS
   450                          
   451                          ;*********************************************************************************************************
   452                          ;** FULL_SCREEN  [E1D2]
   453                          ;** Set Full Screen (Exit Window). This routine set the screen to full size.
   454                          ;** OPTIONS: 'COLUMNS' determines 40 or 80 column screen
   455                          ;**          'SS40'    when COLUMNS=80 uses col size determined by Soft40 'SCNWIDTH' memory location
   456                          ;** Note: Changing SCNWIDTH does not change CRTC parameters. Use the ESC-X command!!!
   457                          ;*********************************************************************************************************
   458                          
   459  e1c8 a900               FULL_SCREEN	LDA #0					; Top/Left=0
   460  e1ca aa                 		TAX
   461  e1cb 20d7e1             		JSR WIN_SET_TOP				; Set Window Top
   462                          
   463  e1ce a918               		LDA #ROWS-1				; Number of Hard-coded Screen Rows - Nomally 25 (0-24). 32+ for 8296 only
   464                          
   465                          !IF SS40=1 {	LDX SCNWIDTH				; Current SS40 screen width
   466  e1d0 a24f                  } ELSE {	LDX #COLUMNS-1 				; Hard-coded Screen Width (Normally 0-79)
   467                          }
   468                          
   469                          ;*********************************************************************************************************
   470                          ;** WIN_SET_BOT  [E1DC]
   471                          ;** Set Bottom Right Corner of Window
   472                          ;*********************************************************************************************************
   473                          
   474  e1d2 85e1               WIN_SET_BOT	STA BotMargin				; Last line of window
   475  e1d4 86d5               		STX RightMargin				; Physical Screen Line Length
   476  e1d6 60                 		RTS
   477                          
   478                          ;*********************************************************************************************************
   479                          ;** WIN_SET_TOP  [E1E1]
   480                          ;** Set Top Left Corner of Window
   481                          ;*********************************************************************************************************
   482                          
   483  e1d7 85e0               WIN_SET_TOP	STA TopMargin				; First line of window
   484  e1d9 86e2               		STX LeftMargin				; First column of window
   485  e1db 60                 		RTS
   486                          
   487                          ;*********************************************************************************************************
   488                          ;** CHROUT_SCREEN  [E202]  (Called from Jump Table)
   489                          ;** $E202 - FIXED ENTRY POINT! Some BASIC/KERNAL bypass the Jump Table and jump directly here
   490                          ;** Output Character to Screen Dispatch 
   491                          ;*********************************************************************************************************
   492  e1dc aaaaaaaaaaaaaaaa...!FILL $e202-*,$aa ; FIXED ENTRY POINT! This must not move!
   493                          ;#########################################################################################################
   494                          
   495  e202 48                 CHROUT_SCREEN	PHA
   496  e203 85d9               		STA DATAX				; Current Character to Print
   497  e205 8a                 		TXA
   498  e206 48                 		PHA
   499  e207 98                 		TYA
   500  e208 48                 		PHA
   501  e209 6ceb00             		JMP (SCROV) 				; Via Screen Output Vector (normally 'CHROUT_NORMAL')
   502                          
   503                          ;*********************************************************************************************************
   504                          ;** CHROUT_NORMAL  [E20C]
   505                          ;** Output Character to Screen. Character to print must be in DATAX.
   506                          ;** SCROV vector normally points here
   507                          ;*********************************************************************************************************
   508                          
   509  e20c a900               CHROUT_NORMAL	LDA #0
   510  e20e 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   511                          
   512  e210 a4c6               		LDY CursorCol				; Cursor Column on Current Line
   513  e212 a5d9               		LDA DATAX				; Current Character to Print
   514  e214 297f               		AND #$7F				; Strip off top bit (REVERSE)
   515                          
   516                          ;[PATCH]	--------------------------------------- Check for ESC Character
   517                          
   518                          !IF ESCCODES=1 {
   519  e216 4caeeb             		JMP CheckESC				; Check for ESC as last Char, then ESC as current Char. If so, perform it.
   520  e219 85f1               ESC_DONE	STA LASTCHAR				; Save the character
   521                          
   522                          } ELSE {
   523                          		CMP #$1B				; <ESC>	key? **** Also SHIFT-ESC $9B (Conflicts with COLOUR CODE!)
   524                          		BNE CHROUT_CHECK
   525                          		JMP ESCAPE				; Cancel RVS/INS/QUOTE modes
   526                          }
   527                          ESC_DONE2
   528                          
   529                          ;[E21D]		--------------------------------------- Reload character and check high bit
   530                          
   531  e21b a5d9               CHROUT_CHECK	LDA DATAX				; Current Character to Print
   532  e21d 20e5ed             !IF COLOURPET=1 { JSR CheckColourCodes }		; Check table of color values @@@@@@@@@@@@@@@@ COLOURPET
   533  e220 1003               		BPL CHROUT_LO				; Is top bit CLEAR? Yes, handle UNSHIFTED Character
   534  e222 4cf9e2             		JMP CHROUT_HI				; No, Handle SHIFTED Character
   535                          
   536                          ;*********************************************************************************************************
   537                          ;** Character Output with High Bit CLEAR  [E224]
   538                          ;** This section checks characters in the range 0 to 127.
   539                          ;** UN-SHIFTED character have the HI BIT is CLEAR
   540                          ;*********************************************************************************************************
   541                          
   542                          ;		--------------------------------------- Check for RETURN
   543                          
   544  e225 c90d               CHROUT_LO	CMP #$0D 				; Is it <RETURN>?
   545  e227 d003               		BNE Be22b				; No, skip to next check
   546  e229 4cb6e3             		JMP CURSOR_RETURN			; Yes, Handle <RETURN>
   547                          
   548                          ;		--------------------------------------- Check for Control Codes Range (0-31)
   549                          
   550  e22c c920               Be22b		CMP #$20 				; <SPACE>
   551  e22e 9008               		BCC Be237 				; -> Control code
   552  e230 293f               		AND #$3f 				; '?'
   553  e232 206ae1             		JSR CheckQuote				; Check For Quotes
   554  e235 4c79e1             		JMP CHAR_TO_SCREEN2			; -> Print to screen
   555                          
   556  e238 a6dc               Be237		LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   557  e23a f003               		BEQ Be23e				; Is FLAG=0? Yes, skip ahead
   558  e23c 4c7de1             		JMP CHAR_TO_SCREEN3			; -> Print reverse to screen
   559                          
   560                          ;		--------------------------------------- Check for DELETE
   561                          
   562  e23f c914               Be23e		CMP #$14 				; Is it <DEL>?
   563  e241 d01d               		BNE Be262				; No, skip ahead
   564                          
   565                          ;		--------------------------------------- DELETE - Check if it would wrap to previous line
   566                          
   567  e243 a4e2               		LDY LeftMargin				; Get left margin
   568  e245 c4c6               		CPY CursorCol				; Is it cursor at left margin?
   569  e247 9005               		BCC Be24d				; No, skip ahead
   570  e249 20aae1             		JSR CURSOR_TO_EOPL			; Yes, move to previous line
   571  e24c d007               		BNE Be25c				; Skip ahead if we are at the top line (Was: BPL Be25c)
   572                          
   573                          ;		--------------------------------------- Perform DELETE
   574                          
   575  e24e c6c6               Be24d		DEC CursorCol				; Move cursor one position to the LEFT
   576  e250 a4c6               		LDY CursorCol				; Get the new cursor position
   577                          
   578                          !IF COLOURPET=0 {
   579                          Be251		INY					; LOOP[
   580                          		LDA (ScrPtr),Y				;   Read Character from Screen RAM
   581                          		DEY					;   move to the left
   582                          		STA (ScrPtr),Y				;   Write Character to Screen RAM
   583                          		INY					;   Next column
   584                          		CPY RightMargin				;   Is it at the Right margin?
   585                          		BNE Be251				; ] No, so go back for more
   586                          } ELSE {
   587  e252 20a5ee             		JSR ColourPET_Scroll_Left		; Scroll both Screen and Colour LEFT	@@@@@@@@@@@@@@ ColourPET
   588                          }
   589                          
   590                          ;[E25C]		--------------------------------------- Entry point for "80240.PRG"
   591                          
   592  e255 a920               Be25c		LDA #$20 				; <SPACE>
   593  e257 91c4               		STA (ScrPtr),Y				; put it on the screen!
   594                          !IF COLOURPET=1 {
   595  e259 adda8f             		LDA COLOURV				; Get the current Colour	@@@@@@@@@@@@@@@ ColourPET
   596  e25c 91c0               		STA (COLOURPTR),Y			; put it to Colour MEM		@@@@@@@@@@@@@@@ ColourPET
   597                          }
   598  e25e d037               		BNE Be299
   599                          
   600  e260 a6cd               Be262		LDX QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   601  e262 f003               		BEQ Be269				; Quote mode OFF, so we need to action the character
   602  e264 4c7de1             		JMP CHAR_TO_SCREEN3			; Quote mode ON, so we need to print the QUOTEMODE version
   603                          
   604                          ;		--------------------------------------- Check for RVS
   605                          
   606  e267 c912               Be269		CMP #$12 				; Is it <RVS>?
   607  e269 d002               		BNE Be26f				; No, skip ahead
   608  e26b 859f               		STA ReverseFlag				; Yes, Set RVS flag
   609                          
   610                          ;		--------------------------------------- Check for HOME and HOME-HOME
   611                          
   612  e26d c913               Be26f		CMP #$13 				; Is it <HOME>?
   613  e26f d010               		BNE Be283				; No, skip ahead
   614  e271 a5e8               		LDA HOMECT 				; Is Home Count=0 (<HOME><HOME> sets window to full screen)
   615  e273 1004               		BPL Be27b				; Yes, skip ahead
   616  e275 20c8e1             		JSR FULL_SCREEN				; Set to full screen (remove any window)
   617  e278 18                 		CLC
   618  e279 66e8               Be27b		ROR HOMECT				; Reset Home Count
   619  e27b 204be0             		JSR CURSOR_HOME				; Home the cursor
   620  e27e 4c9de1             		JMP IRQ_EPILOG2
   621                          
   622                          ;		--------------------------------------- Check for CURSOR RIGHT
   623                          
   624  e281 c91d               Be283		CMP #$1d 				; Is it <CURSOR RIGHT>?
   625  e283 d00b               		BNE Be292				; No, skip ahead
   626  e285 c8                 		INY					; Yes, increment column
   627  e286 84c6               		STY CursorCol				; Update Column
   628  e288 88                 		DEY					; Go back
   629  e289 c4d5               		CPY RightMargin				; Is it at Right Margin?
   630  e28b 900a               		BCC Be299				; No, skip ahead
   631  e28d 4c92e1             		JMP CHAR_TO_SCREEN4			; Yes
   632                          
   633                          ;		--------------------------------------- Check for CURSOR DOWN
   634                          
   635  e290 c911               Be292		CMP #$11 				; Is it <CURSOR DOWN>?
   636  e292 d006               		BNE Be29c				; No, skip ahead
   637  e294 20a3e3             		JSR CURSOR_DOWN				; Go to next line
   638  e297 4c99e1             Be299		JMP IRQ_EPILOG
   639                          
   640                          ;		--------------------------------------- Check for TAB
   641                          
   642  e29a c909               Be29c		CMP #9 					; Is it <TAB>?
   643  e29c d030               		BNE Be2d0				; No, skip to next check (see [BUG?]
   644                          
   645  e29e 2070e5             		JSR JUMP_TO_TAB				; Perform <TAB>
   646  e2a1 ac3a03             Be2a3		LDY NextTab				; LOOP[
   647  e2a4 ee3a03             		INC NextTab
   648  e2a7 c4d5               		CPY RightMargin				;   Physical Screen Line Length
   649  e2a9 9009               		BCC Be2b6				;   
   650  e2ab a5d5               		LDA RightMargin				;   Physical Screen Line Length
   651  e2ad 85c6               		STA CursorCol				;   Cursor Column on Current Line
   652  e2af ce3a03             		DEC NextTab				;   temp var
   653  e2b2 d0e3               		BNE Be299				;   Exit
   654  e2b4 0e3e03             Be2b6		ASL DOS_Syntax				;   temp var
   655  e2b7 d00a               		BNE Be2c5
   656  e2b9 e8                 		INX
   657  e2ba e00a               		CPX #10					;   Have we reached end of tab table?
   658  e2bc f0d9               		BEQ Be299				;   Yes, so no tab found. Exit.
   659  e2be a901               		LDA #1
   660  e2c0 8d3e03             		STA DOS_Syntax				;   temp var
   661  e2c3 bdee03             Be2c5		LDA TABS_SET,X				;   Get TAB from table
   662  e2c6 2d3e03             		AND DOS_Syntax				;   temp var
   663  e2c9 f0d6               		BEQ Be2a3				; ]LOOP
   664  e2cb c8                 		INY
   665  e2cc 84c6               		STY CursorCol				; Set cursor column to new position
   666                          
   667                          ;[BUG?]		Why does this routine drop into the CTRL-V check? It should do JMP IRQ_EPILOG here
   668                          
   669                          ;[E2D0]		--------------------------------------- Check for Erase to End of line
   670                          
   671  e2ce c916               Be2d0		CMP #$16 				; Is it <Ctrl V>? - Erase to EOL? NOTE: 40-col code has BUG here
   672  e2d0 d013               		BNE Be2e0				; No, skip ahead
   673                          
   674                          ;[E2D4]		--------------------------------------- Erase to End of Line
   675                          
   676  e2d2 a920               		LDA #$20				; <SPACE>
   677  e2d4 88                 		DEY
   678                          
   679  e2d5 c8                 Be2d7		INY
   680  e2d6 91c4               		STA (ScrPtr),Y				; Write it to the screen
   681                          !IF COLOURPET=1 {
   682  e2d8 48                 		PHA
   683  e2d9 adda8f             		LDA COLOURV				; Current Colour		@@@@@@@@@@@@@@ COLOURPET
   684  e2dc 91c0               		STA (COLOURPTR),Y			; Write it to Colour RAM	@@@@@@@@@@@@@@ COLOURPET
   685  e2de 68                 		PLA
   686                          }
   687  e2df c4d5               		CPY RightMargin				; are we at right margin?
   688  e2e1 90f2               		BCC Be2d7
   689                          
   690  e2e3 b0b2               		BCS Be299
   691                          
   692                          ;[E2E0]		--------------------------------------- Check for Delete Line
   693                          ;
   694                          
   695  e2e5 c915               Be2e0		CMP #$15				; Is it <Ctrl U>? - DELETE LINE
   696  e2e7 f003               		BEQ DELETE_LINE				; Yes, go do it
   697  e2e9 4c91e5             		JMP Scroll_Or_Select_Charset		; No, skip ahead
   698                          
   699                          ;[E2E7]		--------------------------------------- Delete Line
   700                          
   701                          ESCAPE_D						; Esc-d Delete Line
   702                          DELETE_LINE
   703  e2ec a5e0               		LDA TopMargin				; Top Line of Window
   704  e2ee 48                 		PHA
   705  e2ef a5d8               		LDA CursorRow				; Current Cursor Physical Line Number
   706  e2f1 85e0               		STA TopMargin				; Top Line of Window
   707  e2f3 20e2e3             		JSR WIN_SCROLL_UP			; Scroll window up
   708  e2f6 4cc9e5             		JMP Me5ca
   709                          
   710                          ;*********************************************************************************************************
   711                          ;** CHROUT_HI  [E2F4]
   712                          ;** Character Output when High Bit SET (characters in the range 128 to 255).
   713                          ;** Handles: RETURN,INS,CRSR-UP,
   714                          ;*********************************************************************************************************
   715                          
   716  e2f9 297f               CHROUT_HI	AND #$7f				; strip off top bit
   717  e2fb c97f               		CMP #$7f				; special case: code for PI (7F)
   718  e2fd d002               		BNE COH_SKIP1
   719  e2ff a95e               		LDA #$5e 				; replace with screen code 5E
   720                          
   721  e301 c920               COH_SKIP1	CMP #$20 				; Is it a Control Character?
   722  e303 9003                          	BCC COH_SKIP2				; Yes, skip ahead to check
   723  e305 4c77e1                        	JMP CHAR_TO_SCREEN			; No, so just jump to print it as-is
   724                          
   725                          ;		--------------------------------------- Check for SHIFT-RETURN
   726                          
   727  e308 c90d               COH_SKIP2     	CMP #$0D 				; Is it <SHIFT><RETURN>?
   728  e30a d003                          	BNE COH_SKIP3				; No, skip ahead
   729  e30c 4cb6e3             		JMP CURSOR_RETURN			; Yes, handle it
   730                          
   731                          ;		--------------------------------------- Check Quote Mode
   732                          
   733  e30f a6cd               COH_SKIP3	LDX QuoteMode				; Is QUOTE MODE on?
   734  e311 d02c               		BNE COH_SKIP6				; No, skip ahead
   735                          
   736                          ;		--------------------------------------- Check for INSERT
   737                          
   738  e313 c914               		CMP #$14 				; Is it <INS>? (Shift-DEL)
   739  e315 d024                          	BNE COH_SKIP5				; No, skip ahead
   740                          
   741                          ;		--------------------------------------- Check if INSERT is possible
   742                          
   743  e317 a4d5               CHECK_INSERT	LDY RightMargin				; Right margin
   744  e319 b1c4                          	LDA (ScrPtr),Y				; Read the character at the end of the line
   745  e31b c920                          	CMP #$20 				; Is it <SPACE>?
   746  e31d d06a               		BNE Be38c				; No, so no room to insert. Skip ahead
   747                          
   748  e31f c4c6               COH_SKIP4	CPY CursorCol				; There is a space, but are we at end of line?
   749  e321 9066               		BCC Be38c				; Yes, so cancel insert
   750  e323 f064               		BEQ Be38c				; Yes, so cancel insert
   751                          
   752                          ;		---------------------------------------- Do INSERT
   753                          
   754  e325 a4d5               DO_INSERT	LDY RightMargin
   755                          
   756                          !IF COLOURPET=0 {
   757                          INS_LOOP1	DEY
   758                          		LDA (ScrPtr),Y				; Read it from the Screen
   759                          		INY
   760                          		STA (ScrPtr),Y				; Write it to the Screen
   761                          		DEY
   762                          		CPY CursorCol
   763                          		BNE INS_LOOP1
   764                          } ELSE {
   765  e327 20b7ee             		JSR ColourPET_Insert
   766                          }
   767  e32a a920               		LDA #$20 				; <SPACE>
   768  e32c 91c4               		STA (ScrPtr),Y				; Write it to the Screen
   769                          
   770  e32e a5d5               		LDA RightMargin				; Physical Screen Line Length
   771  e330 38                 		SEC
   772  e331 e5c6               		SBC CursorCol				; Cursor Column on Current Line
   773  e333 e5dc               		SBC INSRT				; Flag: Insert Mode, >0 = # INSTs
   774  e335 3052               		BMI Be38c
   775  e337 e6dc               		INC INSRT				; Flag: Insert Mode, >0 = # INSTs
   776  e339 d04e               		BNE Be38c
   777                          
   778                          ;		--------------------------------------- Check for INSERT in QUOTE MODE
   779                          
   780  e33b a6dc               COH_SKIP5	LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   781  e33d f005               		BEQ COH_CHECK1
   782                          
   783  e33f 0940               COH_SKIP6	ORA #$40 				; '@'
   784  e341 4c7de1             		JMP CHAR_TO_SCREEN3
   785                          
   786                          ;		--------------------------------------- Check for CURSOR UP
   787                          
   788  e344 c911               COH_CHECK1	CMP #$11 				; Is it <CRSR-UP>? (SHIFT-CRSR-DOWN)
   789  e346 d00d               		BNE Be358				; No, skip ahead
   790                          
   791                          ;		--------------------------------------- Do Cursor UP
   792  e348 a6e0               		LDX TopMargin
   793  e34a e4d8               		CPX CursorRow
   794  e34c b03b               		BCS Be38c	
   795  e34e c6d8               		DEC CursorRow
   796  e350 2053e0             		JSR UPDATE_CURSOR_ROW
   797  e353 d034               		BNE Be38c
   798                          
   799                          ;		--------------------------------------- Check for RVS OFF
   800                          
   801  e355 c912               Be358		CMP #$12 				; Is it <OFF>?  (SHIFT-RVS)
   802  e357 d004               		BNE Be360				; No, skip ahead
   803  e359 a900               		LDA #0					; Set RVS OFF
   804  e35b 859f               		STA ReverseFlag				; Store it
   805                          
   806                          ;		--------------------------------------- Check for CURSOR LEFT
   807                          
   808  e35d c91d               Be360		CMP #$1d 				; Is it <LEFT>? (Shift-Cursor RIGHT)
   809  e35f d00f               		BNE Be373				; No, skip ahead
   810  e361 a4e2               		LDY LeftMargin			
   811  e363 c4c6               		CPY CursorCol				; Are we at the left margin already?
   812  e365 9005               		BCC Be36f 				; No, skip ahead         	@@@@@@@@@@@@@@@ was: BNE $E38C
   813  e367 20aae1             		JSR CURSOR_TO_EOPL			; Yes, go to end previous line
   814  e36a d01d               		BNE Be38c				;				@@@@@@@@@@@@@@@ was: BPL Be38c
   815  e36c c6c6               Be36f		DEC CursorCol				; Move one position LEFT
   816  e36e 1019               		BPL Be38c				;				@@@@@@@@@@@@@@@ was: BNE Be38c
   817                          
   818                          ;		--------------------------------------- Check for CLEAR SCREEN
   819                          
   820  e370 c913               Be373		CMP #$13 				; Is it <CLR>? (SHIFT-HOME)
   821  e372 d005               		BNE Be37c				; No, skip ahead
   822  e374 203de0             		JSR WIN_CLEAR				; Yes, clear the screen/window
   823  e377 d010               		BNE Be38c				; Finish Up
   824                          
   825                          ;		--------------------------------------- Check for SET TAB
   826                          
   827  e379 c909               Be37c		CMP #9 					; Is it <SET-TAB>? (SHIFT-TAB)
   828  e37b d00f               		BNE Be38f				; No, skip ahead
   829                          
   830                          ;		--------------------------------------- Set a TAB STOP HERE
   831                          
   832  e37d 2070e5             		JSR JUMP_TO_TAB
   833  e380 bdee03             		LDA TABS_SET,X
   834  e383 4d3e03             		EOR DOS_Syntax
   835  e386 9dee03             		STA TABS_SET,X
   836  e389 4c99e1             Be38c		JMP IRQ_EPILOG
   837                          
   838                          ;		--------------------------------------- Check for ERASE TO START OF LINE
   839                          
   840  e38c c916               Be38f		CMP #$16 				; Is it <SHIFT>CTRL-V?  (Conflicts with COLOURPET!
   841                          !IF COLOURPET=0 {
   842                          		BEQ ERASE_TO_SOL			; Remove Conflict			
   843                          }
   844  e38e 4cbce5             		JMP ProcControl_A
   845                          
   846                          ;*********************************************************************************************************
   847                          ;** ERASE_TO_SOL / ESCAPE_P [E396]
   848                          ;** Erases from cursor to Start of Line
   849                          ;*********************************************************************************************************
   850                          
   851                          ESCAPE_P
   852  e391 a920               ERASE_TO_SOL	LDA #$20 				; <SPACE>
   853  e393 a4e2               		LDY LeftMargin				; Start at Left Margin
   854  e395 c4c6               ESOL_LOOP	CPY CursorCol				; LOOP[ Have we reached the cursor position?
   855  e397 b0f0               		BCS Be38c				;   Yes, skip ahead
   856  e399 91c4               		STA (ScrPtr),Y				;   No, Write it to the screen
   857                          !IF COLOURPET=1 {
   858  e39b adda8f             		LDA COLOURV				;   Current Colour
   859  e39e 91c0               		STA (COLOURPTR),Y			;   Write Current Colour to colour RAM
   860                          }
   861  e3a0 c8                 		INY					;   Move to next column
   862  e3a1 d0f2               		BNE ESOL_LOOP				; ] Loop back for more
   863                          
   864                          ;*********************************************************************************************************
   865                          ;** CURSOR_DOWN [E3A3]
   866                          ;** Do Cursor DOWN, Go to next line. If at bottom of window SCROLL UP.
   867                          ;*********************************************************************************************************
   868                          
   869  e3a3 46a3               CURSOR_DOWN	LSR InputRow
   870  e3a5 a6d8               		LDX CursorRow
   871  e3a7 e4e1               		CPX BotMargin
   872  e3a9 9006               		BCC Be3b1
   873  e3ab 20e2e3             		JSR WIN_SCROLL_UP
   874  e3ae 4c53e0             		JMP UPDATE_CURSOR_ROW
   875  e3b1 e6d8               Be3b1		INC CursorRow
   876  e3b3 4c53e0             		JMP UPDATE_CURSOR_ROW
   877                          
   878                          ;*********************************************************************************************************
   879                          ;** CURSOR_RETURN [E3B6]
   880                          ;** Cursor to start of line, then CURSOR DOWN. Also performs ESCAPE
   881                          ;*********************************************************************************************************
   882                          
   883  e3b6 a4e2               CURSOR_RETURN	LDY LeftMargin
   884  e3b8 84c6               		STY CursorCol
   885  e3ba 20a3e3             		JSR CURSOR_DOWN
   886                          
   887                          ;*********************************************************************************************************
   888                          ;** ESCAPE / ESCAPE_O [E3BD]
   889                          ;** Cancels Insert, Reverse and Quote modes
   890                          ;*********************************************************************************************************
   891                          
   892                          ESCAPE_O
   893  e3bd a900               ESCAPE		LDA #0
   894  e3bf 85dc               		STA INSRT
   895  e3c1 859f               		STA ReverseFlag
   896  e3c3 85cd               		STA QuoteMode
   897                          
   898  e3c5 85f1               !IF ESCCODES = 1 { STA LASTCHAR }
   899                          
   900  e3c7 4c99e1             		JMP IRQ_EPILOG
   901                          
   902                          ;*********************************************************************************************************
   903                          ;** WIN_SCROLL_DN / ESCAPE_W  [E3C8] (Called from Jump Table)
   904                          ;** Scrolls the current Window DOWN 
   905                          ;*********************************************************************************************************
   906                          
   907                          ESCAPE_W
   908  e3ca a6e1               WIN_SCROLL_DN	LDX BotMargin
   909  e3cc e8                 		INX
   910  e3cd ca                 Be3cb		DEX
   911  e3ce 2058e0             		JSR UPDATE_CURSOR_R2			;@@@@@@@@@@ was: JSR CURSOR_LM	; Was: Cursor_BOL
   912  e3d1 e4e0               		CPX TopMargin
   913  e3d3 f025               		BEQ Be3fe
   914                          
   915                          !IF COLOURPET=0 {
   916                          	!IF SS40=0 {
   917                          		LDA Line_Addr_Lo-1,X    		; Screen Line address table LO - 1
   918                          		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   919                          		LDA Line_Addr_Hi-1,X 			; Screen Line address table HI - 1
   920                          		STA SAL+1
   921                          	} ELSE {
   922                          		JSR SS40_SyncPointers2
   923                          	}
   924                          } ELSE {
   925  e3d5 2090ee             		JSR ColourPET_SyncPointers2 		; Synchronize Pointers	@@@@@@@@@@@@@@@ COLOURPET
   926                          }
   927                          
   928  e3d8 c8                 Be3d8		INY
   929                          !IF COLOURPET=0 {
   930                          
   931                          		LDA (SAL),Y				; Read Character from Screen SOURCE
   932                          		STA (ScrPtr),Y				; Write it to Screen DESTINATION
   933                          } ELSE {
   934  e3d9 20ceee             		JSR ColourPET_Scroll_Dest
   935                          }
   936  e3dc c4d5               		CPY RightMargin
   937  e3de 90f8               		BCC Be3d8
   938  e3e0 b0eb               		BCS Be3cb
   939                          
   940                          ;*********************************************************************************************************
   941                          ;** WIN_SCROLL_UP / ESCAPE_V  [E3E8] (Called from Jump Table)
   942                          ;** Scrolls current Window UP 
   943                          ;*********************************************************************************************************
   944                          
   945                          ESCAPE_V						; ESC-V Scroll Up
   946                          WIN_SCROLL_UP
   947  e3e2 a6e0               		LDX TopMargin
   948  e3e4 ca                 		DEX
   949  e3e5 e8                 Be3e6		INX
   950  e3e6 2058e0             		JSR UPDATE_CURSOR_R2			;@@@@@@@@@@@@@@ was: CURSOR_LM			; Was: Cursor_BOL
   951  e3e9 e4e1               		CPX BotMargin
   952  e3eb b00d               		BCS Be3fe
   953                          
   954                          !IF COLOURPET=0 {
   955                          	!IF SS40=0 {	
   956                          		LDA Line_Addr_Lo+1,X			; Screen line address table LO + 1
   957                          		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   958                          		LDA Line_Addr_Hi+1,X			; Screen line address table HI + 1
   959                          		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   960                          	} ELSE {
   961                          		JSR SS40_SyncPointers
   962                          	}
   963                          } ELSE {
   964  e3ed 207bee             		JSR ColourPET_SyncPointers		; Synchronize Pointers	@@@@@@@@@@@@@@@ COLOURPET
   965                          }
   966                          
   967  e3f0 c8                 Be3f3		INY
   968                          !IF COLOURPET=0 {
   969                          		LDA (SAL),Y				; Read Character from Screen SOURCE
   970                          		STA (ScrPtr),Y				; Write to Screen DESTINATION
   971                          } ELSE {
   972  e3f1 20ceee             		JSR ColourPET_Scroll_Dest		; Scroll Character and Colour RAM	
   973                          }
   974  e3f4 c4d5               		CPY RightMargin
   975  e3f6 90f8               		BCC Be3f3
   976  e3f8 b0eb               		BCS Be3e6
   977                          
   978  e3fa 20d7ee             Be3fe		JSR ERASE_TO_EOL			; Clear the bottom line
   979                          
   980                          ;*********************************************************************************************************
   981                          ;** Check Keyboard Scroll Control E40B]
   982                          ;*********************************************************************************************************
   983                          

; ******** Source: scrollpause-b.asm
     1                          ; PET/CBM EDIT ROM - Scroll Pause/Resume Control - B
     2                          ; ================
     3                          
     4                          ;--------------- Check Keyboard Scroll Control
     5                          
     6  e3fd ad12e8             iE40B		LDA PIA1_Port_B		; PIA#1, Register 2 - Keyboard COL input
     7  e400 c9fe               iE40E		CMP #$FE        	; Is BIT 0 set? ie: key held down?
     8  e402 d00e               iE410		BNE iE420       	; no, skip scroll delay loop
     9                          
    10                          ;--------------- Scroll Delay and Pause
    11                          
    12  e404 a000               iE412		LDY #$00       		; Scroll delay
    13  e406 ea                 iE414		NOP
    14  e407 ca                 		DEX
    15  e408 d0fc               		BNE iE414       	; Loop back
    16  e40a 88                 		DEY
    17  e40b d0f9               		BNE iE414       	; Loop back
    18                          
    19  e40d a000               iE41B		LDY #$00        	; Clear keyboard buffer
    20  e40f 849e               		STY CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
    21  e411 60                 iE41F		RTS
    22                          
    23  e412 c9df               iE420		CMP #$DF        	; Is BIT 1 set? key held down?
    24  e414 d0fb               		BNE iE41F       	; no, return
    25  e416 ad12e8             iE424		LDA PIA1_Port_B		; PIA#1, Register 2 - Keyboard ROW input
    26  e419 c9df               		CMP #$DF        	; Is BIT 1 set? key held down?
    27  e41b f0f9               		BEQ iE424       	; yes, loop back
    28  e41d c9ff               		CMP #$FF        	; no keys?
    29  e41f f0f5               		BEQ iE424       	; yes, loop back
    30  e421 d0ea               		BNE iE41B       	; return back up to clear buffer

; ******** Source: editrom80.asm
   984                          
   985                          
   986                          ;*********************************************************************************************************
   987                          ;** Jiffy Clock Timer Correction Patch [E431]
   988                          ;*********************************************************************************************************
   989                          

; ******** Source: jiffyfix.asm
     1                          ; PET/CBM EDIT ROM - Jiffy Clock Timer Fix
     2                          ; ================
     3                          
     4                          ;************** Correct Jiffy Clock Timer
     5                          ; Patch for 50 Hz
     6                          ; TODO: Analyze JIFFY CLOCK differences from older ROMs
     7                          ; TODO: make selectable
     8                          
     9                          !if CODEBASE<2 {
    10                          ADVANCE_TIMER
    11  e423 20eaff             		JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA
    12  e426 e6f8               		INC JIFFY6DIV5			; Counter to speed TI by 6/5
    13  e428 a5f8               		LDA JIFFY6DIV5			; Counter to speed TI by 6/5
    14  e42a c906               		CMP #$06			; every 6 IRQ's
    15  e42c d02a               		BNE IRQ_NORMAL2			; no, jump back to IRQ routine
    16  e42e a900               		LDA #$00      			; yes, reset counter
    17  e430 85f8               		STA JIFFY6DIV5			; Counter to speed TI by 6/5
    18  e432 f0ef               		BEQ ADVANCE_TIMER		; re-do jiffy clock update
    19                          } ELSE {
    20                          
    21                          ADVANCE_TIMER_CORR
    22                          		LDA #6
    23                          		STA JIFFY6DIV5
    24                          ADVANCE_TIMER
    25                          		JSR ADVANCE_JIFFY_CLOCK		; In EDITROMEXT file
    26                          		DEC JIFFY6DIV5
    27                          		BEQ ADVANCE_TIMER_CORR
    28                          		RTS
    29                          }

; ******** Source: editrom80.asm
   990                          
   991                          
   992                          ;*********************************************************************************************************
   993                          ;** MAIN IRQ ENTRY [E442][E455] (Called from Jump Table) - FIXED ENTRY POINT!
   994                          ;** This entry point must not move! It is called directly from KERNAL
   995                          ;** The CRTC chip's V-Sync line is fed to a VIA to generate IRQ's. When an IRQ is triggered, the
   996                          ;** Clock is updated, the keyboard scanned, ieee polled and tape monitored.
   997                          ;*********************************************************************************************************
   998  e434 aaaaaaaaaaaaaaaa...!FILL $e442-*,$aa ; FIXED ENTRY POINT! This routine must not move!
   999                          ;#########################################################################################################
  1000                          

; ******** Source: irq.asm
     1                          ; PET/CBM EDIT ROM - IRQ Handler Routines
     2                          ; ================
     3                          ; The IRQ does the work of updating the clock/timer, checking interrupts and calling the keyboard scanner.
     4                          
     5                          
     6                          IRQ_MAIN
     7  e442 48                 		PHA
     8  e443 8a                 		TXA
     9  e444 48                 		PHA
    10  e445 98                 		TYA
    11  e446 48                 		PHA
    12  e447 ba                 		TSX
    13  e448 bd0401             		LDA STACK+4,X
    14  e44b 2910               		AND #16
    15  e44d f003               		BEQ Be452
    16  e44f 6c9200             		JMP (CBINV)	; Vector: BRK Instr. Interrupt [D478]
    17  e452 6c9000             Be452		JMP (CINV)	; Vector: Hardware Interrupt   [E455] Points to 'IRQ_NORMAL'
    18                          
    19                          ;*********************************************************************************************************
    20                          ;** IRQ_NORMAL [$E455]
    21                          ;*********************************************************************************************************
    22                          
    23                          ;************** IRQ (Called from Jump Table)
    24                          ; The IRQ is fired when the CRTC chip does a VSYNC, so the timing is
    25                          ; dependent on the CRTC configuration.
    26                          ; Normally: $E455
    27                          
    28                          IRQ_NORMAL
    29                          		!IF IRQFIX=1 {
    30                          			!IF CODEBASE=0 { JMP ADVANCE_TIMER }
    31                          			!IF CODEBASE=1 { JMP ADVANCE_TIMER }
    32                          			!IF CODEBASE=2 { JSR ADVANCE_TIMER }
    33                          		} ELSE {
    34  e455 20eaff             			JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA 			
    35                          		}
    36                          
    37                          ;		--------------------------------------- Blink the cursor
    38                          
    39                          IRQ_NORMAL2						; ie458
    40  e458 a5a7               		LDA Blink				; Cursor Blink enable: 0 = Flash Cursor
    41  e45a d018               		BNE Be474				; skip it
    42  e45c c6a8               		DEC BLNCT				; Timer: Countdown to Toggle Cursor
    43  e45e d014               		BNE Be474				; skip it
    44                          
    45  e460 a914               		LDA #$14				; default cursor blink rate (20)
    46                          !if REPEATOPT = 1 {
    47                          		BIT RPTFLG				; check repeat flag
    48                          		BPL ie468				; skip if not enabled
    49                          		LDA #2					; make cursor blink immediately
    50                          }
    51  e462 85a8               ie468		STA BLNCT				; store to blink countdown counter
    52  e464 a4c6               		LDY CursorCol				; Column where cursor lives
    53  e466 46aa               		LSR BlinkPhase				; Is it blinking?
    54  e468 b1c4               		LDA (ScrPtr),Y				; Get character from the screen
    55  e46a b004               		BCS Be470				; Yes, skip
    56  e46c e6aa               		INC BlinkPhase				; count
    57  e46e 85a9               		STA CursorChar				; Remember the character at cursor (to be restored when cursor moves)
    58  e470 4980               Be470		EOR #$80				; Flip the reverse bit
    59  e472 91c4               		STA (ScrPtr),Y				; Put it back on the screen
    60                          
    61                          ;		--------------------------------------- Prep for keyboard scanning [$E47B]
    62                          
    63  e474 a000               Be474		LDY #0
    64  e476 ad10e8             		LDA PIA1_Port_A 			; Keyboard ROW select - PIA#1, Register 0
    65                          							; Upper bits: IEEE and Cassette
    66                          							; Lower bits: Keyboard ROW select
    67                          !if CODEBASE<2 {
    68  e479 29f0               		AND #$F0				; Mask off lower 4 bits (reset keyboard scan row)
    69  e47b 8d10e8             		STA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    70  e47e ad10e8             		LDA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    71                          } 
    72                          
    73                          ;		--------------------------------------- Check IEEE and Cassette status
    74                          
    75  e481 0a                 		ASL					; Shift upper bits to lower 
    76  e482 0a                 		ASL 
    77  e483 0a                 		ASL 
    78  e484 1009               		BPL Be487				; Is CASSETTE#1 Sense? No, skip
    79                          
    80  e486 84f9               		STY CAS1				; Yes, Tape Motor Interlock #1
    81  e488 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt
    82  e48b 0908               		ORA #8					; Is CASSETTE#2 Sense?
    83  e48d d009               		BNE Be490				; No, skip
    84                          
    85  e48f a5f9               Be487		LDA CAS1				; Yes, Tape Motor Interlock #1
    86  e491 d008               		BNE Be493				; No, skip
    87                          
    88  e493 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    89  e496 29f7               		AND #$f7				; Mask off bit 4
    90  e498 8d13e8             Be490		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    91  e49b 9009               Be493		BCC Be49e
    92                          
    93  e49d 84fa               		STY CAS2				; Tape Motor Interlock #2
    94  e49f ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
    95  e4a2 0910               		ORA #16
    96  e4a4 d009               		BNE Be4a7
    97  e4a6 a5fa               Be49e		LDA CAS2				; Tape Motor Interlock #2
    98  e4a8 d008               		BNE Be4aa
    99  e4aa ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
   100  e4ad 29ef               		AND #$ef
   101  e4af 8d40e8             Be4a7		STA VIA_Port_B				; VIA Register 0 (flags)
   102  e4b2 20bbe4             Be4aa		JSR SCAN_KEYBOARD			; Scan the keyboard
   103                          
   104  e4b5 2023ef             !IF KEYRESET=1 {  JSR CheckReboot }			; Check for soft reset ******* should this go above Be474 ?????????????????
   105                          
   106  e4b8 4c00e6             		JMP IRQ_END				; Return from Interrupt
   107                          

; ******** Source: editrom80.asm
  1001                          
  1002                          ;!IF DEBUG=0 { !FILL $e4be-*,$aa }			;#################################################
  1003                          
  1004                          ;*********************************************************************************************************
  1005                          ;** KEYBOARD SCANNER  [E4BE]
  1006                          ;** The Keyboard is scanned during the IRQ and one keystroke is stored to KEYD. Other routines transfer
  1007                          ;** this keystroke to or from a small 10-byte buffer. The keyboard scanner does the actual interfacing to
  1008                          ;** the hardware to read the rows and columns of the keyboard matrix. When a key is pressed it gets the
  1009                          ;** keycode from the keyboard matrix table. If no key is pressed, then $FF is returned.
  1010                          ;*********************************************************************************************************
  1011                          
  1012                          !IF KEYSCAN=0 { !SOURCE "keyscan-g.asm" }		; Graphic Keyboard

; ******** Source: keyscan-b.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Scan - Business Keyboards
     2                          ; ================
     3                          ; Standard Business Keyboard scanner. Requires one keyboard table.
     4                          ;
     5                          ; OPTIONS: KEYBOARD=7 modifies scanner for CBM-II keyboard (16x6 matrix)
     6                          
     7                          ;--------------- Scan Keyboard (scnkey)
     8                          ; NOTE: The keyboard ROW select is reset to zero in IRQ routine
     9                          
    10                          SCAN_KEYBOARD
    11                          ;!if DEBUG = 1 { INC DBLINE+5 }		; DEBUG - 6th character on top line
    12                          
    13  e4bb a0ff               		LDY #$FF		; No Key
    14  e4bd 84a6               		STY Key_Image		; Key Image
    15  e4bf c8                 		INY
    16  e4c0 8498               		STY KEYFLAGS		; Flag: Print Shifted Chars.
    17  e4c2 a5e4               		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    18  e4c4 297f               		AND #$7F
    19  e4c6 85e4               		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    20                          		!IF KEYBOARD=7 {
    21                          			LDX #$60	; 96 bytes in table. X is used as offset into the table (CBM-II keyboard)
    22                          		} ELSE {
    23  e4c8 a250               			LDX #$50	; 80 bytes in table. X is used as offset into the table (normal keyboards)
    24                          		}
    25                          
    26                          SCAN_ROW
    27                          		!IF KEYBOARD=7 {
    28                          			 LDY #$06	; Number of Columns to check = 6 (CBM-II keyboard only)
    29                          		} ELSE {
    30  e4ca a008               			 LDY #$08	; Number of Columns to check = 8 (normal keyboards)
    31                          		}
    32                          
    33  e4cc ad12e8             		LDA PIA1_Port_B 	; Keyboard COL result
    34  e4cf cd12e8             		CMP PIA1_Port_B 	; Keyboard COL result
    35  e4d2 d0f6               		BNE SCAN_ROW		; Debounce
    36                          
    37  e4d4 4a                 SCAN_COL	LSR			; Shift the value right
    38  e4d5 b01f               		BCS SCAN_NEXT2		; If the bit was "1" then key is NOT down. Skip
    39                          
    40                          ;-------------- We have a key press. Look it up in the keyboard matrix
    41                          
    42  e4d7 48                 		PHA			; Save for later
    43  e4d8 bddce6             		LDA KEYBOARD_NORMAL-1,X	; Read Keyboard Matrix (X is offset)
    44  e4db d006               		BNE SCAN_NOSH		; Is it SHIFT key? No, skip
    45                          
    46                          ;-------------- SHIFT key Detected
    47                          
    48  e4dd a901               		LDA #$01		; Set the SHIFT flag
    49  e4df 8598               		STA KEYFLAGS		; Flag: Print Shifted Chars.
    50  e4e1 d012               		BNE SCAN_NEXT		; No, skip
    51                          
    52                          ;-------------- Non-SHIFT key
    53                          
    54  e4e3 c910               SCAN_NOSH	CMP #$10		; Is it REPEAT?
    55  e4e5 d008               		BNE SCAN_NORPT		; No, skip
    56                          
    57                          ;-------------- REPEAT key
    58                          
    59  e4e7 a5e4               		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    60  e4e9 0980               		ORA #$80
    61  e4eb 85e4               		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    62  e4ed 3006               		BMI SCAN_NEXT
    63                          
    64  e4ef c9ff               SCAN_NORPT	CMP #$FF		; Is it "no key"?
    65  e4f1 f002               		BEQ SCAN_NEXT		; Yes, skip
    66                          
    67                          ;-------------- Normal key
    68                          
    69  e4f3 85a6               		STA Key_Image		; Store the key
    70                          
    71  e4f5 68                 SCAN_NEXT	PLA			; Restore value from keyboard scan for next loop
    72  e4f6 ca                 SCAN_NEXT2	DEX			; Decrement keyboard table offset
    73  e4f7 f008               		BEQ SCAN_GOT		; If 0 we have completed the entire matrix...Process Key Image
    74                          
    75  e4f9 88                 		DEY			; Next COLUMN
    76  e4fa d0d8               		BNE SCAN_COL		; Go back up for next column bit
    77                          
    78                          ;-------------- Completed all bits in ROW, Increment ROW
    79                          
    80  e4fc ee10e8             		INC PIA1_Port_A		; Next Keyboard ROW
    81  e4ff d0c9               		BNE SCAN_ROW		; More? Yes, loop back
    82                          
    83                          ;-------------- Process Key Image
    84                          
    85  e501 a5a6               SCAN_GOT	LDA Key_Image		; Key Image
    86  e503 c597               		CMP KEYPRESSED		; Current Key Pressed: 255 = No Key
    87  e505 f006               		BEQ SCAN_PRESS		; If key is the same then it's being held down
    88                          
    89  e507 a210               		LDX #$10
    90  e509 86e6               		STX DELAY		; Repeat Delay Counter
    91  e50b d02f               		BNE SCAN_REC
    92                          
    93  e50d 24e4               SCAN_PRESS	BIT RPTFLG		; Check Repeat Flag: $80 = Repeat, $40 = disable
    94  e50f 301e               		BMI SCAN_DELAY2
    95  e511 705c               		BVS SCAN_OUT		; Exit
    96  e513 c9ff               		CMP #$FF		; No key?
    97  e515 f058               		BEQ SCAN_OUT		; Exit
    98  e517 c914               		CMP #$14
    99  e519 f00c               		BEQ SCAN_DELAY
   100  e51b c920               		CMP #$20
   101  e51d f008               		BEQ SCAN_DELAY
   102  e51f c91d               		CMP #$1D
   103  e521 f004               		BEQ SCAN_DELAY
   104  e523 c911               		CMP #$11
   105  e525 d048               		BNE SCAN_OUT		; Exit
   106                          
   107  e527 a6e6               SCAN_DELAY	LDX DELAY		; Repeat Delay Counter
   108  e529 f004               		BEQ SCAN_DELAY2
   109  e52b c6e6               		DEC DELAY		; Repeat Delay Counter
   110  e52d d040               		BNE SCAN_OUT		; Exit
   111                          
   112  e52f c6e5               SCAN_DELAY2	DEC KOUNT		; Repeat Speed Counter
   113  e531 d03c               		BNE SCAN_OUT		; Exit
   114  e533 a204               		LDX #$04
   115  e535 86e5               		STX KOUNT		; Repeat Speed Counter
   116  e537 a69e               		LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   117  e539 ca                 		DEX			; One less
   118  e53a 1033               		BPL SCAN_OUT		; Exit
   119                          
   120  e53c 8597               SCAN_REC	STA KEYPRESSED		; Current Key Pressed: 255 = No Key
   121  e53e c9ff               		CMP #$FF		; No Key?
   122  e540 f02d                		BEQ SCAN_OUT		; Yes, exit
   123                          
   124  e542 aa                 		TAX
   125  e543 08                 		PHP
   126  e544 297f               		AND #$7F		; Mask off upper bit (non-shiftable flag in key matrix byte)
   127  e546 28                 		PLP
   128  e547 3017               		BMI SCAN_NORM
   129                          
   130                          ;-------------- Process SHIFT key flag with Numeric Keys or Graphic keys
   131                          
   132  e549 4698               		LSR KEYFLAGS		; Check for SHIFT
   133  e54b 9013               		BCC SCAN_NORM		; No, store as-is
   134  e54d c92c               		CMP #$2C		; Is it less than 2C? 
   135  e54f 900d               		BCC SCAN_SHIFT		; Yes, skip
   136  e551 c93c               		CMP #$3C		; Is it greater than 3C?
   137  e553 b009               		BCS SCAN_SHIFT		; Yes, skip
   138  e555 e90f               		SBC #$0F		; No, it must me Numeric so subtract 15
   139  e557 c920               		CMP #$20		; Is it above <SPACE>
   140  e559 b005               		BCS SCAN_NORM		; Yes
   141                          
   142  e55b 6920               		ADC #$20		; Add 32 to convert to shifted symbol on number key
   143  e55d 2c                 		!byte $2C		; Hide the next instruction trick
   144                          
   145  e55e 0980               SCAN_SHIFT	ORA #$80		; Set upper bit for Graphics Symbol
   146                          
   147                          ;-------------- Put the KEY into the Buffer (Key in accumulator)
   148                          
   149                          SCAN_NORM
   150                          
   151  e560 4ca2ed             !IF ESCCODES=1 { JMP EUROSWAP }		; Check if Eurokeys need swapping
   152                          
   153  e563 a69e               SCAN_NORM2	LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   154  e565 e4e3               		CPX XMAX		; Size of Keyboard Buffer
   155  e567 b006               		BCS SCAN_OUT		; Exit if buffer full
   156  e569 9d6f02             		STA KEYD,X		; Put the key into the buffer
   157                          !IF BACKARROW=0 {
   158                          		INX			; Increment character count
   159                          		STX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   160                          } ELSE {
   161  e56c 20c5e7             		JSR TestBackArrow	; Patch/Hack to use SHIFT-BACKARROW as screen mode toggle (text/graphic)
   162                          }
   163                          
   164                          !if KEYBOARD != 1 {
   165                          ;		Compensate for STOP key not in standard position
   166                          		CMP #3			; Is keycode "3" (STOP key)?
   167                          		BNE SCAN_OUT
   168                          		LDA #$EF		; fool kernal into thinking STOP is pressed
   169                          		STA STKEY		; store it
   170                          }

; ******** Source: editrom80.asm
  1013  e56f 60                 }		; Business Keyboard
  1014                          !IF KEYSCAN=2 { !SOURCE "keyscan-din.asm" }		; German DIN Keyboard
  1015                          !IF KEYSCAN=3 { !SOURCE "keyscan-c64.asm" }		; C64 Keyboard
  1016                          !IF KEYSCAN=4 { !SOURCE "keyscan-cbm2.asm" }		; CBM2 Keyboard (future implementation)
  1017                          
  1018                          ;*********************************************************************************************************
  1019                          ;** JUMP_TO_TAB  [E570]
  1020                          ;** Tab positions are stored in a table of 80 bits (10 bytes). This routine
  1021                          ;*********************************************************************************************************
  1022                          
  1023  e570 a5c6               JUMP_TO_TAB	LDA CursorCol				; Get Cursor column on current line
  1024  e572 29f8               		AND #$f8				; mask off upper 5 bits
  1025  e574 8d3a03             		STA NextTab				; This will be the new column to jump to
  1026  e577 4a                 		LSR					; shift right 3 bits (divide by 8)
  1027  e578 4a                 		LSR
  1028  e579 4a                 		LSR
  1029  e57a aa                 		TAX
  1030  e57b a901               		LDA #1					; Set bit 0 to 1
  1031  e57d 8d3e03             		STA DOS_Syntax				; temp storage
  1032  e580 a4c6               		LDY CursorCol				; Get Cursor column on current line
  1033  e582 cc3a03             JTTAB1 		CPY NextTab				; LOOP[ Is 
  1034  e585 f009               		BEQ JTTABDONE				;   Yes, exit out
  1035  e587 0e3e03             		ASL DOS_Syntax				;   No, Move the "1" bit forward
  1036  e58a ee3a03             		INC NextTab				;   Move ahead one column
  1037  e58d 4c82e5             		JMP JTTAB1				; ] Loop back for more
  1038  e590 60                 JTTABDONE	RTS
  1039                          
  1040                          ;		--------------------------------------- Check for CTRL-Y
  1041                          
  1042                          Scroll_Or_Select_Charset
  1043                          
  1044  e591 c919               		CMP #$19 				; Is it CTRL-Y? (Scroll window up)
  1045  e593 d006               		BNE Be59b				; No, skip ahead
  1046  e595 20e2e3             		JSR WIN_SCROLL_UP 			; Yes, Window Scroll Up
  1047  e598 4cd5e5             		JMP Me5d9
  1048                          
  1049                          ;		--------------------------------------- Check for CTRL-O
  1050                          
  1051  e59b c90f               Be59b		CMP #15 				; Is it CTRL-O (Set Window Top-Left)
  1052  e59d d00b               		BNE Be5aa				; No, skip ahead
  1053                          
  1054                          ;*********************************************************************************************************
  1055                          ;** ESCAPE_T
  1056                          ;** This sets the Window's Top-Left corner to the current cursor position
  1057                          ;*********************************************************************************************************
  1058                          
  1059  e59f a5d8               ESCAPE_T	LDA CursorRow				; Get current cursor ROW
  1060  e5a1 85e0               		STA TopMargin				; Store it as the TOP
  1061  e5a3 a5c6               		LDA CursorCol				; Get current cursor COL
  1062  e5a5 85e2               		STA LeftMargin				; Store it as the LEFT
  1063  e5a7 4c99e1             Be5a7		JMP IRQ_EPILOG
  1064                          
  1065                          ;		--------------------------------------- Check for CTRL-N
  1066                          
  1067  e5aa c90e               Be5aa		CMP #14 				; Is it CTRL-N? (Text mode)
  1068  e5ac d005               		BNE Be5b3				; No, skip ahead
  1069  e5ae 2062e0             		JSR CRT_SET_TEXT			; Yes, do it
  1070  e5b1 30f4               		BMI Be5a7
  1071                          
  1072                          ;		--------------------------------------- Check for CTRL-G
  1073                          
  1074  e5b3 c907               Be5b3		CMP #7 					; Is it CTRL-G? (Ring Bell)
  1075  e5b5 d0f0               		BNE Be5a7				; No, skip ahead
  1076  e5b7 20aee6             		JSR BEEP				; Yes, do BEEP
  1077  e5ba f0eb               		BEQ Be5a7
  1078                          
  1079                          ;*********************************************************************************************************
  1080                          ;** ProcControl_A  [E5BC]
  1081                          ;** Continue checking codes.
  1082                          ;*********************************************************************************************************
  1083                          
  1084                          ProcControl_A
  1085                          !IF COLOURPET=0 {
  1086                          		CMP #$15 				; Is it CTRL-SHIFT-U? (Insert Line) - CONFLICT with colour code = DK YELLOW					
  1087                          		BNE ProcControl_C			; @@@@@@ Was: BNE ProcControl_B
  1088                          } ELSE {
  1089  e5bc 4cd1e5             		JMP ProcControl_C
  1090                          }
  1091                          
  1092                          ;*********************************************************************************************************
  1093                          ;** ESCAPE_I
  1094                          ;** Insert a blank line at current cursor position
  1095                          ;*********************************************************************************************************
  1096                          
  1097  e5bf a5e0               ESCAPE_I	LDA TopMargin
  1098  e5c1 48                 		PHA
  1099  e5c2 a5d8               		LDA CursorRow
  1100  e5c4 85e0               		STA TopMargin
  1101  e5c6 20cae3             		JSR WIN_SCROLL_DN			; Scroll Window Down
  1102  e5c9 68                 Me5ca		PLA
  1103  e5ca 85e0               		STA TopMargin
  1104  e5cc 204fe0             		JSR CURSOR_LM
  1105  e5cf d015               		BNE EB_DONE
  1106                          
  1107                          ;[E5D2]		--------------------------------------- Check for CTRL-SHIFT-Y
  1108                          
  1109  e5d1 c919               ProcControl_C	CMP #$19 				; Is it CTRL-SHIFT-Y? (Scroll window up)
  1110  e5d3 d005               		BNE Be5de				; No, skip ahead
  1111                          
  1112                          !IF COLOURPET=0 {
  1113                          		JSR WIN_SCROLL_DN			; CONFLICT with colour code = LT GREEN
  1114                          }
  1115  e5d5 2053e0             Me5d9		JSR UPDATE_CURSOR_ROW
  1116  e5d8 d00c               		BNE EB_DONE
  1117                          
  1118                          ;[E5DE]		--------------------------------------- Check for CTRL-SHIFT-O
  1119                          
  1120  e5da c90f               Be5de		CMP #15 				; Is it CTRL-SHIFT-O? (Set Window Bottom)
  1121  e5dc d00b               		BNE Be5ed				; No, skip ahead
  1122                          
  1123                          
  1124                          ;*********************************************************************************************************
  1125                          ;** ESCAPE_B
  1126                          ;** Set Windos Bottom-Left
  1127                          ;*********************************************************************************************************
  1128                          
  1129  e5de a5d8               ESCAPE_B	LDA CursorRow
  1130  e5e0 85e1               		STA BotMargin
  1131  e5e2 a5c6               		LDA CursorCol
  1132  e5e4 85d5               		STA RightMargin
  1133  e5e6 4c99e1             EB_DONE		JMP IRQ_EPILOG
  1134                          
  1135                          ;[E5ED]		--------------------------------------- Check for CTRL-SHIFT-N
  1136                          
  1137  e5e9 c90e               Be5ed		CMP #14 				; Is it CTRL-SHIFT-N? (Graphics mode)
  1138  e5eb d0c6               		BNE Be5b3				; No, skip ahead
  1139  e5ed 206ae0             		JSR CRT_SET_GRAPHICS			; Yes, do it
  1140  e5f0 30f4               		BMI EB_DONE
  1141                          
  1142                          ;*********************************************************************************************************
  1143                          ;** IRQ_END  [E600]  (Called from Jump Table) - FIXED ENTRY POINT!
  1144                          ;** The IRQ routine jumps here when completed. Do not modify this routine!
  1145                          ;*********************************************************************************************************
  1146  e5f2 aaaaaaaaaaaaaaaa...!FILL $e600-*,$aa ;FIXED ENTRY POINT! This routine must not move! It is called directly from KERNAL
  1147                          ;#########################################################################################################
  1148                          
  1149  e600 68                 IRQ_END		PLA
  1150  e601 a8                 		TAY
  1151  e602 68                 		PLA
  1152  e603 aa                 		TAX
  1153  e604 68                 		PLA
  1154  e605 40                 		RTI
  1155                          
  1156                          ;*********************************************************************************************************
  1157                          ;** RESTORE_CHR_AT_CRSR  [E606]
  1158                          ;** This routine is called to put the character back at the cursor position.
  1159                          ;** It is called to put the initial character on the screen and as part of the cursor blinking routine.
  1160                          ;** NOTE: ColourPET: DOES NOT set/change COLOUR ATTRIBUTE!
  1161                          ;*********************************************************************************************************
  1162                          
  1163                          RESTORE_CHR_AT_CRSR
  1164  e606 a4c6               		LDY CursorCol				; Cursor Column on Current Line		
  1165  e608 91c4               		STA (ScrPtr),Y				; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
  1166  e60a a902               		LDA #2					; Set blink count so cursor appears immediately
  1167  e60c 85a8               		STA BLNCT				; Timer: Countdown to Toggle Cursor
  1168  e60e 60                 		RTS
  1169                          
  1170                          ;*********************************************************************************************************
  1171                          ;** INIT_EDITOR  [E60F]
  1172                          ;** Initializes the Editor. Clears Clock. Sets IRQ Vector. Sets Keyboard buffer size. Clears TABs.
  1173                          ;** Sets zero-page locations. And finally, chimes the BELL.
  1174                          ;*********************************************************************************************************
  1175                          
  1176  e60f a97f               INIT_EDITOR	LDA #$7f
  1177  e611 8d4ee8             		STA VIA_IER				; VIA, Register E - I/O Timers
  1178  e614 a26d               		LDX #$6d
  1179  e616 a900               		LDA #0
  1180  e618 85e8               		STA HOMECT				; Clear Home Count (80-col)
  1181                          	
  1182                          !IF REPEATOPT = 1 { STA RPTFLG }			; Clear REPEAT ($80 = Repeat, $40 = disable)
  1183                          
  1184  e61a 958d               INITED1		STA JIFFY_CLOCK,X			; Clear Real-Time Jiffy Clock (approx) 1/60 Sec
  1185  e61c ca                 		DEX
  1186  e61d 10fb               		BPL INITED1
  1187  e61f 8698               		STX KEYFLAGS 				; $FF = Clear all flags
  1188                          
  1189                          ;		--------------------------------------- Set IRQ Vector - Normally $E455 or $E900 for Execudesk
  1190                          
  1191                          !IF EXECUDESK=1 {
  1192                          		LDA #<IRQ_EDESK				; Execudesk IRQ Vector LO
  1193                          		STA CINV
  1194                          		LDA #>IRQ_EDESK				; Execudesk IRQ Vector HI
  1195                          		STA CINV+1
  1196                          } ELSE {
  1197  e621 a955               		LDA #<IRQ_NORMAL			; Normal IRQ Vector LO
  1198  e623 8590               		STA CINV
  1199  e625 a9e4               		LDA #>IRQ_NORMAL			; Normal IRQ Vector HI
  1200  e627 8591               		STA CINV+1
  1201                          }
  1202                          
  1203                          ;		--------------------------------------- Init SS40
  1204                          
  1205                          !IF SS40=1 {
  1206                          	!IF HARD4080=1 {
  1207                          		LDA #1					; 40/80 Switcher board INSTALLED
  1208                          		STA SCN4080BOARD
  1209                          	} ELSE {
  1210                          		LDA #0					; 40/80 Switcher board NOT installed
  1211                          		STA SCN4080BOARD	
  1212                          	}
  1213                          
  1214                          	!IF SS40MODE=80 {
  1215                          		JSR SS40_INIT80				; Initialize Switchable Soft-40 to 80 columns
  1216                          	} ELSE {
  1217                          		JSR SS40_INIT40				; Initialize Switchable Soft-40 to 40 columns
  1218                          	}
  1219                          }
  1220                          ;		--------------------------------------- Continue
  1221                          
  1222  e629 a909               		LDA #$09
  1223  e62b 85e3               		STA XMAX				; Size of Keyboard Buffer
  1224  e62d a903               		LDA #$03
  1225  e62f 85b0               		STA DFLTO				; Default Output (CMD) Device (3)
  1226  e631 a90f               		LDA #15
  1227  e633 8d10e8             		STA PIA1_Port_A 			; Keyboard ROW select
  1228  e636 0a                 		ASL 
  1229  e637 8d40e8             		STA VIA_Port_B
  1230  e63a 8d42e8             		STA VIA_DDR_B
  1231  e63d 8e22e8             		STX PIA2_Port_B
  1232  e640 8e45e8             		STX VIA_Timer_1_Hi
  1233  e643 a93d               		LDA #$3d
  1234  e645 8d13e8             		STA PIA1_Cont_B
  1235  e648 2c12e8             		BIT PIA1_Port_B 			; Keyboard COL read
  1236  e64b a93c               		LDA #$3c
  1237  e64d 8d21e8             		STA PIA2_Cont_A
  1238  e650 8d23e8             		STA PIA2_Cont_B
  1239  e653 8d11e8             		STA PIA1_Cont_A
  1240  e656 8e22e8             		STX PIA2_Port_B
  1241  e659 a90e               		LDA #14
  1242  e65b 85a8               		STA BLNCT				; Timer: Countdown to Toggle Cursor
  1243  e65d 85a7               		STA Blink				; Cursor Blink enable: 0 = Flash Cursor
  1244  e65f 85e6               		STA DELAY				; Repeat Delay Counter
  1245  e661 85e5               		STA KOUNT				; Repeat Speed Counter
  1246  e663 8d4ee8             		STA VIA_IER
  1247  e666 20c8e1             		JSR FULL_SCREEN				; Exit Window - Set screen size (ie: 80x25)
  1248                          
  1249                          ;[E669]		--------------------------------------- Clear Tab Stops (80 bits) 
  1250                          
  1251  e669 a20c               CLEAR_TABS	LDX #12					; 12 bytes (10 bytes plus?)
  1252  e66b a900               		LDA #0					; To Clear the table
  1253  e66d 9dee03             CT_LOOP		STA TABS_SET,X				; LOOP[  Table of 80 bits to set TABs
  1254  e670 ca                 		DEX					;   next byte
  1255  e671 10fa               		BPL CT_LOOP				; ] Loop back for more
  1256                          
  1257                          ;		--------------------------------------- Set Screen Input and Output Vectors
  1258                          
  1259  e673 a91d               		LDA #<DEFAULT_SCREEN_VECTOR		; LO Address of Screen Input vector (from E006)
  1260  e675 a2e1               		LDX #>DEFAULT_SCREEN_VECTOR		; HI 
  1261  e677 85e9               		STA SCRIV				; Input from screen vector (from E006)
  1262  e679 86ea               		STX SCRIV+1				; Input from screen vector (from E006)
  1263                          
  1264  e67b a90c               		LDA #<CHROUT_NORMAL
  1265  e67d a2e2               		LDX #>CHROUT_NORMAL
  1266  e67f 85eb               		STA SCROV				; Print to screen vector (from E009)
  1267  e681 86ec               		STX SCROV+1				; Print to screen vector (from E009)
  1268                          
  1269  e683 a910               		LDA #$10
  1270  e685 85e7               		STA CHIME
  1271                          
  1272                          ;		--------------------------------------- Patches for new features here
  1273                          
  1274                          !IF ESCCODES=1 {
  1275  e687 a901               		LDA #1					; 1=Enabled
  1276  e689 85f2               		STA BELLMODE				; Flag to Enable BELL
  1277                          }
  1278  e68b 2012e9             !IF AUTORUN=1 {	JSR AUTOSTART }				; Do Auto Run Prep
  1279                          
  1280                          ;		--------------------------------------- Finish up by ringing BELL 4 times
  1281                          
  1282  e68e 20abe6             		JSR BEEP_BEEP				; Power-up chimes
  1283  e691 f018               		BEQ BEEP_BEEP				; More chimes (4 total)
  1284                          
  1285                          
  1286                          ;*********************************************************************************************************
  1287                          ;** ChrOutMarginBeep  [E68C]
  1288                          ;** Checks the cursor position and rings the BELL if near the end of the line
  1289                          ;*********************************************************************************************************
  1290                          
  1291                          ChrOutMarginBeep
  1292  e693 2002e2             		JSR CHROUT_SCREEN			; Output to Screen
  1293  e696 aa                 		TAX
  1294  e697 a5d5               		LDA RightMargin				; Physical Screen Line Length
  1295  e699 38                 		SEC
  1296  e69a e5c6               		SBC CursorCol				; Cursor Column on Current Line
  1297  e69c c905               		CMP #5					; 5 characters from end of line
  1298  e69e d03c               		BNE BELLDONE
  1299  e6a0 8a                 		TXA
  1300  e6a1 c91d               		CMP #$1d 				; <Cursor Right> ?
  1301  e6a3 f006               		BEQ BEEP_BEEP				; Ring BELL
  1302  e6a5 297f               		AND #$7f
  1303  e6a7 c920               		CMP #$20 				; <SPACE>
  1304  e6a9 9031               		BCC BELLDONE
  1305                          
  1306                          ;*********************************************************************************************************
  1307                          ;** BEEP / BEEP_BEEP  [E6A7]
  1308                          ;** Rings the BELL
  1309                          ;*********************************************************************************************************
  1310                          
  1311  e6ab 20aee6             BEEP_BEEP	JSR BEEP				; Double BEEP
  1312                          BEEP							; Single BEEP
  1313                          
  1314                          !IF SILENT=0 {
  1315  e6ae a4e7               		LDY CHIME				; Chime Time FLAG
  1316                          } ELSE {
  1317                          		!IF CRUNCH=0 { NOP }			; To keep code aligned
  1318                          		RTS
  1319                          }
  1320                          
  1321                          !IF ESCCODES=1 {
  1322  e6b0 a5f2               		LDA BELLMODE
  1323  e6b2 1001               		BPL BELLENABLED
  1324  e6b4 60                 		RTS
  1325                          }
  1326  e6b5 f025               BELLENABLED	BEQ BELLDONE
  1327  e6b7 a910               		LDA #16
  1328  e6b9 8d4be8             		STA VIA_ACR
  1329  e6bc a90f               		LDA #15
  1330  e6be 8d4ae8             		STA VIA_Shift
  1331  e6c1 a207               		LDX #7
  1332  e6c3 bd59e7             BELLOOP1	LDA SOUND_TAB-1,X
  1333  e6c6 8d48e8             		STA VIA_Timer_2_Lo
  1334  e6c9 a5e7               		LDA CHIME				; Chime Time
  1335                          
  1336  e6cb 88                 BELLOOP2	DEY
  1337  e6cc d0fd               		BNE BELLOOP2				; Delay loop
  1338  e6ce 38                 		SEC
  1339  e6cf e901               		SBC #1
  1340  e6d1 d0f8               		BNE BELLOOP2				; Delay loop
  1341  e6d3 ca                 		DEX
  1342  e6d4 d0ed               		BNE BELLOOP1				; Delay loop
  1343  e6d6 8e4ae8             		STX VIA_Shift
  1344  e6d9 8e4be8             		STX VIA_ACR
  1345  e6dc 60                 BELLDONE	RTS
  1346                          
  1347                          ;*********************************************************************************************************
  1348                          ;** Keyboard Decoding Table  [E6D1]
  1349                          ;*********************************************************************************************************
  1350                          

; ******** Source: keyboard.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Selection
     2                          ; ================
     3                          ; This adds the appropriate keyboard matrix or matrices depending on options:
     4                          ; KEYSCAN=n  -- which keyboard scanning routine is used
     5                          ; KEYBOARD=n -- to select the matrix layout
     6                          ;
     7                          ; Note: Not all keyboards are defined for all options! Please check source
     8                          ;------------------------------------------------------------------------------
     9                          
    10                          !if KEYSCAN=0 { !source "keyboard-tables1.asm" }	; Graphic (Normal) Keyboard Scanner - Simple

; ******** Source: keyboard-tables1.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Tables for KEYSCAN-N, KEYSCAN-B scanner code
     2                          ; ================
     3                          ; 
     4                          ; Notes:
     5                          ;	Modifier Keys: 00 = Shift, 10 = Repeat, 80 = CTRL
     6                          ;	Special Codes: Bit 7 set (+$80) = Unshiftable, FF = No Key
     7                          ;       Labelling:
     8                          ;	   KP = Keypad, S- = Shift , GR- = Graphic Code, NONE = No Key
     9                          ;          CTRL- = CTRL+key , SHC- = Shift-CTRL+key, A- = Accent
    10                          
    11                          KEYBOARD_NORMAL
    12                          
    13                          ;---------- Normal/Graphic Keyboard - QWERTY Layout (chicklet or standard type)
    14                          ;
    15                          !IF KEYBOARD=0 {
    16                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    17                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    18                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A
    19                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
    20                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
    21                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
    22                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
    23                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
    24                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
    25                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
    26                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
    27                          !byte $1d,$13,$5f,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J
    28                          }
    29                          
    30                          ;---------- Business Keyboard - QWERTY Layout
    31                          ;
    32                          !IF KEYBOARD=1 {
    33                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    34                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    35  e6dd 16043a03393633df   !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A
    36  e6e5 b12f15134d205812   !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
    37  e6ed b2100fb02c4e565a   !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
    38  e6f5 b30019ae2e424300   !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
    39  e6fd b4db4f1155544551   !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
    40  e705 145049dc59525709   !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
    41  e70d b6c04c0d4a474441   !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
    42  e715 b53b4bdd4846539b   !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
    43  e71d b906deb7b0373431   !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
    44  e725 050e1db82d383532   !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
    45                          }
    46                          
    47                          ;---------- Business Keyboard - German DIN, QWERTZ (Version 1) Layout
    48                          ;
    49                          !IF KEYBOARD=2 {
    50                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES
    51                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    52                          !byte $16,$04,$40,$03,$39,$36,$33,$5F ; CTRL-V CTRL-D @      STOP   9      6      3      BK-ARR ROW0/A  ..x....x
    53                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   M      SPACE  x      RVS    ROW1/B  ........
    54                          !byte $B2,$80,$0F,$01,$2C,$4E,$56,$59 ; KP 2   CTRL   CTRL-O KP 0   ,      n      v      y      ROW2/C  .x.x...x <- $80=CTRL (was $10=REPEAT)
    55                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D  ........ <- $00=SHIFT
    56                          !byte $B4,$5B,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E  .x......
    57                          !byte $14,$50,$49,$3A,$5A,$52,$57,$09 ; DEL    p      i      :      z      r      w      TAB    ROW5/F  ...xx...
    58                          !byte $B6,$5D,$4C,$0D,$4A,$47,$44,$41 ; KP 6   ]      l      RETURN j      g      d      a      ROW6/G  .x......
    59                          !byte $B5,$5C,$4B,$3B,$48,$46,$53,$1B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H  .......x
    60                          !byte $B9,$06,$5E,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I  ..x.....
    61                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J  ........
    62                          }
    63                          
    64                          ;---------- C64/VIC-20 Keyboard
    65                          ;
    66                          ; Keyboard will plug directly into the PET keyboard connector.
    67                          ; It is electrically compatible, but only uses an 8x8 matrix of keys.
    68                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
    69                          ;
    70                          ; * Code Change: SHIFT=01 with 00
    71                          ; * Reassign   : POUND as \=5C, CTRL as RVS=12, C= as ESC=9B
    72                          ; * Reassign   : F1 as TEXT=0E, F3 as DELETE LINE=15, F5 as ERASE TO START=16, F7 as SCROLL DOWN=19
    73                          
    74                          !IF KEYBOARD=3 {
    75                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    76                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    77                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A
    78                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B
    79                          !byte $19,$13,$2D,$30,$38,$36,$34,$32 ; F7     HOME   -      0      8      6      4      2      ROW2/C
    80                          !byte $16,$5E,$40,$4F,$55,$54,$45,$51 ; F5     UP-ARR @      O      U      T      E      Q      ROW3/D
    81                          !byte $15,$3D,$3A,$4B,$48,$46,$53,$9B ; F3     =      :      K      H      F      S      C=     ROW4/E
    82                          !byte $0E,$00,$2E,$4D,$42,$43,$5A,$20 ; F1     SHIFT  .      M      B      C      Z      SPACE  ROW5/F
    83                          !byte $11,$2F,$2C,$4E,$56,$58,$00,$03 ; DOWN   /      ,      N      V      X      SHIFT  STOP   ROW6/G
    84                          !byte $1D,$3B,$4C,$4A,$47,$44,$41,$12 ; RIGHT  ;      L      J      G      D      A      CTRL   ROW7/H
    85                          !byte $0D,$2A,$50,$49,$59,$52,$57,$DF ; RETURN *      P      I      Y      R      W      BK-ARR ROW8/I
    86                          !byte $14,$5C,$2B,$39,$37,$35,$33,$31 ; DEL    POUND  +      9      7      5      3      1      ROW9/J
    87                          }
    88                          
    89                          ;---------- Business Keyboard - Modified QWERTY Layout - BSJG
    90                          ;
    91                          ; This is a B keyboard with re-arranged layout to make it closer to C64 keyboard
    92                          ; ESC moved to top left. Cursor keys to bottom CLR/HOME and INS/DEL moved to top row
    93                          ; REPEAT moved to bottom left.
    94                          ;
    95                          !IF KEYBOARD=4 {
    96                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    97                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== ======
    98                          !byte $16,$04,$3A,$14,$39,$36,$33,$9B ; CTRL-V CTRL-D :      DEL    9      6      3      ESC    ROW0/A 
    99                          !byte $B1,$2F,$15,$1D,$4D,$20,$58,$10 ; KP 1   /      CTRL-U RIGHT  m      SPACE  x      REPT   ROW1/B 
   100                          !byte $B2,$11,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   DOWN   CTRL-O KP 0   ,      n      v      z      ROW2/C
   101                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      n      c      SHIFT  ROW3/D
   102                          !byte $B4,$DB,$4F,$DF,$55,$54,$45,$51 ; KP 4   [      o      BK-ARR u      t      e      q      ROW4/E
   103                          !byte $DE,$50,$49,$DD,$59,$52,$57,$09 ; UP-ARR p      i      ]      y      r      w      TAB    ROW5/F
   104                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   105                          !byte $B5,$3B,$4B,$DC,$48,$46,$53,$03 ; KP 5   ;      k      \      h      f      s      STOP   ROW7/H
   106                          !byte $B9,$06,$12,$B7,$B0,$37,$34,$31 ; KP     CTRL-F RVS    KP 7   0      7      4      1      ROW8/I
   107                          !byte $05,$0E,$13,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N HOME   KP 8   -      8      5      2      ROW9/J
   108                          }
   109                          
   110                          ;---------- Graphic Keyboard - Modified QWERTY Layout - NSJG
   111                          ;
   112                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none,
   113                          ; so the "@" key is used instead as it occupies the position an ESC key would normally be. The BACKARROW
   114                          ; key will become the "@" symbol so that the DOS wedge is usable (BACKARROW is rarely used).
   115                          ;
   116                          !IF KEYBOARD=5 {
   117                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   118                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   119                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    
   120                          !byte $2d,$30,$00,$3e,$ff,$5d,$9b,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      ESC    SHIFT  @ replaced with ESC
   121                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x
   122                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z
   123                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s
   124                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a
   125                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w
   126                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q
   127                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "
   128                          !byte $1d,$13,$40,$28,$26,$25,$23,$21 ; RIGHT  HOME   @      (      &      %      #      !      BACKARROW replaced by @
   129                          }
   130                          
   131                          ;---------- Business Keyboard - QWERTZ Layout
   132                          ;
   133                          !IF KEYBOARD=6 {
   134                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   135                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   136                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0 
   137                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1 
   138                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$59 ; KP 2   RPT    CTRL-O KP 0   ,      n      v      y      ROW2 
   139                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3
   140                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   ]      o      DOWN   u      t      e      q      ROW4 
   141                          !byte $14,$50,$49,$DC,$5A,$52,$57,$09 ; DEL    p      i      @      z      r      w      TAB    ROW5 
   142                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   [      l      RETURN j      g      d      a      ROW6
   143                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   \      k      ;      h      f      s      ESC    ROW7
   144                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8
   145                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9
   146                          }
   147                          
   148                          ;----------- Business Keyboard - French AZERTY Layout
   149                          ;
   150                          !IF KEYBOARD=7 {
   151                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   152                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   153                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A
   154                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
   155                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
   156                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   157                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
   158                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
   159                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   160                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
   161                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   162                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   163                          }
   164                          
   165                          ;----------- CBM-II (B-Series, P-Series) - QWERTY Layout
   166                          ;
   167                          ; The CBM-II keyboard has a 16*6 matrix, so it requires a hardware modification to work on the PET,
   168                          ; and a small modification to the keyboard scanning routine.
   169                          ; It also has many extra keys with no equivilent function, and so will have some non-functioning keys.
   170                          ;
   171                          ; *** WORK IN PROGRESS!!!!!!!
   172                          ;
   173                          !IF KEYBOARD=8 {
   174                          ;     C0  C1  C2  C3  C4  C5    COL0   COL1   COL2   COL3   COL4   COL5   NOTES 
   175                          ;     === === === === === ===   ====== ====== ====== ====== ====== ====== =====
   176                          !BYTE $E0,$1B,$09,$FF,$00,$01 ; F1     ESCAPE TAB    NONE   SHIFT  CTRL   ROW0/A
   177                          !BYTE $E1,$31,$51,$41,$5A,$FF ; F2     1      Q      A      Z      NONE   ROW1/B
   178                          !BYTE $E2,$32,$57,$53,$58,$43 ; F3     2      W      S      X      C      ROW2/C
   179                          !BYTE $E3,$33,$45,$44,$46,$56 ; F4     3      E      D      F      V      ROW3/D
   180                          !BYTE $E4,$34,$52,$54,$47,$42 ; F5     4      R      T      G      B      ROW4/E
   181                          !BYTE $E5,$35,$36,$59,$48,$4E ; F6     5      6      Y      H      N      ROW5/F
   182                          !BYTE $E6,$37,$55,$4A,$4D,$20 ; F7     7      U      J      M      SPACE  ROW6/G
   183                          !BYTE $E7,$38,$49,$4B,$2C,$2E ; F8     8      I      K      ,      .      ROW7/H
   184                          !BYTE $E8,$39,$4F,$4C,$3B,$2F ; F9     9      O      L      ;      /      ROW8/I
   185                          !BYTE $E9,$30,$2D,$50,$5B,$27 ; F10    0      -      P      [      '      ROW9/J
   186                          !BYTE $11,$3D,$5F,$5D,$0D,$DE ; DOWN   =      _      ]      RETURN PI     ROW10/K
   187                          !BYTE $91,$9D,$1D,$14,$02,$FF ; UP     LEFT   RIGHT  DEL    CMDR   NONE   ROW11/L
   188                          !BYTE $13,$3F,$37,$34,$31,$30 ; HOME   ?      7      4      1      0      ROW12/M
   189                          !BYTE $12,$04,$38,$35,$32,$2E ; RVS    CE     8      5      2      .      ROW13/N
   190                          !BYTE $8E,$2A,$39,$36,$33,$30 ; GRAPH  *      9      6      3      00     ROW14/O
   191                          !BYTE $03,$2F,$2D,$2B,$0D,$FF ; STOP   /      -      +      ENTER  NONE   ROW15/P
   192                          }
   193                          
   194                          ;----------- Normal/Graphic Keyboard - Modified QWERTY Layout with [ESC] modification
   195                          ;
   196                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none.
   197                          ; This layout changes the BACKARROW to ESC.
   198                          ;
   199                          !IF KEYBOARD=9 {
   200                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   201                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   202                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A
   203                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
   204                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   205                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   206                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   207                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   208                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   209                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   210                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   211                          !byte $1d,$13,$1b,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J   BACKARROW replaced by @
   212                          }
   213                          
   214                          ;----------- TED Series (C116/C16/Plus4) QWERTY Layout
   215                          ;
   216                          ; The TED keyboards have different connectors depending on model. Also, the pinouts
   217                          ; do not group the ROWs and COLs so you will need to make an adapter cable.
   218                          ; TED keyboards have 4 separate cursor keys meaning no SHIFT is needed. This will likely
   219                          ; conflict with the keyboard scanner which uses the TOP BIT of the character to indicate
   220                          ; it cannot be shifted. Cursor UP and LEFT are normally shifted.
   221                          ;
   222                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
   223                          ;
   224                          ; * Code Change: SHIFT=01 with 00, CTRL with 80
   225                          ; * Reassign   : POUND as \=5C, C= as TEXT/GRAPHICS mode
   226                          ; * Reassign   : F1 as TEXT=0E, F2 as DELETE LINE=15, F3 as ERASE TO START=16, HELP as SCROLL DOWN=19
   227                          ;
   228                          ; NOTE: Pin 3=LED, Pin 4=GND
   229                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   230                          ;
   231                          !IF KEYBOARD=11 {
   232                          ;PIN: 17  14  13  2   6   8   9   16
   233                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   234                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   235                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A -
   236                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B -
   237                          !byte $31,$13,$00,$03,$20,$0E,$51,$32 ;	1      CLR    CTRL   STOP   SPACE  C=     Q      2      ROW2/C 5
   238                          !byte $33,$57,$41,$00,$5A,$53,$45,$34 ; 3      W      A      SHIFT  Z      S      E      4      ROW3/D 7
   239                          !byte $35,$52,$44,$58,$43,$46,$54,$36 ; 5      R      D      X      C      F      T      6      ROW4/E 11
   240                          !byte $37,$59,$47,$56,$42,$48,$55,$38 ; 7      Y      G      V      B      H      U      8      ROW5/F 10
   241                          !byte $39,$49,$4A,$4E,$4D,$4B,$4F,$30 ; 9      I      J      N      M      K      O      0      ROW6/G 12
   242                          !byte $11,$50,$4C,$2C,$2E,$3B,$2D,$91 ; DOWN   P      L      ,      .      :      -      UP     ROW7/H 1
   243                          !byte $9D,$2A,$3B,$2F,$1B,$3D,$2B,$1D ; LEFT   *      ;      /      ESC    =      +      RIGHT  ROW8/I 15
   244                          !byte $14,$0D,$5C,$40,$0E,$15,$16,$19 ; DEL    RETURN POUND  @      F1     F2     F3     HELP   ROW9/J 18
   245                          }
   246                          
   247                          ;----------- C128 Keyboard - Requires hardware mod for larger matrix
   248                          ;
   249                          ; This table is taken from a C128 ROM disassembly and re-formatted
   250                          ; This has not been tested! It looks like the ROWS and COLUMNS are
   251                          ; reversed compared to the PET/CBM keyboard scanner. This will either
   252                          ; require re-ordering the matrix, or re-wiring/adapting the connector.
   253                          ;
   254                          ; CHANGES:
   255                          ;           SHIFT ($01) to SHIFT ($00)
   256                          ;           CTRL  ($04) to CTRL  ($80)
   257                          ;           ALT   ($08) to SHIFT ($00)
   258                          ;           NOSCRL($FF) to SHIFT ($00)
   259                          ; PIN
   260                          ; 1   GROUND
   261                          ; 2   NO PIN (keyed)
   262                          ; 4   +5V
   263                          ; 
   264                          ; Keys not in matrix:
   265                          ;    RESTORE  = pin 1 and pin 3
   266                          ;    40/80    = pin 1 and pin 24
   267                          ;    CAPS LOCK= pin 1 and pin 25
   268                          ;
   269                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   270                          ;
   271                          !IF KEYBOARD=12 {
   272                          
   273                          ;PIN: 12  11  10  5   8   7   6   9
   274                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   275                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   276                          !byte $14,$0D,$1D,$88,$85,$86,$87,$11 ; DEL    RETURN RIGHT  .      .      .      .      DOWN   ROW0   13
   277                          !byte $33,$57,$41,$34,$5A,$53,$45,$00 ; 3      w      a      4      z      s      e      SHIFT  ROW1   19
   278                          !byte $35,$52,$44,$36,$43,$46,$54,$58 ; 5      r      d      6      c      f      t      x      ROW2   18
   279                          !byte $37,$59,$47,$38,$42,$48,$55,$56 ; 7      y      g      8      b      h      u      v      ROW3   17
   280                          !byte $39,$49,$4A,$30,$4D,$4B,$4F,$4E ; 9      i      j      0      m      k      o      n      ROW4   16
   281                          !byte $2B,$50,$4C,$2D,$2E,$3A,$40,$2C ; +      p      l      -      .      :      @      ,      ROW5   15
   282                          !byte $5C,$2A,$3B,$13,$00,$3D,$5E,$2F ; \      *      ;      HOME   SHIFT  =      ^      /      ROW6   14
   283                          !byte $31,$5F,$80,$32,$20,$02,$51,$03 ; 1      BARROW CTRL   2      SPACE  CBM    q      STOP   ROW7   20
   284                          !byte $84,$38,$35,$09,$32,$34,$37,$31 ; HELP   8      5      TAB    2      4      7      1      ROW8   21
   285                          !byte $1B,$2B,$2D,$0A,$0D,$36,$39,$33 ; ESC    +      -      LF     ENTER  6      9      3      ROW9   22
   286                          !byte $08,$30,$2E,$91,$11,$9D,$1D,$00 ; ALT    0      .      UP     DOWN   LEFT   RIGHT  NOSCRL ROW10  23

; ******** Source: keyboard.asm
    11                          }	; Business Keyboard Scanner - Simple with code for specific shifted keys
    12                          !if KEYSCAN=2 { !source "keyboard-tables2.asm" }	; Extended Keyboard Scanner - Two Tables (Normal and Shifted)
    13                          !if KEYSCAN=3 { !source "keyboard-tables3.asm" }	; C64 keyboard tables

; ******** Source: editrom80.asm
  1351                          
  1352                          
  1353                          ;*********************************************************************************************************
  1354                          ;** SHIFT RUN/STOP string  [E721]
  1355                          ;*********************************************************************************************************
  1356                          
  1357  e72d 44cc222a0d         RUN_STRING	!byte $44,$cc,$22,$2a,$0d		; dL"*<RETURN>
  1358  e732 52554e0d           		!byte $52,$55,$4e,$0d			; run<RETURN>
  1359                          
  1360                          ;*********************************************************************************************************
  1361                          ;** CRTC Chip Register Setup Tables (2K ROMs) [E72A]
  1362                          ;*********************************************************************************************************
  1363                          

; ******** Source: crtc-tables.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Table Selection
     2                          ; ================
     3                          ; Sets the CRTC Table depending on options
     4                          ; COLUMNS ---- 40 or 80 column hardware (with special cases 90 and 32)
     5                          ; SOFT40 ----- Software Defined 40-column modes
     6                          
     7                          
     8                          !IF COLUMNS=40 {
     9                          	!IF SOFT40=0 { !SOURCE "crtc-reg-normal.asm" }
    10                          	!IF SOFT40=1 { !SOURCE "crtc-reg-soft40.asm" }
    11                          } ELSE {

; ******** Source: crtc-reg-normal.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Tables
     2                          ; ================
     3                          ; For "normal" configurations (ie: for single main screen)
     4                          ; Sets the CRTC Table depending on options:
     5                          ; COLUMNS = 32,40,64,80,90
     6                          ;
     7                          ;======================================
     8                          ; NORMAL 4000/8000/8296/SuperPET MODELS
     9                          ;======================================
    10                          ; Common settings for "normal" machines (4000,8000,8296,SuperPET) with 12" monitor
    11                          ; NOTE: The 8296D uses a different monitor than the 8296 and requires a different register table (see below)
    12                          
    13                          ; REGISTER#->>>      DECIMAL: 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17
    14                          ;                        HEX: 00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  
    15                          ;                             ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==
    16                          ;
    17                          ;---------------------- 40/80x25, 50 Hz, 20 kHz for 12" Internal Monitor (inverted video R12=$10)
    18                          !IF REFRESH=0 {
    19                          CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$27,$00,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    20                          CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$31,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    21                          }
    22                          
    23                          ;---------------------- 40/80x25, 60 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    24                          !IF REFRESH=1 {
    25  e736 3128290f2003191d...CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$20,$03,$19,$1d,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    26  e748 3128290f28051921...CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    27                          }
    28                          
    29                          ;---------------------- 40/80x25, 50 Hz, 15.625 kHz (PAL)  for External Monitor (inverted video)
    30                          !IF REFRESH=2 {
    31                          CRT_CONFIG_TEXT:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    32                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    33                          }
    34                          
    35                          ;---------------------- 40/80x25, 60 Hz, 15.748 kHz (NTSC) for External Monitor (inverted video)
    36                          !IF REFRESH=3 {
    37                          CRT_CONFIG_TEXT:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    38                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    39                          }
    40                          
    41                          ;---------------------- 40/80x25, 50 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    42                          !IF REFRESH=4 {
    43                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    44                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    45                          }
    46                          
    47                          ;---------------------- 40/80x25, 60 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    48                          !IF REFRESH=5 {
    49                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    50                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    51                          }
    52                          
    53                          ;===============
    54                          ; 8296D MACHINES
    55                          ;===============
    56                          ; The 8296D has a different monitor than standard machines and requires slightly modified timing
    57                          
    58                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V1)
    59                          !IF REFRESH=82 {
    60                          CRT_CONFIG_TEXT:	!byte $3A,$28,$2C,$08,$20,$09,$19,$1D,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    61                          CRT_CONFIG_GRAPHICS:	!byte $3A,$28,$2C,$08,$29,$03,$19,$22,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    62                          }
    63                          
    64                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V2)
    65                          !IF REFRESH=83 {
    66                          CRT_CONFIG_TEXT:	!byte $32,$28,$28,$08,$26,$02,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    67                          CRT_CONFIG_GRAPHICS:	!byte $32,$28,$28,$08,$30,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    68                          }
    69                          
    70                          
    71                          ;======================
    72                          ; Extended/Experimental
    73                          ;======================
    74                          ; NOTE: Screens larger than 25 lines are for 8296 ONLY!!! The 8296 has additional screen RAM.
    75                          ;       These settings push the monitor to it's maximum possible resolution. Because of this you loose
    76                          ;       the ability to expand the line height in 'text' mode.
    77                          
    78                          ;---------------------- 40/80x32, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    79                          !IF REFRESH=90 {
    80                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    81                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    82                          }
    83                          
    84                          ;---------------------- 40/80x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    85                          !IF REFRESH=91 {
    86                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    87                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    88                          }
    89                          
    90                          ;---------------------- 45/90x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    91                          !IF REFRESH=92 {
    92                          CRT_CONFIG_TEXT:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    93                          CRT_CONFIG_GRAPHICS:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    94                          }
    95                          
    96                          ;=======================
    97                          ; CUSTOM - You Define It
    98                          ;=======================
    99                          
   100                          ;---------------------- CUSTOM - Your parameters here!
   101                          !IF REFRESH=99 {
   102                          CRT_CONFIG_TEXT:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
   103                          CRT_CONFIG_GRAPHICS:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
   104                          }
   105                          

; ******** Source: crtc-tables.asm
    12                          

; ******** Source: editrom80.asm
  1364                          
  1365                          
  1366                          ;*********************************************************************************************************
  1367                          ;** BELL Sound Table  [E74D]
  1368                          ;*********************************************************************************************************
  1369                          
  1370  e75a 0e1e3e7e3e1e0e     SOUND_TAB	!byte $0e,$1e,$3e,$7e,$3e,$1e,$0e	; BELL chime values
  1371                          
  1372                          ;*********************************************************************************************************
  1373                          ;** Screen Line Address Tables  [E755][E76E]
  1374                          ;*********************************************************************************************************
  1375                          

; ******** Source: screen1v.asm
     1                          ; PET/CBM EDIT ROM - Screen line address table - Screen 1 @ $8000 Video (characters)
     2                          ; ================
     3                          ; Variables: ROWS,COLUMNS
     4                          ; These tables are used to calculate the starting address of each line on the screen.
     5                          ; The standard screens are 40x25 and 80x25. Experimental screens can be up to 90x35.
     6                          ; 32 and 64 are included for future support of non-cbm type screens.
     7                          ; When ROWS>25 it assumes maximum 35 rows although less are supported as well.
     8                          
     9                          ;---------- 32 characters wide (32x32 = 1K RAM)
    10                          !IF COLUMNS=32 {
    11                          Line_Addr_Lo	!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    12                          		!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    13                          Line_Addr_Hi	!byte $80,$80,$80,$80,$80,$80,$80,$80,$81,$81,$81,$81,$81,$81,$81,$81
    14                          		!byte $82,$82,$82,$82,$82,$82,$82,$82,$83,$83,$83,$83,$83,$83,$83,$83
    15                          }
    16                          
    17                          ;---------- 40 characters wide 
    18                          !IF COLUMNS=40 {
    19                          Line_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    20                          		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    21                          !if ROWS>25 {	!byte $e8,$10,$38,$60,$88,$b0,$d8,$00,$28,$50 }
    22                          
    23                          Line_Addr_Hi	!byte $80,$80,$80,$80,$80,$80,$80,$81,$81,$81
    24                          		!byte $81,$81,$81,$82,$82,$82,$82,$82,$82,$82
    25                          		!byte $83,$83,$83,$83,$83
    26                          !if ROWS>25 {	!byte $83,$84,$84,$84,$84,$84,$84,$85,$85,$85 }
    27                          }
    28                          
    29                          ;---------- 64 characters wide (64x32 = 2K RAM)
    30                          !IF COLUMNS=64 {
    31                          Line_Addr_Lo	!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    32                          		!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    33                          Line_Addr_Hi	!byte $80,$80,$80,$80,$81,$81,$81,$81,$82,$82,$82,$82,$83,$83,$83,$83
    34                          		!byte $84,$84,$84,$84,$85,$85,$85,$85,$86,$86,$86,$86,$87,$87,$87,$87
    35                          }
    36                          
    37                          ;---------- 80 characters wide 
    38                          !IF COLUMNS=80 {
    39  e761 0050a0f04090e030...Line_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0
    40  e76b 2070c01060b00050...		!byte $20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0
    41  e775 4090e03080         		!byte $40,$90,$e0,$30,$80
    42                          !if ROWS>25 {	!byte $d0,$20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0 }
    43                          
    44  e77a 8080808081818182...Line_Addr_Hi	!byte $80,$80,$80,$80,$81,$81,$81,$82,$82,$82
    45  e784 8383838484848585...		!byte $83,$83,$83,$84,$84,$84,$85,$85,$85,$85
    46  e78e 8686868787         		!byte $86,$86,$86,$87,$87
    47                          !if ROWS>25 {	!byte $87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a,$8a }
    48                          }
    49                          
    50                          ;---------- 90 characters wide
    51                          !IF COLUMNS=90 {
    52                          Line_Addr_Lo	!byte $00,$5a,$b4,$0e,$68,$c2,$1c,$76,$d0,$2a,$84,$de,$38,$92,$ec,$46
    53                          		!byte $a0,$fa,$54,$ea,$08,$62,$bc,$16,$70,$ca,$24,$7e,$d8,$32,$8c,$e6
    54                          		!byte $40,$9a,$f4
    55                          Line_Addr_Hi	!byte $80,$80,$80,$81,$81,$81,$82,$82,$82,$83,$83,$83,$84,$84,$84,$85
    56                          		!byte $85,$85,$86,$86,$87,$87,$87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a
    57                          		!byte $8b,$8b,$8b
    58                          }

; ******** Source: editrom80.asm
  1376                          					; Screen RAM address table

; ******** Source: screen1c.asm
     1                          ; PET/CBM EDIT ROM - Screen line address table - Screen 1 @ $8800 Attributes (colour)
     2                          ; ================
     3                          ;
     4                          ; These tables are used to calculate the starting address of each line on the screen
     5                          
     6                          ;---------- 32 characters wide 
     7                          !IF COLUMNS=32 {
     8                          CLine_Addr_Lo	!byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00,$20,$40,$60,$80,$a0,$c0,$e0
     9                          		!byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00
    10                          CLine_Addr_Hi	!byte $88,$88,$88,$88,$88,$88,$88,$88,$89,$89,$89,$89,$89,$89,$89,$89
    11                          		!byte $8a,$8a,$8a,$8a,$8a,$8a,$8a,$8a,$8b
    12                          }
    13                          
    14                          ;---------- 40 characters wide 
    15                          !IF COLUMNS=40 {
    16                          CLine_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    17                          		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    18                          CLine_Addr_Hi	!byte $88,$88,$88,$88,$88,$88,$88,$89,$89,$89,$89,$89,$89,$8A,$8A,$8A
    19                          		!byte $8A,$8A,$8A,$8A,$8B,$8B,$8B,$8B,$8B
    20                          }
    21                          
    22                          ;---------- 64 characters wide
    23                          !IF COLUMNS=64 {
    24                          CLine_Addr_Lo	!byte $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
    25                          		!byte $00,$40,$80,$c0,$00,$40,$80,$c0,$00
    26                          CLine_Addr_Hi	!byte $88,$88,$88,$88,$89,$89,$89,$89,$8a,$8a,$8a,$8a,$8b,$8b,$8b,$8b
    27                          		!byte $8c,$8c,$8c,$8c,$8d,$8d,$8d,$8d,$8e
    28                          }
    29                          
    30                          ;---------- 80 characters wide 
    31                          !IF COLUMNS=80 {
    32  e793 0050a0f04090e030...CLine_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0,$20,$70,$c0,$10,$60,$b0
    33  e7a3 0050a0f04090e030...		!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80
    34  e7ac 888888888989898a...CLine_Addr_Hi	!byte $88,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a,$8b,$8b,$8b,$8c,$8c,$8c
    35  e7bc 8d8d8d8d8e8e8e8f...		!byte $8d,$8d,$8d,$8d,$8e,$8e,$8e,$8f,$8f
    36                          }
    37                          
    38                          ; 90 characters wide not applicable

; ******** Source: editrom80.asm
  1377                          }			; Colour address table (future hardware)
  1378                          
  1379                          ;*********************************************************************************************************
  1380                          ;** Small patches here  [E787]
  1381                          ;*********************************************************************************************************
  1382                          

; ******** Source: editbarrow.asm
     1                          ; PET/CBM EDIT ROM - BackArrow Hack/Patch
     2                          ; ================ - Adapted from 8096 edit rom found at World of Commodore 2015
     3                          ;
     4                          ; The BACKACTION variable determines which action code is included:
     5                          ; 0=Toggle Screen Text/Graphic Font
     6                          ; 1=Toggle 40/80 Column Mode (either soft40 or hardware 40/80)
     7                          
     8                          TestBackArrow
     9                          !IF KEYBOARD=0 {                        ; Graphics keyboard -> "@" as top left key
    10                                                                  ; Note: scanner clears KEYFLAGS, so can only be seen on bit 7 set
    11                          		CMP #$c0		; Is it (shifted) "@" key? (top left key).
    12                          					; NOTE: this is a graphics character. It will get discarded!
    13                          
    14                          } ELSE {
    15                                                        		; others use left arrow as top left key
    16  e7c5 a498               		LDY KEYFLAGS		; Is it a Shifted Char?
    17  e7c7 f004               		BEQ TestBAExit		; No, so exit and store key
    18  e7c9 c95f               		CMP #$5F		; Is it BackArrow key?
    19                          }
    20  e7cb f004               		BEQ DoBackArrow		; Yes, perform the action then RETURN (do not store key!)
    21                          
    22  e7cd e8                 TestBAExit	INX			; No, treat it as a normal key and store it, then increment char count
    23  e7ce 869e               		STX CharsInBuffer	; Num Chars in Keyboard Buffer
    24  e7d0 60                 		RTS
    25                          
    26                          ;---------------------------------------- Do the action
    27                          ; BACKACTION=0 to toggle Text/Graphics mode
    28                          ; BACKACTION=1 to toggle 40/80 column
    29                          
    30                          DoBackArrow:
    31                          
    32                          !IF BACKACTION=0 {
    33  e7d1 ad4ce8             		LDA VIA_PCR 		; VIA PCR - Reg#C
    34  e7d4 4902               		EOR #$02		; toggle bit 1 (graphic/text mode bit)
    35  e7d6 8d4ce8             		STA VIA_PCR 		; VIA PCR - Reg#C
    36  e7d9 60                 		RTS
    37                          }
    38                          
    39                          !IF BACKACTION=1 {
    40                          		JMP SS40_SwapModes	; Swap 40/80 mode
    41                          }

; ******** Source: editrom80.asm
  1383                          }		; Patch for BackArrow toggling of screen mode
  1384                          
  1385                          ;#########################################################################################################
  1386                          !IF CRUNCH=0 {	!byte $cd }		; to match 901474-04
  1387                          
  1388                          ;*********************************************************************************************************
  1389                          ;** FILLER
  1390                          ;*********************************************************************************************************
  1391  e7da aaaaaaaaaaaaaaaa...		!FILL $e800-*,$aa	; 78 bytes - Fill to end of 2K
  1392                          ;#########################################################################################################
  1393                          ;END! DO NOT ADD ANYTHING BELOW THIS LINE!!!!!!!!

; ******** Source: editrom.asm
    39                          			; 80-column CODEBASE
    40                          	!IF CODEBASE=2 {!SOURCE "editrom82.asm"}			; 80-column EXTENDED CODEBASE
    41                          
    42                          ;----------------------- Determine if we need to generate more code!
    43                          ; We must include this area if:
    44                          ;   1) We are using CODEBASE 2
    45                          ;   2) Certain EXTended features are enabled
    46                          ;   3) BACKARROW feature needs relocating.
    47                          
    48                          	!IF (CODEBASE=2) | ((COLOURPET + ESCCODES + WEDGE + EXECUDESK + SS40 + AUTORUN + KEYRESET) > 0) | (BACKARROW=2) {
    49                          
    50                          ;=======================================================================
    51                          ; EXT 4K Edit ROM code starts here
    52                          ;=======================================================================
    53                          ; $E800-EFFF for Extended ROM start address. Includes two sections:
    54                          ;   1) $E800-E8FF - IO Area
    55                          ;   3) $E900-EFFF - Extended area
    56                          
    57                          ;=======================================================================
    58                          ; IO Area
    59                          ;=======================================================================
    60                          ; $E800-E8FF is not visible to the PET cpu as I/O is in this space.
    61                          ; When not tring to duplicate existing code binaries, the IO.ASM file can
    62                          ; be used to place comments here that will be readable in the ROM via binary viewers.
    63                          

; ******** Source: io.asm
     1                          ; IO - This part of the ROM is not visible since IO is mapped here, so we will fill it
     2                          ; ==   with a decription of the editrom features and options.
     3                          
     4  e800 2a2a43424d204544...!text "**CBM EDIT ROM**"
     5  e810 5b                 !text "["
     6  e811 323032322d30342d...+DATE
     7                          
     8  e81b 5d20434f44454241...!text "] CODEBASE="
     9                          !IF CODEBASE=0 { !text "0" }
    10  e826 31                 !IF CODEBASE=1 { !text "1" }
    11                          !IF CODEBASE=2 { !text "2" }
    12                          
    13                          !IF COLOURPET = 1 {
    14  e827 20434f4c4f555250...	!text " COLOURPET-"
    15                          	!if COLOURVER=0 { !text "beta" }
    16  e832 72656c65617365     	!if COLOURVER=1 { !text "release" }
    17                          }
    18                          
    19  e839 204b4559424f4152...!text " KEYBOARD="
    20                          	!if KEYBOARD= 0 { !text "n-qwerty" }
    21  e843 622d717765727479   	!if KEYBOARD= 1 { !text "b-qwerty" }	; QWERTY layout
    22                          	!if KEYBOARD= 2 { !text "din" }
    23                          	!if KEYBOARD= 3 { !text "c64/vic" }
    24                          	!if KEYBOARD= 4 { !text "b-sjg" }	; Modified layout - cursor keys, esc etc
    25                          	!if KEYBOARD= 5 { !text "n-sjg" }	; Modified layout - @ replaced with ESC, backarrow becomes @
    26                          	!if KEYBOARD= 6 { !text "b-qwertz" }	; QWERTZ layout
    27                          	!if KEYBOARD= 7 { !text "b-azerty" }	; AZERTY layout
    28                          	!if KEYBOARD= 8 { !text "cbm-ii" }	; CBM-II keyboard (requires hardware mod)
    29                          	!if KEYBOARD= 9 { !text "n-sjg2" }	; Modified layout - backarrow replaced with ESC
    30                          	!if KEYBOARD=11 { !text "ted" }		; TED series (C16,C116,Plus/4 etc)
    31                          
    32  e84b 2053435245454e3d   !text " SCREEN="
    33                          	!if COLUMNS=32  { !text "32" }
    34                          	!if COLUMNS=40  { !text "40" }
    35  e853 3830               	!if COLUMNS=80  { !text "80" }
    36                          	!if COLUMNS=90  { !text "90" }
    37                          	!if ROWS=16     { !text "x16" }
    38  e855 783235             	!if ROWS=25     { !text "x25" }
    39                          	!if ROWS=32     { !text "x32" }
    40                          	!if ROWS=35     { !text "x35" }
    41                          	!if SOFT40=1    { !text " (soft40)" }
    42                          	!if SS40=1      {
    43                          		!pet " ("
    44                          		!if HARD4080=1  { !text "hs" } else { !text "ss" }
    45                          		!if SS40MODE=40 { !text "40)" }
    46                          		!if SS40MODE=80 { !text "80)" }
    47                          	}
    48                          
    49  e858 20484552545a3d     !text " HERTZ="
    50  e85f 3530               	!if HERTZ=50 { !text "50" }
    51                          	!if HERTZ=60 { !text "60" }
    52                          
    53  e861 2052454652455348...!text " REFRESH="
    54                          	!if REFRESH= 0 { !text "euro" }
    55  e86a 6e2e616d65726963...	!if REFRESH= 1 { !text "n.america" }
    56                          	!if REFRESH= 2 { !text "pal" }
    57                          	!if REFRESH= 3 { !text "ntsc" }
    58                          	!if REFRESH= 4 { !text "9inch" }
    59                          	!if REFRESH=82 { !text "8296d-v1" }
    60                          	!if REFRESH=83 { !text "8296d-v2" }
    61                          	!if REFRESH=90 { !text "8296(d)-n.a." }
    62                          	!if REFRESH=91 { !text "8296(d)-n.a." }
    63                          	!if REFRESH=92 { !text "8296(d)-n.a." }
    64                          	!if REFRESH=98 { !text "special" }
    65                          	!if REFRESH=99 { !text "custom" }
    66                          
    67  e873 2046454154555245...!text " FEATURES="
    68  e87d 6573632d636f6465...!if ESCCODES=1  { !text "esc-codes" }
    69  e886 2c6175746f72756e   !if AUTORUN=1   { !text ",autorun" }
    70                          !if BYPASS=1    { !text "+bypass" }
    71  e88e 2c62616e6e6572     !if BANNER>0    { !text ",banner" }
    72  e895 2c7765646765       !if WEDGE=1     { !text ",wedge" }
    73  e89b 2c6b657972657365...!if KEYRESET=1  { !text ",keyreset" }
    74                          !if DISKBOOT=1  { !text ",disk boot" }
    75                          !if EXECUDESK=1 { !text ",execudesk" }
    76  e8a4 2c6261636b617272...!if BACKARROW>0 { !text ",backarrow" }
    77                          !if SILENT=1    { !text ",silent" }
    78  e8ae 2c6372756e6368     !if CRUNCH=1    { !text ",crunch" }
    79                          !if MOT6845=1   { !text ",mot6845" }
    80                          !if DEBUG=1     { !text ",debug" }
    81  e8b5 2e20434f4d4d454e...!text ". COMMENT="
    82  e8bf 534a472d45444954...+COMMENT
    83                          

; ******** Source: editrom.asm
    64                          					; Filler not visible due to I/O space!
    65  e8ca 2020202020202020...	!fill $E900-*,$20 
    66                          
    67                          ;=======================================================================
    68                          ; CODEBASE 2 Code
    69                          ;=======================================================================
    70                          ; This code is included only for Codebase 2
    71                          
    72                          	!IF CODEBASE = 2 {!SOURCE "editromext.asm" }
    73                          
    74                          ;=======================================================================
    75                          ; NEW Code
    76                          ;=======================================================================
    77                          ; The EXTended features will go here. This is NEW code that has been added,
    78                          ; or code that must be RELOCATED due to lack of space in the 2K area 
    79                          ; due to restrictions of HARDCODED entrypoints.
    80                          ;
    81                          ; It is very likely that CODEBASE 2 will not have enough space for many of
    82                          ; these additions.
    83                          ; If OPTROM is greater than 0 then this code will be put in the OPTION ROM space.
    84                          
    85                          	;----- If OPTION ROM then adjust Code assembly address
    86                          	
    87                          	!IF OPTROM=1 { *=$9000 }  				; Assemble to option ROM at $9000
    88                          	!IF OPTROM=2 { *=$A000 }  				; Assemble to option ROM at $A000
    89                          	!IF OPTROM=99 {!SOURCE "io.asm"}			; Special case for development purposes
    90                          
    91                          	;----- These features require AUTORUN
    92                          
    93                          	!IF AUTORUN   = 1 {

; ******** Source: editautorun.asm
     1                          ; PET/CBM EDIT ROM - Auto Run
     2                          ; ================
     3                          ;
     4                          ; This module controls auto running tasks after PET has booted. It does this by
     5                          ; stuffing the keyboard buffer with a SYS command. We need to do this because
     6                          ; the editrom code runs before basic and zero-page are initialized.
     7                          ;
     8                          ; The SYS command will automatically be erased.
     9                          ;
    10                          ;-------------- Autostart Dispatch
    11                          ; This should assemble to the $E900,$9000, or $A000 depending on OPTROM setting.
    12                          ; The SYS points to here.
    13                          ; We check options to see what needs to Auto Run.
    14                          
    15                          AUTODISPATCH
    16  e900 200ae9             		JSR ERASE_SYS
    17  e903 204ce9             		!IF BANNER > 0   { JSR SHOW_BANNER   }		; Display Custom Banner Message
    18  e906 20fee9             		!IF WEDGE  > 0   { JSR INSTALL_WEDGE }		; Install DOS Wedge
    19                          		!IF EXECUDESK =2 { JSR EDESKMENU }		; Run Execudesk Menu
    20                          		!IF DISKBOOT > 0 { JSR DOBOOT }			; Do Disk Boot
    21  e909 60                 		RTS
    22                          
    23                          ERASE_SYS
    24  e90a a92c               		LDA #<ERASE_TXT			; pointer to erase text string
    25  e90c a0e9               		LDY #>ERASE_TXT
    26  e90e 201dbb             		JSR STROUTZ			; print it
    27  e911 60                 		RTS
    28                          
    29                          ;-------------- Wedge Prep (1st Step)
    30                          ; We jump to here in the Editor ROM Init code, near the end.
    31                          ; If BYPASS=1 then we check for a key on ROW0 (which is ROW9 in the keyboard table)
    32                          
    33                          AUTOSTART
    34                          
    35                          !IF BYPASS=1 {
    36                          		LDA PIA1_Port_A 		; Keyboard ROW select - PIA#1, Register 0
    37                          						; Upper bits: IEEE and Cassette
    38                          						; Lower bits: Keyboard ROW select
    39                          		AND #$F0			; Mask off lower 4 bits (reset keyboard scan row)
    40                          		STA PIA1_Port_A			; Keyboard ROW select - PIA#1, Register 0				CHIP
    41                          		LDA PIA1_Port_B			; Keyboard COL result							CHIP
    42                          		CMP #$FF			; Are any keys pressed?  (FF=No keys down)
    43                          		BEQ AUTO_GO			; No, so do Auto Run
    44                          
    45                          !IF COLOURPET > 0 {
    46                          						; For ColourPET we can change the colours to indicate no wedge installed
    47                          		LDA #BYPASSFG			; ColourPET Foreground for Wedge Bypass
    48                          		STA COLOURFG
    49                          		LDA #BYPASSBG 			; ColourPET Background for Wedge Bypass
    50                          		STA COLOURBG
    51                          		}
    52                          
    53                          		RTS				; Exit without activating wedge sys
    54                          }
    55                          
    56                          ;-------------- Stuff Keyboard
    57                          AUTO_GO
    58  e912 a209               		LDX #9				; Length of string
    59                          
    60  e914 bd22e9             AUTO_LOOP	LDA AUTO_SYS,X			; Get a key from table
    61  e917 9d6f02             		STA KEYD,X 			; put it in the Keyboard Buffer
    62  e91a ca                 		DEX
    63  e91b 10f7               		BPL AUTO_LOOP			; loop until done
    64                          
    65  e91d a909               		LDA #9				; Length of string
    66  e91f 859e               		STA CharsInBuffer		; Set characters in keyboard buffer 
    67  e921 60                 AUTO_DONE	RTS
    68                          
    69                          ;-------------- TEXT to stuff into keyboard buffer
    70                          
    71                          AUTO_SYS
    72  e922 5359533539363438   		!IF OPTROM=0 {!text "SYS59648"}		; Autostart is located at $E900!
    73                          		!IF OPTROM=1 {!text "SYS36864"}		; Autostart is located at $9000!
    74                          		!IF OPTROM=2 {!text "SYS40960"}		; Autostart is located at $A000!
    75  e92a 0d00               		!byte $0D,0				; <CR> and zero pad byte
    76                          
    77                          ;-------------- TEXT to erase SYS and READY from screen
    78                          
    79                          ERASE_TXT
    80  e92c 91                 		!byte $91			; <UP>
    81  e92d 2020202020202020...		!text "            "		; erase "SYS" message
    82  e939 0d                 		!byte $0D			; <CR>
    83  e93a 2020202020202020...		!text "            "		; erase "READY" message
    84  e946 0d                 		!byte $0D			; <CR>
    85  e947 91919191           		!byte $91,$91,$91,$91		; <UP><UP><UP><UP>
    86  e94b 00                 		!byte 0
    87                          
    88                          ;============================================================================================
    89                          ; DISK AUTOBOOT
    90                          ;============================================================================================
    91                          ; This puts the SHIFT RUN/STOP code into the keyboard buffer and the system
    92                          ; will take care of the rest!
    93                          
    94                          !IF DISKBOOT >0 {
    95                          DOBOOT
    96                          		LDA #$83			; SHIFT RUN/STOP
    97                          		STA KEYD			; First position of Keyboard Input Buffer
    98                          		LDA #1				; One character
    99                          		STA $9E				; Set number of characters in keyboard buffer
   100                          		RTS
   101                          }

; ******** Source: editrom.asm
    94                          

; ******** Source: editbanner.asm
     1                          ; PET/CBM EDIT ROM - Custom Banner
     2                          ; ================
     3                          ;
     4                          ; You can display a custom banner message when the machine is turned on. This could be a simple
     5                          ; welcome message, or a completely new message. By including CLS, HOME or CURSOR characters you
     6                          ; can overwrite the PET's normal power-up banner with anything you like.
     7                          ;
     8                          ; NOTES:
     9                          ; - The default banner "*** COMMODORE BASIC 4.0 ***"  (27 characters wide) is located in the
    10                          ;   BASIC ROM so we cannot change it, but we can clear or overwrite it.
    11                          ; - Be sure to use proper cursoring so that the "READY" prompt is positioned correctly!
    12                          ; - If you clear the screen you will lose the "xxxxx BYTES FREE" message.
    13                          ; - For ColourPET, if you set the initial FG and BG colours to be the same then the PET banner
    14                          ;   will be invisible. Be sure to set the colour before printing your custom message.
    15                          
    16                          ;-------------- Display the Banner
    17                          
    18                          SHOW_BANNER
    19  e94c a954               		lda #<BANNER_TXT		; pointer to BANNER text string
    20  e94e a0e9               		ldy #>BANNER_TXT
    21  e950 201dbb             		jsr STROUTZ			; print it
    22  e953 60                 		rts
    23                          
    24                          ;-------------- Include the Banner text
    25                          
    26                          BANNER_TXT

; ******** Source: banner.asm
     1                          ; PET/CBM EDIT ROM - Custom Banner (Power-on) Messages
     2                          ; ================
     3                          
     4                          ; You can display a custom banner message when the machine is turned on. This could be a simple
     5                          ; welcome message, or a completely new message. By including CLS, HOME or CURSOR characters you
     6                          ; can overwrite the PET's normal power-up banner with anything you like.
     7                          ;
     8                          ; NOTES:
     9                          ; - The default banner "*** COMMODORE BASIC 4.0 ***"  (27 characters wide) is located in the
    10                          ;   BASIC ROM so we cannot change it, but we can clear or overwrite it.
    11                          ; - Be sure to use proper cursoring so that the "READY" prompt is positioned correctly!
    12                          ; - If you clear the screen you will lose the "xxxxx BYTES FREE" message.
    13                          ; - For ColourPET, if you set the initial FG and BG colours to be the same then the PET banner
    14                          ;   will be invisible. Be sure to set the colour before printing your custom message.
    15                          ;
    16                          ; Currently the following are available:
    17                          ;
    18                          ; ##  MODEL  MODE   TYPE MESSAGE / DESCRIPTION                   40                                      80
    19                          ; --  -----  ----   ---- "---------!---------!---------!---------!---------!---------!---------!---------!"
    20                          ;  1  CPET   GRAPH  OVER "COMMODORE COLOURPET"
    21                          ;  2  CPET   TEXT   OVER "ColourPET BASIC4 + Wedge"
    22                          ;  3  80COL  TEXT   OVER "Commodore EDITROM Project - Wedge/ESC/SS40"
    23                          ;  4  ANY    GRAPH  OVER "CBM BASIC 4 WITH WEDGE"
    24                          ;  5  CPET   GRAPH  FULL C65-like screen with colour bars
    25                          ;  6  80COL  ANY    OVER "*** commodore basic 4.0 with wedge/esc/ss40"
    26                          ;  7  80COL  ANY    OVER "*** commodore basic 4.0 with wedge,esc,reboot,40/80 switcher"
    27                          ;  8  8296   ANY    OVER "*** commodore 8296 basic 4.0 with wedge,esc,reboot,80x35 screen"
    28                          ;  9  8296   ANY    OVER "*** commodore 8296 basic 4.0 with wedge,esc,reboot,extended screen"
    29                          ; 10  80COL  ANY    OVER "*** commodore basic 4.0 with wedge,esc,reboot,ss40, execudesk"
    30                          ; 11  80COL  ANY    OVER "*** commodore basic 4.0 with enhanced editor and wedge"
    31                          ; 12  40COL  ANY    OVER "*** cbm basic 4 plus editor+wedge ***"
    32                          ; 13  8296D  ANY    OVER "*** commodore 8296 basic 4.0 with wedge,reboot, backarrow ***"
    33                          ; 14  8296D  ANY    OVER "*** commodore 8296 basic 4.0 with custom editor rom ***"
    34                          ; 15  8296D  ANY    OVER "*** commodore 8296d basic 4.0 with custom editor rom ***"
    35                          ; 16  80COL  ANY    OVER "*** commodore basic 4.0 with custom editor rom ***"
    36                          ; 17  40COL  ANY    OVER "*** cbm basic 4 custom editrom ***"
    37                          ; 18  40COL  ANY    OVER "*** commodore basic 4.0 *** hard40/80,n"
    38                          ; 19  40COL  ANY    OVER "*** commodore basic 4.0 *** disk boot"
    39                          ; 98  ANY    ANY    ADD  Show DATE and COMMENT for debug purposes
    40                          ; 99  CUSTOM ...    ...  Your own banner text
    41                          ;
    42                          ; TYPE: FULL = Replaces all, OVER = Overwrites part, ADD = Adds additional text
    43                          ;
    44                          ;-----------------------------------------------
    45                          ; CUSTOM BANNER
    46                          ;-----------------------------------------------
    47                          !IF BANNER=99 {
    48                          		!byte $13
    49                          ;Screen columns:      44444444444444444444444444v44444444444448888888888888888888888888888888888888888
    50                          		!pet "*** commodore basic 4.0 *** hard40/80,n",$0D
    51                          		!pet "waltermixx edition!"
    52                          		!byte $0D      			; <CR><CR><CR>
    53                          }
    54                          
    55                          ;-----------------------------------------------
    56                          ; DEBUG BANNER
    57                          ;-----------------------------------------------
    58                          
    59                          !IF BANNER=98 {	!pet "date: "
    60                          		+DATE
    61                          		!byte $0D
    62                          		!pet "comment: "
    63                          		+COMMENT
    64                          		!byte $0D				
    65                          }
    66                          
    67                          !IF BANNER=19 {	!byte $13
    68                          		!pet "*** commodore basic 4.0 *** disk boot"
    69                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    70                          }
    71                          
    72                          !IF BANNER=18 {	!byte $13
    73                          		!pet "*** commodore basic 4.0 *** hard40/80,n"
    74                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    75                          }
    76                          
    77                          !if BANNER=17 { !byte $13            		; <HOME> 
    78                                   	!pet "*** cbm basic 4 with custom editrom ***"
    79                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    80                          }
    81                          
    82                          !if BANNER=16 { !byte $13            		; <HOME> 
    83                                   	!pet "*** commodore basic 4.0 with custom editor rom ***"
    84                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    85                          }
    86                          
    87                          !if BANNER=15 { !byte $13            		; <HOME> 
    88                                   	!pet "*** commodore 8296d basic 4.0 with custom editor rom ***"
    89                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    90                          }
    91                          
    92                          !if BANNER=14 { !byte $13            		; <HOME> 
    93                                   	!pet "*** commodore 8296 basic 4.0 with custom editor rom ***"
    94                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    95                          }
    96                          
    97                          !if BANNER=13 { !byte $13            		; <HOME> 
    98                                   	!pet "*** commodore 8296d basic 4.0 with wedge,reboot,din ***"
    99                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   100                          }
   101                          
   102                          !if BANNER=12 {	!byte $13            		; <HOME> 
   103                                   	!pet "*** cbm basic 4 plus editor+wedge ***"
   104                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   105                          }
   106                          
   107                          !if BANNER=11 {	!byte $13            		; <HOME> 
   108                                   	!pet "*** commodore basic 4.0 with enhanced editor and wedge ***"
   109                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   110                          }
   111                          
   112                          !if BANNER=10 {	!byte $13            		; <HOME> 
   113                                   	!pet "*** commodore basic 4.0 with wedge,esc,reboot,ss40, execudesk ***"
   114                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   115                          }
   116                          
   117                          !if BANNER=9 {	!byte $13            		; <HOME> 
   118                                   	!pet "*** commodore 8296 basic 4.0 with wedge,esc,reboot,extended screen ***"
   119                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   120                          }
   121                          
   122                          !if BANNER=8 {	!byte $13            		; <HOME> 
   123                                   	!pet "*** commodore 8296 basic 4.0 with wedge,esc,reboot,80x35 screen ***"
   124                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   125                          }
   126                          
   127                          !if BANNER=7 {	!byte $13            		; <HOME> 
   128                                   	!pet "*** commodore basic 4.0 with wedge,esc,reboot,40/80 switcher ***"
   129                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   130                          }
   131                          
   132                          !if BANNER=6 {	!byte $13            		; <HOME> 
   133                                   	!pet "*** commodore basic 4.0 with wedge/esc/ss40 ***"
   134                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   135                          }
   136                          
   137                          ;-----------------------------------------------
   138                          ; Custom ColourPET-40 C65-like startup screen with colour bars
   139                          ; TIP: Set foreground and background colour to <BLUE> to hide initial banner message
   140                          ;-----------------------------------------------
   141                          !IF BANNER=5 {
   142  e954 051f938e           		!byte $5,$1F,$93,142		; <WHT><BLUE><CLS><GRAPHICS>
   143                          		
   144                          		;-- line 1		
   145  e958 1c12               		!byte $1C,$12			;<RED><RVS>
   146  e95a 2020202020202020...		!pet "         "		; bar
   147  e963 92e905             		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   148                          
   149                          !IF UPET=1 {
   150  e966 202054484520554c...		!pet "  the ultra-pet development prototype"
   151                          } ELSE {
   152                          		!pet "  the commodore colourpet"
   153                          }
   154                          
   155  e98b 0d                 		!byte $0D			; <CR>
   156                          
   157                          		;-- line 2
   158  e98c 9612               		!byte $96,$12			; <LT RED><RVS>
   159  e98e 20202020202020     		!pet "       "			; bar
   160  e995 92e90d             		!byte $92,$E9,$0D		; <OFF><diag block><CR>
   161                          
   162                          		;-- line 3
   163  e998 9e12               		!byte $9E,$12			; <YEL><RVS>
   164  e99a 2020202020         		!pet "     "                    ; bar
   165  e99f 92e905             		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   166                          
   167                          !IF UPET=1 {
   168  e9a2 2020202020204259...		!pet "      by andre fachat"
   169                          } ELSE {
   170                          		!pet "      (c) steve j. gray"
   171                          }
   172                          
   173  e9b7 0d                 		!byte $0D			; <CR>
   174                          
   175                          		;-- line 4
   176  e9b8 9912               		!byte $99,$12			; <LT GRN><RVS>
   177  e9ba 202020             		!pet "   "			; bar
   178  e9bd 92e905             		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   179  e9c0 2020202020202020...		!pet "        basic 4.0  31743 bytes free"
   180  e9e3 0d                 		!byte $0D
   181                          
   182                          		;-- line 5,6
   183  e9e4 0d                 		!byte $0D
   184  e9e5 4d4f44204b455942...		!pet "mod keyboard and wedge"
   185  e9fb 0d                 		!byte $0D				
   186                          }
   187                          
   188                          ;-----------------------------------------------
   189                          ; Custom 4032 - For GRAPHICS MODE startup screen
   190                          ;-----------------------------------------------
   191                          
   192                          !if BANNER=4 {	!byte $13            		; <HOME> 
   193                                   	!pet "*** CBM BASIC 4 WITH WEDGE ***"
   194                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   195                          }
   196                          
   197                          ;-----------------------------------------------
   198                          ; Custom 8032 - For TEXT MODE startup screen
   199                          ;-----------------------------------------------
   200                          
   201                          !if BANNER=3 {	!byte $13            		; <HOME> 
   202                                   	!pet "*** Commodore EDITROM Project - Wedge/ESC/SS40 ***"
   203                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   204                          }
   205                          
   206                          ;-----------------------------------------------
   207                          ; Custom ColourPET message courtesy Christian Dirks - For GRAPHICS MODE startup screen
   208                          ;-----------------------------------------------
   209                          
   210                          !if BANNER=2 {	!byte $13,$99          		; <HOME><GRN>
   211                                   	!pet "*** "
   212                                   	!byte $1c            		; <RED>
   213                                   	!pet "co"
   214                                   	!byte $99            		; <GRN>
   215                                   	!pet "lo"
   216                                   	!byte $9a            		; <BLU>
   217                                   	!pet "ur"
   218                                   	!byte $9e            		; <YEL>
   219                                   	!pet "pet"
   220                                   	!byte $99            		; <GRN>
   221                                   	!pet " basic 4.0 + wedge ***"   ; message
   222                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   223                          }
   224                          
   225                          ;-----------------------------------------------
   226                          ; Custom ColourPET message for TEXT MODE startup screen
   227                          ;-----------------------------------------------
   228                          
   229                          !if BANNER=1 {	!byte $93,$5			; <CLS><WHT>
   230                          		!pet "*** "
   231                          		!byte $9f			; <LTCYN>
   232                          		!pet "Commodore "
   233                          		!byte $1c			; <RED>
   234                          		!pet "Co"
   235                          		!byte $99			; <GRN>
   236                          		!pet "lo"
   237                          		!byte $9a			; <BLU>
   238                          		!pet "ur"
   239                          		!byte $9e			; <YEL>
   240                          		!pet "PET"
   241                          		!byte $05			; <WHT>
   242                          		!pet " ***"
   243                          		!byte 11,11
   244                          		!byte $0D			; <cr>
   245                          }
   246                          
   247                          ;-----------------------------------------------
   248                          ; Unspecified values
   249                          ;-----------------------------------------------
   250                          

; ******** Source: editbanner.asm
    27  e9fc 0000               
    28                          
    29                          

; ******** Source: editrom.asm
    95                          }

; ******** Source: editwedge.asm
     1                          ; PET/CBM EDIT ROM - Wedge
     2                          ; ================
     3                          ;
     4                          ; Based on Commodore's universal wedge taken from 8050's test/demo disk
     5                          ; but rewritten and enhanced by Nils Eilers
     6                          ;
     7                          ; Adapted for EDIT-ROM and ACME assembler by Steve Gray.
     8                          ;
     9                          ; NOTE: The reason we have to stuff the keyboard buffer to activate the wedge is because
    10                          ;       the editrom code runs before basic and zero-page are initialized.
    11                          ;
    12                          ;----------------------------------------------------------------------------------------
    13                          ; Wedge commands are only available in direct mode. 
    14                          ;
    15                          ; #<unit number> 	- sets the default drive. Without unit number shows the current default drive.
    16                          ; @$[[drive]:filename] 	- displays the disk's directory. SPACE=Pause, any other key to continue. STOP=Abort.
    17                          ;				@$ displays the entire directory.
    18                          ;				@$1: displays the directory of default's device drive 1 only. Do not confuse drive and device.
    19                          ;				@$:N* displays all files having a "N" as the first letter in their filename.
    20                          ; /filename		- Loads a program.
    21                          ; ^filename		- Loads and runs a file ("^" is up arrow, NOT "carat")
    22                          ; @			- Read disk status. Without any parameters reads and displays the disk drive error message channel.
    23                          ; @<string>		- Sends <string> to the device's command channel. 
    24                          ;				@C:newfile=existingfile	- Copy a file on the same diskette
    25                          ;				@I 			- Initialize the disk drive.
    26                          ;				@N:diskname		- New a disk that was already formatted
    27                          ;				@N:diskname,id		- Format a diskette, giving it an index at your choice
    28                          ;				@R:newname=oldname	- Rename a file
    29                          ;				@S:file1[,file2 ...]	- Scratch file(s). Wild cards allowed. Status channel returns # of files scratched.
    30                          ;				@UJ			- Reset drive. Status channel will return the DOS version string.
    31                          ;				@V			- Validate disk
    32                          ;				@D1=0			- Duplicate disk (dual drive units only). Target drive first, then source.
    33                          ;------------------------------------------------------------------------------------------------------------------------------------------
    34                          
    35                          
    36                          ;-------------- INSTALL WEDGE
    37                          ; This patches the CHRGET routine in Zero Page to point to the WEDGE interpreter
    38                          
    39                          INSTALL_WEDGE
    40  e9fe a90f               		lda #<resident_wedge		; patch CHRGET JMP address
    41  ea00 8571               		sta CHRGET+1 			; to jump into wedge
    42  ea02 a9ea               		lda #>resident_wedge
    43  ea04 8572               		sta CHRGET+2
    44  ea06 a94c               		lda #$4c			; insert JMP command in CHRGET routine
    45  ea08 8570               		sta CHRGET
    46                          
    47  ea0a a908               		lda #8				; init default device
    48  ea0c 8573               		sta CHRGETX			; $73=unused byte in CHRGET
    49                          
    50                          !if WEDGEMSG=1 {
    51                          		lda #<WEDGESTRING		; write "wedge installed"
    52                          		ldy #>WEDGESTRING
    53                          		jsr STROUTZ
    54                          }	
    55  ea0e 60                 		rts				; exit to BASIC
    56                          
    57                          ;-------------- MESSAGE
    58                          WEDGESTRING
    59                          !if WEDGEMSG=1 {
    60                          		!pet "wedge installed"		; message
    61                          		!byte 0				; extra 0 padding
    62                          }
    63                          
    64                          ;-------------- Resident part of the universal DOS wedge
    65                          ; When installed, the CHRGET routine points here.
    66                          
    67                          resident_wedge
    68                          		wedge_unit = CHRGETX		; default device, unused byte in CHRGET
    69                          		wedge_char = SAVELA		; $B3 -0 if @># else load/run char / ^
    70                          
    71  ea0f e677               		inc TXTPTR			; increment text pointer 
    72  ea11 d002               		bne MAIN2
    73  ea13 e678               		inc TXTPTR + 1
    74                          MAIN2 
    75                          
    76                          ; if MAINS is stacked, CHRGET is called from direct mode. abort if not called from there
    77                          
    78  ea15 86b3               		stx wedge_char			; save X
    79  ea17 ba                 		tsx 
    80  ea18 bd0101             		lda STACK+1,x
    81  ea1b c90f               		cmp #<MAINS
    82  ea1d d037               		bne restabort
    83  ea1f bd0201             		lda STACK+2,x
    84  ea22 c9b4               		cmp #>MAINS
    85  ea24 d030               		bne restabort			; abort if textpointer doesn't point to $0200
    86                          
    87  ea26 a577               		lda TXTPTR
    88  ea28 d02e               		bne abort
    89  ea2a a578               		lda TXTPTR + 1
    90  ea2c c902               		cmp #2
    91  ea2e d028               		bne abort
    92                          
    93  ea30 a000               		ldy #0				; NUL when @>#
    94  ea32 84b3               		sty wedge_char			; else load/run character /^
    95                          
    96  ea34 b177               testchar	lda (TXTPTR),y
    97  ea36 c920               		cmp #32				; skip leading spaces
    98  ea38 d004               		bne nospace
    99  ea3a e677               		inc TXTPTR
   100  ea3c d0f6               		bne testchar
   101                          
   102  ea3e c93e               nospace		cmp #$3e			; '>'
   103  ea40 f019               		beq command_or_status
   104  ea42 c940               		cmp #$40			; '@'
   105  ea44 f015               		beq command_or_status
   106  ea46 c923               		cmp #$23			; '#'
   107  ea48 f01c               		beq default_device
   108  ea4a 85b3               		sta wedge_char			; save load/run character
   109  ea4c c92f               		cmp #$2f			; '/'
   110  ea4e f057               		beq to_prepare_fn
   111  ea50 c95e               		cmp #$5e			; '^'
   112  ea52 f053               		beq to_prepare_fn
   113  ea54 d002               		bne abort
   114                          
   115  ea56 a6b3               restabort	ldx wedge_char			; restore X
   116  ea58 4c7600             abort		jmp CHRGOT
   117                          
   118                          ;-------------- COMMAND OR STATUS
   119                          
   120                          command_or_status
   121  ea5b c8                 		iny 
   122  ea5c b177               		lda (TXTPTR),y
   123  ea5e f049               		beq get_status
   124  ea60 c924               		cmp #'$'			; '$'
   125  ea62 f06b               		beq prepare_fn
   126  ea64 d01d               		bne send_cmd
   127                          
   128                          ;-------------- SET DEVICE
   129                          
   130                          default_device
   131  ea66 e677               		inc TXTPTR
   132  ea68 b177               		lda (TXTPTR),y			; Y is still 0
   133  ea6a d00c               		bne set_device			; parameter given -> set device number
   134                          
   135  ea6c a673               		ldx wedge_unit			; show current device number
   136  ea6e 98                 		tya
   137  ea6f 2083cf             		jsr INTOUT
   138  ea72 2034d5             		jsr CRLF
   139  ea75 4cffb3             		jmp READY
   140                          
   141                          set_device
   142                          		; prerequsites for RDINT: 
   143                          		; - TXTPTR $77/$78 point to first char
   144                          		; - A contains that first char
   145                          		; - Carry is cleared
   146                          
   147  ea78 18                 		clc
   148  ea79 20f6b8             		jsr RDINT			; convert string to unsigned int
   149  ea7c a511               		lda LINNUM			; LSB of converted number
   150  ea7e 8573               		sta wedge_unit
   151  ea80 4cffb3             		jmp READY
   152                          	
   153                          ;-------------- SEND COMMAND
   154                          
   155  ea83 a573               send_cmd	lda wedge_unit
   156  ea85 85d4               		sta FA
   157  ea87 a96f               		lda #$6f			; DATA SA 15
   158  ea89 85d3               		sta SA
   159  ea8b 20d5f0             		jsr LISTN			; LISTEN 
   160  ea8e a5d3               		lda SA
   161  ea90 2043f1             		jsr SECND			; send secondary address
   162                          
   163  ea93 e677               SENDCMD2	inc TXTPTR
   164  ea95 a000               		ldy #0			
   165  ea97 b177               		lda (TXTPTR),y
   166  ea99 f006               		beq SENDCMDDONE	
   167  ea9b 209ef1             		jsr CIOUT			; send char to IEEE
   168  ea9e b8                 		clv 
   169  ea9f 50f2               		bvc SENDCMD2			; branch always
   170                          
   171  eaa1 20b9f1             SENDCMDDONE	jsr UNLSN
   172  eaa4 18                 		clc
   173  eaa5 9002               		bcc get_status
   174                          
   175                          ;-------------- Relative Branch forwarder
   176                          
   177  eaa7 f026               to_prepare_fn:	beq prepare_fn		
   178                          
   179                          ;-------------- GET STATUS
   180                          
   181  eaa9 8477               get_status	sty TXTPTR
   182  eaab a573               		lda wedge_unit
   183  eaad 85d4               		sta FA
   184  eaaf 20d2f0             		jsr TALK			; TALK
   185  eab2 a96f               		lda #$6f			; DATA SA 15
   186  eab4 85d3               		sta SA
   187  eab6 2043f1             		jsr SECND			; send secondary address
   188                          
   189  eab9 20c0f1             GS_NEXTCHAR	jsr ACPTR			; read byte from IEEE bus
   190  eabc c90d               		cmp #$0D			; last byte = CR?		
   191  eabe f006               		beq GS_DONE
   192  eac0 2002e2             		jsr SCROUT			; write char to screen
   193  eac3 b8                 		clv 
   194  eac4 50f3               		bvc GS_NEXTCHAR			; branch always
   195                          
   196  eac6 2002e2             GS_DONE		jsr SCROUT			; write char to screen
   197  eac9 20aef1             		jsr UNTLK			; UNTALK
   198  eacc 4cffb3             		jmp READY
   199                          
   200                          ;------------------------------------------------------------------------------
   201                          ; identify filename to load/run, includes quote handling
   202                          
   203                          prepare_fn
   204  eacf c8                 		iny				; count filename length
   205  ead0 b177               		lda (TXTPTR),y
   206  ead2 f01a               		beq end_name
   207  ead4 c922               		cmp #'"'			; quote character
   208  ead6 d0f7               		bne prepare_fn
   209                          
   210  ead8 a5b3               handle_quote	lda wedge_char
   211  eada 3012               		bmi end_name
   212  eadc 0980               		ora #$80
   213  eade 85b3               		sta wedge_char 
   214  eae0 98                 		tya
   215  eae1 a000               		ldy #0
   216  eae3 18                 		clc
   217  eae4 6577               		adc TXTPTR
   218  eae6 8577               		sta TXTPTR
   219  eae8 90e5               		bcc prepare_fn
   220  eaea e678               		inc TXTPTR+1
   221  eaec d0e1               		bne prepare_fn
   222                          
   223  eaee 88                 end_name	dey 
   224  eaef 84d1               		sty FNLEN			; store length
   225  eaf1 a677               		ldx TXTPTR
   226  eaf3 e8                 		inx
   227  eaf4 86da               		stx FNADR
   228  eaf6 a578               		lda TXTPTR + 1
   229  eaf8 85db               		sta FNADR + 1
   230  eafa a573               		lda wedge_unit
   231  eafc 85d4               		sta FA
   232  eafe a5b3               		lda wedge_char			; load/run?
   233  eb00 297f               		and #$7f
   234  eb02 85b3               		sta wedge_char
   235  eb04 d039               		bne to_loadrun			; yes
   236                          
   237                          ;-------------- DIRECTORY
   238                          
   239  eb06 a900               		lda #0				; Clear the status flag
   240  eb08 8596               		sta STATUS
   241  eb0a a960               		lda #$60			; DATA SA 0
   242  eb0c 85d3               		sta SA
   243  eb0e 20a5f4             		jsr OPENI			; open file
   244  eb11 20d2f0             		jsr TALK
   245  eb14 a5d3               		lda SA
   246  eb16 2043f1             		jsr SECND
   247                          
   248  eb19 a003               		ldy #3
   249                          list_blocks
   250  eb1b 84d1               		sty FNLEN
   251  eb1d 20c0f1             		jsr ACPTR			; read byte from IEEE
   252  eb20 85fd               		sta MEMUSS			; store blocks LSB
   253  eb22 a496               		ldy STATUS			; check the status. is it non-zero?
   254  eb24 d01b               		bne to_stoplisting		; yes
   255  eb26 20c0f1             		jsr ACPTR
   256  eb29 85fe               		sta MEMUSS + 1			; store blocks MSB
   257  eb2b a496               		ldy STATUS
   258  eb2d d012               		bne to_stoplisting
   259  eb2f a4d1               		ldy FNLEN
   260  eb31 88                 		dey 
   261  eb32 d0e7               		bne list_blocks
   262  eb34 a6fd               		ldx MEMUSS
   263  eb36 a5fe               		lda MEMUSS + 1
   264  eb38 2083cf             		jsr INTOUT			; write #blocks to screen
   265  eb3b a920               		lda #' '
   266  eb3d d006               		bne listing			; branch always
   267                          
   268                          ;-------------- Relative Branch forwarder
   269                          
   270  eb3f d03b               to_loadrun:	bne loadrun
   271  eb41 d031               to_stoplisting:	bne stoplisting
   272  eb43 d0d6               to_list_blocks:	bne list_blocks
   273                          
   274                          
   275                          ;-------------- Continuation of DIRECTORY
   276                          
   277                          listing
   278  eb45 2002e2             		jsr SCROUT
   279  eb48 20c0f1             LISTLOOP	jsr ACPTR			; read byte from IEEE
   280  eb4b a696               		ldx STATUS			; was it successful?
   281  eb4d d025               		bne stoplisting			; no, so exit
   282  eb4f c900               		cmp #0				; Is it end of line
   283  eb51 f018               		beq newline			; yes, jump ahead
   284  eb53 2002e2             		jsr SCROUT			; write filename and type
   285  eb56 2035f3             		jsr STOPEQ			; Was STOP key pressed?
   286  eb59 f019               		beq stoplisting			; Yes, we're done. Jump out
   287  eb5b 20e4ff             		jsr GETIN			; pause listing with SPACE key
   288  eb5e f0e8               		beq LISTLOOP			; no key pressed -> continue
   289  eb60 c920               		cmp #32				; <space>?
   290  eb62 d0e4               		bne LISTLOOP			; No, go back for more
   291                          
   292  eb64 20e4ff             listwait	jsr GETIN			; get a key
   293  eb67 f0fb               		beq listwait			; 0=no key, so keep waiting
   294                          
   295  eb69 d0dd               		bne LISTLOOP			; then continue
   296                          
   297                          ;-------------- end of directory entry
   298                          
   299  eb6b a90d               newline		lda #$0D			; <CR>
   300  eb6d 2002e2             		jsr SCROUT			; print it
   301  eb70 a002               		ldy #2
   302  eb72 d0cf               		bne to_list_blocks
   303                          
   304                          ;-------------- listing is done - end or stop key pressed
   305                          
   306  eb74 202ff7             stoplisting	jsr CLSEI			; close file with $E0, unlisten
   307                          
   308  eb77 68                 		pla 
   309  eb78 68                 		pla 
   310  eb79 4cffb3             		jmp READY			; BASIC warm start
   311                          
   312                          ;-------------- LOAD / RUN
   313                          
   314                          loadrun
   315  eb7c a900               		lda #0				; Clear status byte
   316  eb7e 8596               		sta STATUS
   317  eb80 859d               		sta VERCK			; LOAD=0, VERIFY=1
   318  eb82 2056f3             		jsr LOADOP			; LOAD without pointer change
   319                          
   320  eb85 a596               		lda STATUS			; Did it load?
   321  eb87 2910               		and #$10
   322  eb89 d020               		bne loaderr			; No, exit out
   323                          
   324  eb8b a5ca               		lda EAL+1			; end of program MSB
   325  eb8d 852b               		sta VARTAB+1			; start of basic variables MSB
   326  eb8f a5c9               		lda EAL				; end of program LSB
   327  eb91 852a               		sta VARTAB			; start of basic variables LSB
   328                          
   329  eb93 2034d5             		jsr CRLF
   330  eb96 20e9b5             		jsr RSTXCLR			; reset TXTPTR and perform CLR
   331  eb99 20b6b4             		jsr LINKPRG			; rebuild chaining of BASIC lines
   332                          
   333  eb9c a5b3               		lda wedge_char
   334  eb9e c92f               		cmp #$2f			; if '/' then load only, omit RUN
   335  eba0 d003               		bne startprg			; '^' --> RUN
   336  eba2 4cffb3             		jmp READY			; load only, exit with BASIC warm start
   337                          
   338  eba5 2022b6             startprg	jsr STXTPT			; reset TXTPTR
   339  eba8 4c4ab7             		jmp NEWSTT			; RUN
   340                          
   341  ebab 4c25f4             loaderr		jmp FILENOTFOUND		; FILE NOT FOUND, return to basic
   342                          

; ******** Source: editrom.asm
    96                          }		
    97                          	}
    98                          
    99                          	;----- These features require ESC codes
   100                          
   101                          	!IF ESCCODES = 1  {

; ******** Source: editescape.asm
     1                          ; PET/CBM EDIT ROM - Code to check for ESC Sequence
     2                          ; ================
     3                          ; Goal is to support as many C128/CBM-II ESC codes as possible
     4                          ;
     5                          
     6                          ;-------------- Check for ESC as LAST character
     7                          ;
     8                          ; NOTE: We JMP here from EDITROMxx.ASM. Accumulator holds code of CURRENT character
     9                          ;       If we want to continue processing as normal we need to JMP ESC_DONE.
    10                          ;       If we need to modify the action we set DATAX with the new character.
    11                          ;       If we want to skip the rest of the character processing we should JMP IRQ_EPILOG .
    12                          
    13  ebae a6f1               CheckESC	LDX LASTCHAR 		; Previous character printed
    14  ebb0 e01b               		CPX #$1B		; <ESC>?
    15  ebb2 f00c               		BEQ ESC_YES		; Yes, process it
    16  ebb4 c91b               		CMP #$1B		; Is current Chr ESC?
    17  ebb6 f003               		BEQ ESC_NOW		; Yes, 
    18  ebb8 4c19e2             		JMP ESC_DONE		; No, back to normal checking
    19                          
    20                          ;-------------- ESC is current Chr
    21                          
    22  ebbb 85f1               ESC_NOW		STA LASTCHAR		; Remember it
    23  ebbd 4c99e1             		JMP IRQ_EPILOG		; don't process anything
    24                          
    25                          ;-------------- Process ESC sequence
    26                          
    27  ebc0 c91b               ESC_YES		CMP #$1b		; Is current char <ESC>?
    28  ebc2 f002               		BEQ DoESCESC		; Yes, Do <ESC><ESC>
    29  ebc4 d005               		BNE DoEscapeCode	; No,  Do <ESC>+KEY
    30                          
    31                          ;-------------- Do <ESC><ESC>
    32                          
    33  ebc6 a900               DoESCESC	LDA #0			; Clear character
    34  ebc8 4cbde3             		JMP ESCAPE_O		; <ESC>+O (escape)
    35                          
    36                          ;-------------- Do <ESC>+KEY Sequence
    37                          
    38  ebcb 297f               DoEscapeCode	AND #$7F		; Strip top bit
    39  ebcd 38                 		SEC
    40                          !IF (COLOURPET=1) OR (VIDSWITCH=1) {
    41  ebce e930               		SBC #$30		; Subtract 30 (Start at "0")
    42  ebd0 c92f               		CMP #$2F		; Make sure it is in range!
    43                          } ELSE {
    44                          		SBC #$40		; Subtract 40 (Start at "@")
    45                          		CMP #$20		; Make sure it is in range!
    46                          }
    47  ebd2 b00f               		BCS DoESCDONE		; Yes, skip
    48                          
    49  ebd4 a200               		LDX #0
    50  ebd6 86f1               		STX LASTCHAR		; Clear Last Char
    51                          
    52  ebd8 0a                 		ASL
    53  ebd9 aa                 		TAX
    54  ebda bde7eb             		LDA ESCVECTORS+1,X	; ESC Sequence Vectors
    55  ebdd 48                 		PHA
    56  ebde bde6eb             		LDA ESCVECTORS,X	; ESC Sequence Vectors
    57  ebe1 48                 		PHA			; Push address to stack so RTS will jump to selected routine
    58                          ;		LDA #0			; Clear Character
    59  ebe2 60                 		RTS
    60                          
    61  ebe3 4c19e2             DoESCDONE	JMP ESC_DONE
    62                          
    63                          ;-------------- Esc Sequence Vectors    (*=changed from C128)
    64                          
    65                          ESCVECTORS
    66                          
    67                          ;--------------- COLOURPET ESC Codes: ESC 0 to 9 plus :;<=>?
    68                          ;                Set Colour to specified value (0 to 15).
    69                          ;
    70                          !IF (COLOURPET=1) OR (VIDSWITCH=1) {
    71                            !IF (COLOURPET=1) {
    72  ebe6 48ec               		!WORD ESCAPE_NUM-1	; Esc-0 Set Colour to Black
    73  ebe8 48ec               		!WORD ESCAPE_NUM-1	; Esc-1 Set Colour to Medium Grey
    74  ebea 48ec               		!WORD ESCAPE_NUM-1	; Esc-2 Set Colour to Blue
    75  ebec 48ec               		!WORD ESCAPE_NUM-1	; Esc-3 Set Colour to Light Blue
    76  ebee 48ec               		!WORD ESCAPE_NUM-1	; Esc-4 Set Colour to Green
    77  ebf0 48ec               		!WORD ESCAPE_NUM-1	; Esc-5 Set Colour to Light Green
    78  ebf2 48ec               		!WORD ESCAPE_NUM-1	; Esc-6 Set Colour to Dark Cyan
    79  ebf4 48ec               		!WORD ESCAPE_NUM-1	; Esc-7 Set Colour to Light Cyan
    80  ebf6 48ec               		!WORD ESCAPE_NUM-1	; Esc-8 Set Colour to Red
    81  ebf8 48ec               		!WORD ESCAPE_NUM-1	; Esc-9 Set Colour to Light Red
    82  ebfa 48ec               		!WORD ESCAPE_NUM-1	; Esc-: Set Colour to Dark Purple
    83  ebfc 48ec               		!WORD ESCAPE_NUM-1	; Esc-; Set Colour to Purple
    84  ebfe 48ec               		!WORD ESCAPE_NUM-1	; Esc-< Set Colour to Dark Yellow
    85  ec00 48ec               		!WORD ESCAPE_NUM-1	; Esc-= Set Colour to Yellow
    86  ec02 48ec               		!WORD ESCAPE_NUM-1	; Esc-> Set Colour to Light Grey
    87  ec04 48ec               		!WORD ESCAPE_NUM-1	; Esc-? Set Colour to White
    88                          } ELSE {
    89                          
    90                          ;--------------- VIDSWITCH ESC Codes: ESC 0 to 9
    91                          ;                Sets a specific video mode immediately (and temporarily)
    92                          ;                For manually setting the video mode, when testing different
    93                          ;                monitors and/or NTSC/PAL composite adapters.
    94                          ;                COLOURPET and VIDSWITCH cannot be combined!
    95                          ;
    96                          		!WORD ESCAPE_SETVID-1	; Esc-0 Set to Video MODE 0
    97                          		!WORD ESCAPE_VID-1	; Esc-1 Set to Video MODE 1
    98                          		!WORD ESCAPE_VID-1	; Esc-2 Set to Video MODE 2
    99                          		!WORD ESCAPE_VID-1	; Esc-3 Set to Video MODE 3
   100                          		!WORD ESCAPE_VID-1	; Esc-4 Set to Video MODE 4
   101                          		!WORD ESCAPE_VID-1	; Esc-5 Set to Video MODE 5
   102                          		!WORD ESCAPE_VID-1	; Esc-6 Set to Video MODE 6
   103                          		!WORD ESCAPE_VID-1	; Esc-7 Set to Video MODE 7
   104                          		!WORD ESCAPE_VID-1	; Esc-8 Set to Video MODE 8
   105                          		!WORD ESCAPE_VID-1	; Esc-9 Set to Video MODE 9
   106                          		!WORD NOESCAPE-1	; NONE
   107                          		!WORD NOESCAPE-1	; NONE
   108                          		!WORD NOESCAPE-1	; NONE
   109                          		!WORD NOESCAPE-1	; NONE
   110                          		!WORD NOESCAPE-1	; NONE
   111                          		!WORD NOESCAPE-1	; NONE
   112                            }
   113                          }
   114                          
   115                          ;-------------- Normal ESC Codes
   116                          
   117  ec06 45ec               		!WORD ESCAPE_AT-1	; Esc-@ Clear Remainder of Screen
   118  ec08 45ec               		!WORD ESCAPE_A-1	; Esc-a Auto Insert
   119  ec0a dde5               		!WORD ESCAPE_B-1	; Esc-b Bottom
   120  ec0c 45ec               		!WORD ESCAPE_C-1	; Esc-c Cancel Auto Insert
   121  ec0e ebe2               		!WORD ESCAPE_D-1	; Esc-d Delete Line
   122  ec10 58ec               		!WORD ESCAPE_E-1	; Esc-e ?     / Fill BG    (was: Cursor Non Flash)
   123  ec12 b9ec               		!WORD ESCAPE_F-1	; Esc-f Flash / Fill FG+BG (was: Cursor Flash)
   124  ec14 dcec               		!WORD ESCAPE_G-1	; Esc-g Bell Enable
   125  ec16 e3ec               		!WORD ESCAPE_H-1	; Esc-h Bell Disable
   126  ec18 bee5               		!WORD ESCAPE_I-1	; Esc-i Insert Line
   127  ec1a c0e1               		!WORD ESCAPE_J-1	; Esc-j Start-of-Line
   128  ec1c 45ec               		!WORD ESCAPE_K-1	; Esc-k End-of-Line
   129  ec1e 45ec               		!WORD ESCAPE_L-1	; Esc-l Scroll On
   130  ec20 45ec               		!WORD ESCAPE_M-1	; Esc-m Scroll Off
   131  ec22 b6ed               		!WORD ESCAPE_N-1	; Esc-n Screen Normal
   132  ec24 bce3               		!WORD ESCAPE_O-1	; Esc-o Escape all modes (Also: <ESC><ESC>)
   133  ec26 90e3               		!WORD ESCAPE_P-1	; Esc-p Erase Begin
   134  ec28 eaec               		!WORD ESCAPE_Q-1	; Esc-q Erase End
   135  ec2a beed               		!WORD ESCAPE_R-1	; Esc-r Screen Reverse
   136  ec2c f0ec               		!WORD ESCAPE_S-1	; Esc-s Text/Lowercase Mode * (was: Block Cursor)
   137  ec2e 9ee5               		!WORD ESCAPE_T-1	; Esc-t Top
   138  ec30 f6ec               		!WORD ESCAPE_U-1	; Esc-u Graphics/Uppercase Mode * (was: Underline Cursor)
   139  ec32 e1e3               		!WORD ESCAPE_V-1	; Esc-v Scroll Up
   140  ec34 c9e3               		!WORD ESCAPE_W-1	; Esc-w Scroll Down
   141  ec36 45ec               		!WORD ESCAPE_X-1	; Esc-x Switch 40/80 Col
   142  ec38 c6ed               		!WORD ESCAPE_Y-1	; Esc-y Normal Chr Set * (was: Set Default Tabs)
   143  ec3a ceed               		!WORD ESCAPE_Z-1	; Esc-z Alternate Chr Set * (was: Clear All Tabs)
   144  ec3c fcec               		!WORD ESCAPE_LB-1	; Esc-[ Mark Start
   145  ec3e 95ed               		!WORD ESCAPE_BS-1	; Esc-\ Toggle ASCII / DIN
   146  ec40 22ed               		!WORD ESCAPE_RB-1	; Esc-] Mark End (Copy)
   147  ec42 6fed               		!WORD ESCAPE_UA-1	; Esc-UPARROW Paste
   148  ec44 45ec               		!WORD ESCAPE_BA-1	; Esc-BACKARROW Display Project Info
   149                          
   150                          ;=============== ESCAPE CODES not in normal PET code
   151                          ;
   152                          ; The following ESCAPE CODE entry points need to be assigned
   153                          ; and/or additional code must be written to support them.
   154                          
   155                          ESCAPE_AT	; Esc-@ Clear Remainder of Screen
   156                          ESCAPE_A	; Esc-a Auto Insert
   157                          ESCAPE_C	; Esc-c Cancel Auto Insert
   158                          ESCAPE_K	; Esc-k End-of-Line
   159                          ESCAPE_L	; Esc-l Scroll On
   160                          ESCAPE_M	; Esc-m Scroll Off
   161                          
   162                          !IF SS40=0 {
   163                          ESCAPE_X	; Esc-x Switch 40/80 Col
   164                          }
   165                          		
   166                          !IF INFO=0 {
   167                          ESCAPE_BA	; Esc-Backarrow Display Project info
   168                          }
   169                          
   170                          ;-------------- These are codes that are not in 40-COL Codebase C0
   171                          
   172                          !IF CODEBASE=0 {
   173                          ESCAPE_B	; ESC-B Set Window Bottom
   174                          ESCAPE_T	; ESC-T Set Window Top
   175                          ESCAPE_D	; ESC-D Delete Line
   176                          ESCAPE_I	; ESC-I Insert Line
   177                          ESCAPE_J	; ESC-J Start of Line
   178                          }
   179                          
   180  ec46 4c99e1             NOESCAPE	JMP IRQ_EPILOG				; Ignore sequence for now
   181                          
   182                          
   183                          ;====================================================================================
   184                          ; New ESC sequences
   185                          ;====================================================================================
   186                          
   187                          ;-------------- ColourPET Colours
   188                          
   189                          !IF COLOURPET=1 {
   190  ec49 a5d9               ESCAPE_NUM	LDA DATAX				; Character
   191  ec4b 38                 		SEC
   192  ec4c e930               		SBC #$30				; Subtract 30 (Start at "0")
   193                          
   194  ec4e aa                 ESC_NUM2	TAX					; The Colour number becomes the index
   195  ec4f bd12ef             		LDA COLOURS,X				; Lookup the correct PETSCII code
   196  ec52 85d9               		STA DATAX				; replace ESC code with colour code
   197  ec54 a900               		LDA #0					;
   198  ec56 4c1be2             		JMP ESC_DONE2				; return and process
   199                          }
   200                          
   201                          ;-------------- Video Configuration Switching
   202                          
   203                          !IF VIDSWITCH=1 {
   204                          ESCAPE_VID	LDA DATAX				; Character
   205                          		SEC
   206                          		SBC #$30				; Subtract 30 (Start at "0")
   207                          		ASL
   208                          		ASL
   209                          		ASL
   210                          		ASL					; multiply by 16 (# of bytes per each set)
   211                          		TAY					; Y is offset into table
   212                          		LDX #0					; byte counter
   213                          
   214                          ESCVLOOP	LDA VIDMODE0,Y				; Get byte from table at offset Y
   215                          		STX CRT_Address				; Select the CRTC register 			CHIP
   216                          		STA CRT_Status				; Write to the register				CHIP
   217                          		INY					; Next table byte
   218                          		INX					; count
   219                          		CPX #14					; We copy R0 to R13. 14/15 are always zero.
   220                          		BMI ESCVLOOP				; loop for more
   221                          		LDA #0					;
   222                          		JMP IRQ_EPILOG				; Ignore sequence for now
   223                          
   224                          ;-------------- VIDEO MODES TABLE
   225                          ;
   226                          ; These are CRTC register sets. There are 16 bytes per set to make calculations simpler.
   227                          ; Use ESC+0 to ESC+9 to select a set to configure the CRTC controller.
   228                          ; NOTE: The CRTC registers can be updated using CHR codes 14 and 142 causing the video
   229                          ;       to revert to the default CRTC settings as set from the main code. This feature
   230                          ;       is handy for hardware testing or using an external composite adapter.
   231                          ;
   232                          ;         REGISTER -> R0 R1 R2 R3 R4  R5 R6 R7 R8 R9 R10 R11 R12 R13 Rxx Rxx   DESCRIPTION
   233                          ;                     -- -- -- -- -- --- -- -- -- -- --- --- --- --- --- ---   -----------
   234                          VIDMODE0 	!byte 49,40,41,15,40,  3,25,29, 0, 9,  0,  0, 16,  0,  0,  0 ; 40/80 TEXT     NA
   235                          VIDMODE1        !byte 49,40,41,15,32,  5,25,33, 0, 7,  0,  0, 16,  0,  0,  0 ; 40/80 GRAPHIC  NA
   236                          VIDMODE2	!byte 49,40,41,15,39,  0,25,32, 0, 9,  0,  0, 16,  0,  0,  0 ; 40/80 TEXT     EURO
   237                          VIDMODE3	!byte 49,40,41,15,49,  0,25,37, 0, 7,  0,  0, 16,  0,  0,  0 ; 40/80 GRAPHIC  EURO
   238                          VIDMODE4	!byte 58,40,44, 8,32,  9,25,29, 0, 9,  0,  0, 16,  0,  0,  0 ; 8296D TEXT     EURO
   239                          VIDMODE5	!byte 58,40,44, 8,41,  3,25,34, 0, 7,  0,  0, 16,  0,  0,  0 ; 8296D GRAPHIC  EURO
   240                          VIDMODE6        !byte 63,40,50,18,30,  6,25,28, 0, 7,  0,  0, 16,  0,  0,  0 ; NTSC
   241                          VIDMODE7	!byte 63,40,50,18,30,  6,25,28, 0, 7,  0,  0,  0,  0,  0,  0 ; NTSC / INVERT VIDEO
   242                          VIDMODE8	!byte 63,40,47,20,36,123,25,32, 0, 7,  0,  0, 16,  0,  0,  0 ; PAL
   243                          VIDMODE9        !byte 63,40,47,20,36,123,25,32, 0, 7,  0,  0,  0,  0,  0,  0 ; PAL  / INVERT VIDEO
   244                          ;
   245                          ; Extra Modes. You can substitute this mode for any above if you want
   246                          ;VIDMODEXXXX	!byte 49,20,31,15,40,  5,25,33, 0, 9,  0,  0, 16,  0,  0,  0 ; 20/40 TEXT     NA
   247                          
   248                          }
   249                          
   250                          ;------------------------------------------------------------------------------------------------
   251                          ; ESC-BACKARROW Display Project Info
   252                          
   253                          !IF INFO>0 {
   254                          ESCAPE_BA
   255                          
   256                          ;-------------- DISPLAY FONT ON SCREEN
   257                          !IF INFO = 2 {
   258                          		LDY #0				; Y=0
   259                          INFLOOP		TYA				; LOOP[  A=Y
   260                          		STA SCREEN_RAM,Y		; Put it on the screen
   261                          		INY				; Next position and character
   262                          		BNE INFLOOP			; ] Loop for more
   263                          }
   264                          
   265                          ;-------------- DISPLAY PROJECT INFO		
   266                          !IF INFO > 0 {
   267                          		LDA #<INFOSTRING		; point to INFO string
   268                          		LDY #>INFOSTRING
   269                          		JSR STROUTZ
   270                          		JMP IRQ_EPILOG
   271                          }
   272                          }
   273                          
   274                          ;------------------------------------------------------------------------------------------------
   275                          ; ESC-E = Fill BG Colour
   276                          ; For NormalPET ?
   277                          ; For ColourPET will fill the screen with the current BG colour (ignores window)
   278                          ;               The FG of each character is not changed.
   279                          ; Note: This might be changed in the future to work with windows!
   280                          
   281                          ESCAPE_E
   282                          
   283                          !if COLOURPET=1 {
   284  ec59 adda8f             		LDA COLOURV
   285  ec5c 29f0               		AND #$F0
   286  ec5e 85b7               		STA TMPZB7
   287  ec60 a200               		LDX #0
   288                          ESCELOOP
   289  ec62 bd0088             		LDA COLOUR_RAM,X
   290  ec65 290f               		AND #$0F
   291  ec67 05b7               		ORA TMPZB7
   292  ec69 9d0088             		STA COLOUR_RAM,X
   293                          
   294  ec6c bdfa88             		LDA COLOUR_RAM+250,X
   295  ec6f 290f               		AND #$0F
   296  ec71 05b7               		ORA TMPZB7
   297  ec73 9dfa88             		STA COLOUR_RAM+250,X
   298                          
   299  ec76 bdf489             		LDA COLOUR_RAM+500,X
   300  ec79 290f               		AND #$0F
   301  ec7b 05b7               		ORA TMPZB7
   302  ec7d 9df489             		STA COLOUR_RAM+500,X
   303                          
   304  ec80 bdee8a             		LDA COLOUR_RAM+750,X
   305  ec83 290f               		AND #$0F
   306  ec85 05b7               		ORA TMPZB7
   307  ec87 9dee8a             		STA COLOUR_RAM+750,X	; don't overwrite non-visible locations (used for storage)
   308                          
   309                          !IF COLUMNS=80 {
   310  ec8a bde88b             		LDA COLOUR_RAM+1000,X
   311  ec8d 290f               		AND #$0F
   312  ec8f 05b7               		ORA TMPZB7
   313  ec91 9de88b             		STA COLOUR_RAM+1000,X
   314                          
   315  ec94 bde28c             		LDA COLOUR_RAM+1250,X
   316  ec97 290f               		AND #$0F
   317  ec99 05b7               		ORA TMPZB7
   318  ec9b 9de28c             		STA COLOUR_RAM+1250,X
   319                          
   320  ec9e bddc8d             		LDA COLOUR_RAM+1500,X
   321  eca1 290f               		AND #$0F
   322  eca3 05b7               		ORA TMPZB7
   323  eca5 9ddc8d             		STA COLOUR_RAM+1500,X
   324                          
   325  eca8 bdd68e             		LDA COLOUR_RAM+1750,X
   326  ecab 290f               		AND #$0F
   327  ecad 05b7               		ORA TMPZB7
   328  ecaf 9dd68e             		STA COLOUR_RAM+1750,X	; don't overwrite non-visible locations (used for storage)
   329                          }
   330  ecb2 e8                 		INX
   331  ecb3 e0fa               		CPX #250
   332  ecb5 d0ab               		BNE ESCELOOP
   333                          }
   334  ecb7 4c99e1             		JMP IRQ_EPILOG
   335                          
   336                          
   337                          ;------------------------------------------------------------------------------------------------
   338                          ; ESC-F = Flash Screen / Fill FG+BG Colour (was: Cursor Flash)
   339                          ; For NormalPET this will toggle the REVERSE bit (bit 7) of each character on the screen (ignores window)
   340                          ; For ColourPET this will fill the screen with the current colour FG+BG (ignores window)
   341                          ; Note: This might be changed in the future to work with windows!
   342                          
   343                          ESCAPE_F
   344                          
   345                          !if COLOURPET=1 {
   346  ecba a200               		LDX #0
   347  ecbc adda8f             		LDA COLOURV
   348                          
   349  ecbf 9d0088             ESCFLOOP	STA COLOUR_RAM,X
   350  ecc2 9d0089             		STA COLOUR_RAM+$100,X
   351  ecc5 9d008a             		STA COLOUR_RAM+$200,X
   352  ecc8 9de88a             		STA COLOUR_RAM+$300-24,X	; don't overwrite non-visible locations (used for storage)
   353                          !IF COLUMNS = 80 {
   354  eccb 9de88b             		STA COLOUR_RAM+$400-24,X
   355  ecce 9de88c             		STA COLOUR_RAM+$500-24,X
   356  ecd1 9de88d             		STA COLOUR_RAM+$600-24,X
   357  ecd4 9dd08e             		STA COLOUR_RAM+$700-48,X	; don't overwrite non-visible locations (used for storage)
   358                          }
   359  ecd7 e8                 		INX
   360  ecd8 d0e5               		BNE ESCFLOOP
   361                          }
   362                          
   363                          !if COLOURPET=0 {
   364                          		LDX #0
   365                          ESCFLOOP2
   366                          		LDA SCREEN_RAM,X
   367                          		EOR #$80
   368                          		STA SCREEN_RAM,X
   369                          
   370                          		LDA SCREEN_RAM+250,X
   371                          		EOR #$80
   372                          		STA SCREEN_RAM+250,X
   373                          
   374                          		LDA SCREEN_RAM+500,X
   375                          		EOR #$80
   376                          		STA SCREEN_RAM+500,X
   377                          
   378                          		LDA SCREEN_RAM+750,X
   379                          		EOR #$80
   380                          		STA SCREEN_RAM+750,X	; don't overwrite non-visible locations (used for storage)
   381                          
   382                          !IF COLUMNS = 80 {
   383                          		LDA SCREEN_RAM+1000,X
   384                          		EOR #$80
   385                          		STA SCREEN_RAM+1000,X
   386                          
   387                          		LDA SCREEN_RAM+1250,X
   388                          		EOR #$80
   389                          		STA SCREEN_RAM+1250,X
   390                          
   391                          		LDA SCREEN_RAM+1500,X
   392                          		EOR #$80
   393                          		STA SCREEN_RAM+1500,X
   394                          
   395                          		LDA SCREEN_RAM+1750,X
   396                          		EOR #$80
   397                          		STA SCREEN_RAM+1750,X	; don't overwrite non-visible locations (used for storage)
   398                          }
   399                          		INX
   400                          		CPX #250
   401                          		BNE ESCFLOOP2
   402                          
   403                          }
   404  ecda 4c99e1             		JMP IRQ_EPILOG
   405                          
   406                          ;------------------------------------------------------------------------------------------------
   407                          ESCAPE_G						; Esc-g Bell Enable
   408  ecdd a901               		LDA #1
   409  ecdf 85f2               		STA BELLMODE
   410  ece1 4c99e1             		JMP IRQ_EPILOG
   411                          
   412                          ;------------------------------------------------------------------------------------------------
   413                          ESCAPE_H						; Esc-h Bell Disable
   414  ece4 a900               		LDA #0
   415  ece6 85f2               		STA BELLMODE
   416  ece8 4c99e1             		JMP IRQ_EPILOG
   417                          
   418                          ;------------------------------------------------------------------------------------------------
   419                          ESCAPE_Q						; Esc-q Erase End
   420  eceb 20d7ee             		JSR ERASE_TO_EOL
   421  ecee 4c99e1             		JMP IRQ_EPILOG
   422                          ;------------------------------------------------------------------------------------------------
   423                          ESCAPE_S						; Esc-s Standard Lowercase (was: Block Cursor)
   424  ecf1 2062e0             		JSR CRT_SET_TEXT			; Set Lowercase/Text Mode
   425  ecf4 4c99e1             		JMP IRQ_EPILOG
   426                          ;------------------------------------------------------------------------------------------------
   427                          ESCAPE_U						; Esc-u Uppercase (was: Underline Cursor - not supported on PET)
   428  ecf7 206ae0             		JSR CRT_SET_GRAPHICS			; Set Uppercase/Graphics Mode
   429  ecfa 4c99e1             		JMP IRQ_EPILOG
   430                          
   431                          ;-------------- Copy/Paste functions
   432                          ;
   433                          ; These functions use Tape Buffer#1 to store copied byte(s)
   434                          ; TAPEB1   - Set to "ESC" character to indicate valid Start Marker
   435                          ; TAPEB+1  - Length of string (Max 160 characters)
   436                          ; TAPEB+2/3- Pointer to screen marked starting position 
   437                          ; TAPEB+4..- Buffer
   438                          ;
   439                          ; TODO: Add check for buffer start > buffer end !!!!
   440                          
   441                          ;-------------- ESC-[ Mark Start
   442                          
   443                          ESCAPE_LB
   444  ecfd ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   445  ed00 c91b               		CMP #27					; is it ESC?
   446  ed02 f00a               		BEQ ESCLB_SET				; Yes, Start Mark, so skip initialize
   447                          
   448  ed04 a900               		LDA #0					; Initialize buffer -
   449  ed06 8d7b02             		STA TAPEB1+1				; Set Buffer Length to zero
   450  ed09 a91b               		LDA #27					; Buffer identifier = ESC
   451  ed0b 8d7a02             		STA TAPEB1				; Set Buffer identifier
   452                          ESCLB_SET	
   453  ed0e a5c5               		LDA ScrPtr+1				; Copy HI byte of line pointer
   454  ed10 8d7d02             		STA TAPEB1+3				; to buffer
   455  ed13 a5c4               		LDA ScrPtr				; Get LO byte of line pointer
   456  ed15 18                 		CLC
   457  ed16 65c6               		ADC CursorCol				; Add cursor offset
   458  ed18 8d7c02             		STA TAPEB1+2				;   to buffer
   459  ed1b 9003               		BCC ESCLB_SKIP				; do we need to update HI byte?
   460  ed1d ee7d02             		INC TAPEB1+3				; yes, increment it
   461  ed20 4c99e1             ESCLB_SKIP	JMP IRQ_EPILOG				; Return
   462                          
   463                          ;--------------- ESC-] Mark End (Copy to buffer)
   464                          
   465                          ESCAPE_RB	
   466  ed23 ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   467  ed26 c91b               		CMP #27					; is it ESC?
   468  ed28 d043               		BNE ESCRB_EXIT				; No Start Mark, so exit out
   469                          		
   470                          ESCRB_INIT
   471  ed2a ad7d02             		LDA TAPEB1+3				; Copy Hi byte of paste buffer pointer
   472  ed2d 85c8               		STA SAL+1				;   to work pointer
   473  ed2f ad7c02             		LDA TAPEB1+2				; Copy Lo byte of paste buffer pointer
   474  ed32 85c7               		STA SAL					;   to work pointer
   475                          
   476  ed34 a5c5               		LDA ScrPtr+1				; Copy Hi byte of screen pointer
   477  ed36 85ca               		STA EAL+1				;   to work pointer 2
   478  ed38 a5c4               		LDA ScrPtr				; Copy Lo byte of screen pointer
   479  ed3a 18                 		CLC
   480  ed3b 65c6               		ADC CursorCol				; Add cursor position
   481  ed3d 85c9               		STA EAL					;   to work pointer 2
   482  ed3f 9002               		BCC ESCRB_SKIP				; do we need to update Hi byte?
   483  ed41 e6ca               		INC EAL+1				; yes, increment it
   484                          
   485  ed43 a200               ESCRB_SKIP	LDX #0					; length counter
   486  ed45 a000               		LDY #0					; offet for pointer
   487                          ESCRB_LOOP
   488  ed47 b1c7               		LDA (SAL),Y				; read byte from screen (SAL is updated, y never changes)
   489  ed49 9d7e02             		STA TAPEB1+4,X				; Store in buffer (x is index)
   490                          
   491  ed4c a5c8               		LDA SAL+1				; Get HI byte
   492  ed4e c5ca               		CMP EAL+1				; Does it match?
   493  ed50 d006               		BNE ESCRB_CHECK				; no, keep going
   494  ed52 a5c7               		LDA SAL					; get lo byte of pointer
   495  ed54 c5c9               		CMP EAL					; does it match?
   496                          
   497  ed56 b00d               		BCS ESCRB_DONE				; yes, finish up
   498                          
   499  ed58 e8                 ESCRB_CHECK	INX
   500  ed59 e6c7               		INC SAL					; Increment pointer LO byte
   501  ed5b a5c7               		LDA SAL					; read it
   502  ed5d d002               		BNE ESCRB2				; is byte 0? No, skip hi byte
   503  ed5f e6c8               		INC SAL+1				; yes, increment hi byte
   504                          
   505  ed61 e0a0               ESCRB2		CPX #160				; Are we at maximum buffer length?
   506  ed63 d0e2               		BNE ESCRB_LOOP				; No, loop back for more
   507                          
   508  ed65 8e7b02             ESCRB_DONE	STX TAPEB1+1				; Store string length
   509  ed68 a900               		LDA #0
   510  ed6a 9d7f02             		STA TAPEB1+5,X				; Store a ZERO at end for STROUT routine
   511  ed6d 4c99e1             ESCRB_EXIT	JMP IRQ_EPILOG				; Return
   512                          
   513                          ;--------------- ESC-UPARROW - Copy from buffer to screen
   514                          ESCAPE_UA	
   515  ed70 ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   516  ed73 c91b               		CMP #27					; is it ESC?
   517  ed75 d01c               		BNE ESCUA_OUT				; No Start Mark, so exit out
   518                          
   519  ed77 20aee6             		JSR BEEP
   520  ed7a a97e               		lda #<TAPEB1+4				; setup string address
   521  ed7c 85c7               		STA SAL
   522  ed7e a002               		ldy #>TAPEB1+4
   523  ed80 85c8               		STA SAL+1
   524                          
   525  ed82 a000               ESCUA_LOOP	LDY #0					; counter
   526  ed84 b1c7               		LDA (SAL),Y				; get byte from buffer
   527  ed86 f00b               		BEQ ESCUA_OUT
   528  ed88 20d2ff             		JSR BSOUT				; print it
   529  ed8b e6c7               		INC SAL
   530  ed8d d0f3               		BNE ESCUA_LOOP
   531  ed8f e6c8               		INC SAL+1
   532  ed91 d0ef               		BNE ESCUA_LOOP
   533                          
   534  ed93 4c99e1             ESCUA_OUT	JMP IRQ_EPILOG				; Return		
   535                          
   536                          
   537                          ;-------------- Eurokey Functions
   538                          ;
   539                          ; These functions SET or CLEAR the EUROFLAG location.
   540                          ; A '0' means use ASCII layout. A '1' means use DIN layout (swap Y and Z)
   541                          
   542  ed96 a5f3               ESCAPE_BS	LDA EUROFLAG
   543  ed98 4901               		EOR #1
   544                          
   545  ed9a 85f3               EuroSet		STA EUROFLAG
   546  ed9c 20aee6             		JSR BEEP
   547  ed9f 4c99e1             		JMP IRQ_EPILOG
   548                          
   549                          ;-------------- Check if Euro keys need swapping
   550                          ;
   551                          ; .A contains character to add to keyboard buffer. If EUROFLAG=1 then check if Y or Z need swapping.
   552                          
   553  eda2 a6f3               EUROSWAP	LDX EUROFLAG		; Flag to swap Z and Y keys; 1=Swap
   554  eda4 f00e               		BEQ EUROSWAP_OUT
   555                          
   556  eda6 c95a               		CMP #'Z'		; Is it "Z"?
   557  eda8 d004               		BNE EUROSWAP2
   558  edaa a959               		LDA #'Y'		; Yes, swap with "Y"
   559  edac d006               		BNE EUROSWAP_OUT
   560  edae c959               EUROSWAP2	CMP #'Y'		; Is it "Y"?
   561  edb0 d002               		BNE EUROSWAP_OUT
   562  edb2 a95a               		LDA #'Z'		; Yes, swap with "Z"
   563  edb4 4c63e5             EUROSWAP_OUT	JMP SCAN_NORM2		; Return to keyboard routine
   564                          
   565                          
   566                          ;-------------- Switchable 40/80 column Functions
   567                          ;
   568                          ; When SS40=1, ESC-X switches between 40/80 column mode.
   569                          ; Currently this is done with SOFT40 method where the 80 column screen is
   570                          ; reprogrammed to 40 column by increasing the left and right margins.
   571                          ; With future hardware we may be able to switch between REAL 40/80 column mode.
   572                          
   573                          !IF SS40=1 {
   574                          ESCAPE_X	JSR SS40_SwapModes	; Swap 40/80 Modes
   575                          		JMP IRQ_EPILOG		
   576                          }
   577                          
   578                          ;-------------- CRTC Chip Functions
   579                          ;
   580                          ; CRTC controller REGISTER 12 is used for Screen RAM Address HI
   581                          ; BIT 4 controls the INVERT line     (normal=1,rvs=0)
   582                          ; BIT 5 controls the CHR OPTION line (normal=0,alternate=1)
   583                          ;
   584                          ; NOTE: Only the MOTOROLA 6845 CRTC chip can READ register 12!
   585                          ; If MOT6845=0 then Register 12 is simply set (default for compatibility with most PET machines!)
   586                          ; If MOT6845=1 then Register 12 is read and then manipulated.
   587                          
   588                          ESCAPE_N						; ESC-N = Screen Normal
   589  edb7 20dbed             		JSR CRTPREP
   590                          	!if MOT6845=1 {
   591                          		ORA #%00010000				; Set BIT 4
   592                          	} else {
   593  edba a910               		LDA #16					; Normal screen, Normal chr set
   594                          	}
   595  edbc 4cd4ed             		JMP CRTUPDATE
   596                          
   597                          ESCAPE_R						; ESC-R = Screen Reverse
   598  edbf 20dbed             		JSR CRTPREP
   599                          	!if MOT6845=1 {
   600                          		AND #%11101111				; Clear BIT 4
   601                          	} else {
   602  edc2 a900               		LDA #0					; Reverse screen, Normal chr set
   603                          	}
   604  edc4 4cd4ed             		JMP CRTUPDATE
   605                          
   606                          ESCAPE_Y						; ESC-Y = Normal Chr Set    (B-series). Was: Set Default Tabs (C128)
   607  edc7 20dbed             		JSR CRTPREP
   608                          	!if MOT6845=1 {
   609                          		AND #%11011111				; Clear BIT 5
   610                          	} else {
   611  edca a910               		LDA #16					; Normal screen, Normal chr set
   612                          	}
   613  edcc 4cd4ed             		JMP CRTUPDATE
   614                          				
   615                          ESCAPE_Z						; ESC-Z = Alternate Chr Set (B-Series). Was: Clear All Tabs (C128)
   616  edcf 20dbed             		JSR CRTPREP
   617                          	!if MOT6845=1 {
   618                          		ORA #%00100000				; Set BIT 5
   619                          	} else {
   620  edd2 a930               		LDA #48					; Normal screen, Alternate chr set
   621                          	}
   622                          CRTUPDATE
   623  edd4 8d81e8             		STA CRT_Status				; Write the Value to previously selected register
   624  edd7 58                 		CLI					; Enable Interrupts
   625  edd8 4c99e1             		JMP IRQ_EPILOG				; Continue
   626                          
   627  eddb 78                 CRTPREP		SEI
   628  eddc a90c               		LDA #12					; CRTC Register#12 - Display Address HI
   629  edde 8d80e8             		STA CRT_Address				; Select the Register 
   630  ede1 ad81e8             		LDA CRT_Status				; Read the Value (if CRTC chip is NOT a Motorola6845 then this will not work)
   631  ede4 60                 		RTS

; ******** Source: editrom.asm
   102                          

; ******** Source: colourpetsubs.asm
     1                          ; PET/CBM EDIT ROM - ColourPET Routines; Init, Change colours, Set Registers, Sync Pointers
     2                          ; ================
     3                          ;
     4                          ; Standard C128 colour codes will be used.
     5                          ; ------------------------------------------------------------------
     6                          ; NOTE: Some code is included for possible future hardware options
     7                          ;       Colour key codes (C64 code at E8DA)
     8                          ; ------------------------------------------------------------------
     9                          
    10                          ;-------------- Check Colour Codes
    11                          ;
    12                          ; Checks if the character to print is a colour code.
    13                          ; If so it sets the proper foreground, background or border COLOUR.
    14                          ; To set colours you can use 1 to 3 contiguous color code characters.
    15                          ; The FIRST code will set the FG colour (normal behaviour)
    16                          ; The SECOND code will set the BG colour
    17                          ; The THIRD code will set the BORDER colour (future hardware)
    18                          ; Any NON-Colour Code will reset the count
    19                          
    20                          CheckColourCodes
    21                          
    22                          !if DEBUG = 1 { INC DBLINE+9 }			; DEBUG
    23                          
    24  ede5 48                 		PHA				; Save the character
    25  ede6 a20f                  		LDX #$0F			; Table has 15 entries
    26  ede8 dd12ef             ccloop		CMP COLOURS,X			; Does it match code from table?
    27  edeb f00a               		BEQ ccfound			; Yes, done
    28  eded ca                 		DEX				; 
    29  edee 10f8               		BPL ccloop			; loop for more
    30                          
    31  edf0 a200               ccnotfound	LDX #0				; not found
    32  edf2 8ede8f             		STX COLOURCOUNT			; Clear the Count
    33  edf5 f027               		BEQ ccexit			; no match, exit 
    34                          
    35  edf7 eede8f             ccfound		INC COLOURCOUNT			; Count code
    36  edfa 8a                 		TXA
    37  edfb aede8f             		LDX COLOURCOUNT			; 
    38  edfe e001               		CPX #1				; FIRST?
    39  ee00 d003               		BNE cc3		
    40  ee02 8ddb8f             		STA COLOURFG			; Set the FG colour		
    41                          
    42  ee05 e002               cc3		CPX #2				; SECOND?
    43  ee07 d003               		BNE cc4
    44  ee09 8ddc8f             		STA COLOURBG			; Set the BG colour
    45                          
    46  ee0c e003               cc4		CPX #3				; THIRD?
    47  ee0e d00b               		BNE cc5
    48  ee10 8ddd8f             		STA COLOURBORDER		; Set the BORDER colour
    49  ee13 8de08f             		STA COLOURREGBORDER		; Store it in the BORDER register
    50  ee16 a900               		LDA #0
    51  ee18 8dde8f             		STA COLOURCOUNT			; Reset count
    52                          
    53  ee1b 203aee             cc5		JSR SetColourValue   		; Set the FG/BG value
    54  ee1e 68                 ccexit		PLA				; Restore the Character
    55  ee1f 60                 		RTS
    56                          
    57                          ;-------------- Initialize ColourPET
    58                          ;
    59                          ; This is called from the RESET_EDITOR routine.
    60                          ; It sets the default foreground, background and border colours.
    61                          
    62                          ColourPET_Init
    63                          
    64                          		!IF COLOURPET = 2 { JSR ClearColourRAM }
    65                          
    66  ee20 200fe6             		JSR INIT_EDITOR			; Do Normal Initialization
    67                          
    68  ee23 a900               		LDA #0
    69  ee25 8dde8f             		STA COLOURCOUNT			; Reset Colour Count
    70                          
    71  ee28 a902               		LDA #DEFAULTFG			; Default Foreground Colour
    72  ee2a 8ddb8f             		STA COLOURFG
    73  ee2d a902               		LDA #DEFAULTBG			; Default Background Colour
    74  ee2f 8ddc8f             		STA COLOURBG
    75  ee32 a902               		LDA #DEFAULTBO			; Default Border Colour
    76                          		
    77                          ;-------------- Set Border Colour and update Register
    78                          
    79                          SetColourAndBorder
    80  ee34 8ddd8f             		STA COLOURBORDER		; Set the BORDER colour
    81  ee37 8de08f             		STA COLOURREGBORDER		; Store it in the BORDER register
    82                          
    83                          ;-------------- Set Colour
    84                          ;
    85                          ; COLOURMODE OPTION: 0=DIGITAL, 1=ANALOG
    86                          ;
    87                          ; DIGITAL: Takes the FG colour and BG colour and combines them into one value
    88                          ;          RGBIRGBI - Lower bits for FG, Upper bits for BG
    89                          ;
    90                          ; ANALOG : Takes the FG colour and uses it as an index to the RGB Conversion table.
    91                          ;          RRRGGGBB All bits for FG. Background colour set for entire screen
    92                          
    93                          SetColourValue
    94                          
    95                          !if COLOURMODE=0 {
    96  ee3a addc8f             		LDA COLOURBG			; Get the BG colour
    97  ee3d 0a                 		ASL				; move BG colour to upper nibble
    98  ee3e 0a                 		ASL
    99  ee3f 0a                 		ASL
   100  ee40 0a                 		ASL
   101  ee41 18                 		CLC
   102  ee42 6ddb8f             		ADC COLOURFG			; Add the FG colour
   103                          } ELSE {
   104                          		LDX COLOURFG			; Get the FG index
   105                          		LDA RGBTABLE,X			; Convert it to Analog RRRGGGBB
   106                          }
   107  ee45 8dda8f             		STA COLOURV			; Store it
   108  ee48 60                 		RTS
   109                          
   110                          ;-------------- Clear Colour Ram - Green on Black
   111                          ;
   112                          ; This was a temporary solution until colour routines were debugged.
   113                          ; Not needed now since Colour Erase_To_EOL completed. But might come in handly later.
   114                          ; NOTE: This routine clears ALL colour ram INCLUDING areas used for storage!!!!!!
   115                          
   116                          ClearColourRAM
   117  ee49 a905               		LDA #5
   118  ee4b a200               		LDX #0
   119                          CCRAM1		
   120  ee4d 9d0088             		STA COLOUR_RAM,X
   121  ee50 9d0089             		STA COLOUR_RAM+$100,X
   122  ee53 9d008a             		STA COLOUR_RAM+$200,X
   123  ee56 9d008b             		STA COLOUR_RAM+$300,X
   124                          !IF COLUMNS = 80 {
   125  ee59 9d008c             		STA COLOUR_RAM+$400,X
   126  ee5c 9d008d             		STA COLOUR_RAM+$500,X
   127  ee5f 9d008e             		STA COLOUR_RAM+$600,X
   128  ee62 9d008f             		STA COLOUR_RAM+$700,X
   129                          }
   130  ee65 e8                 		INX
   131  ee66 d0e5               		BNE CCRAM1
   132  ee68 60                 		RTS
   133                          
   134                          ;-------------- Sync Pointers - Current Line
   135                          ;
   136                          ; This takes the current line number in X and then uses the lookup tables
   137                          ; to find the screen and colour ram address of the start of the line and stores them
   138                          ; in the Character and Colour pointers.
   139                          
   140                          ColourPET_SyncPointersX
   141  ee69 85c4               		STA ScrPtr				; Pointer: Current Screen Line Address LO
   142  ee6b bd7ae7             		LDA Line_Addr_Hi,X			; Screen Line Addresses HI
   143  ee6e 85c5               		STA ScrPtr+1         			; Pointer: Current Screen Line Address HI
   144                          
   145  ee70 bd93e7             		LDA CLine_Addr_Lo,X			; Colour Screen Line Addresses LO
   146  ee73 85c0               		STA COLOURPTR				; Colour Pointer: Current Screen Line Address LO
   147  ee75 bdace7             		LDA CLine_Addr_Hi,X			; Colour Screen Line Addresses HI
   148  ee78 85c1               		STA COLOURPTR + 1      			; Colour Pointer: Current Screen Line Address HI
   149                          
   150  ee7a 60                 		RTS
   151                          
   152                          ;-------------- Sync Pointers - Next Line
   153                          ;
   154                          ; This takes the current line number in X and then uses the lookup tables
   155                          ; to find the screen and colour ram address of the start of the NEXT line and stores them
   156                          ; in the Character and Colour pointers.
   157                          
   158                          ColourPET_SyncPointers
   159  ee7b bd62e7             		LDA Line_Addr_Lo+1,X			; Screen line address table LO + 1
   160  ee7e 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   161  ee80 bd7be7             		LDA Line_Addr_Hi+1,X			; Screen line address table HI + 1
   162  ee83 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   163                          
   164  ee85 bd94e7             		LDA CLine_Addr_Lo+1,X     		; Screen Line address table LO + 1
   165  ee88 85c2               		STA COLOURPTR2				; Second Colour RAM Pointer
   166  ee8a bdade7             		LDA CLine_Addr_Hi+1,X 			; Screen Line address table HI + 1
   167  ee8d 85c3               		STA COLOURPTR2+1			;
   168  ee8f 60                 		RTS
   169                          
   170                          ColourPET_SyncPointers2
   171  ee90 bd60e7             		LDA Line_Addr_Lo-1,X			; Screen line address table LO - 1
   172  ee93 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   173  ee95 bd79e7             		LDA Line_Addr_Hi-1,X			; Screen line address table HI - 1
   174  ee98 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   175                          
   176  ee9a bd92e7             		LDA CLine_Addr_Lo-1,X     		; Screen Line address table LO - 1
   177  ee9d 85c2               		STA COLOURPTR2				; Second Colour RAM Pointer
   178  ee9f bdabe7             		LDA CLine_Addr_Hi-1,X 			; Screen Line address table HI - 1
   179  eea2 85c3               		STA COLOURPTR2+1			;
   180  eea4 60                 		RTS
   181                          
   182                          
   183                          ;-------------- Scroll Left
   184                          
   185                          ColourPET_Scroll_Left
   186  eea5 c8                 CPSL1		INY
   187  eea6 b1c4               		LDA (ScrPtr),Y				; Read Character from Screen RAM
   188  eea8 88                 		DEY					; move to the left
   189  eea9 91c4               		STA (ScrPtr),Y				; Write Character to Screen RAM
   190  eeab c8                 		INY
   191  eeac b1c0               		LDA (COLOURPTR),Y			; Read Colour from Colour RAM	@@@@@@@@@@@@@@ ColourPET
   192  eeae 88                 		DEY					; move to the left
   193  eeaf 91c0               		STA (COLOURPTR),Y			; Write Colour to Colour RAM	@@@@@@@@@@@@@@ ColourPET
   194  eeb1 c8                 		INY
   195  eeb2 c4d5               		CPY RightMargin
   196  eeb4 d0ef               		BNE CPSL1
   197  eeb6 60                 		RTS
   198                          
   199                          ;-------------- Insert
   200                          
   201                          ColourPET_Insert
   202  eeb7 88                 CPI1		DEY
   203  eeb8 b1c4               		LDA (ScrPtr),Y				; Read Character from Screen RAM
   204  eeba c8                 		INY					; move to the left
   205  eebb 91c4               		STA (ScrPtr),Y				; Write Character to Screen RAM
   206  eebd 88                 		DEY
   207  eebe b1c0               		LDA (COLOURPTR),Y			; Read Colour from Colour RAM	@@@@@@@@@@@@@@ ColourPET
   208  eec0 c8                 		INY					; move to the left
   209  eec1 91c0               		STA (COLOURPTR),Y			; Write Colour to Colour RAM	@@@@@@@@@@@@@@ ColourPET
   210  eec3 88                 		DEY
   211  eec4 c4c6               		CPY CursorCol
   212  eec6 d0ef               		BNE CPI1
   213                          
   214  eec8 adda8f             		LDA COLOURV				; Current Colour              	@@@@@@@@@@@@@@ COLOURPET
   215  eecb 91c0               		STA (COLOURPTR),Y			; Write it to the Colour RAM	@@@@@@@@@@@@@@ COLOURPET
   216                          
   217  eecd 60                 		RTS
   218                          
   219                          ;--------------- Copy Character and Colour from SOURCE to DEST
   220                          
   221                          ColourPET_Scroll_Dest
   222  eece b1c7               		LDA (SAL),Y				; Read Character from Screen SOURCE
   223  eed0 91c4               		STA (ScrPtr),Y				; Write it to Screen DESTINATION
   224  eed2 b1c2               		LDA (COLOURPTR2),Y			; Read Colour from Colour RAM SOURCE	@@@@@@@@@@@@@@@ COLOURPET
   225  eed4 91c0               		STA (COLOURPTR),Y			; Write it to Screen DESTINATION	@@@@@@@@@@@@@@@ COLOURPET
   226  eed6 60                 		RTS
   227                          
   228                          ;-------------- Erase to End of Line
   229                          ;
   230                          ; Clears ONE line on the screen from current cursor to RIGHT margin
   231                          ; Called from WINDOW_CLEAR and WINDOW_SCROLL_UP.
   232                          ; Replaces equivilent non-colour routine.
   233                          ; Must not modify X since it is used as a line counter in WINDOW_CLEAR.
   234                          
   235                          ERASE_TO_EOL
   236  eed7 98                 		TYA					; Save the Current offset
   237  eed8 48                 		PHA					; to the stack
   238                          
   239  eed9 a920               		LDA #$20 				; <SPACE>
   240  eedb c8                 CEOL		INY					; next character
   241  eedc 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address @@@@@@@@@@@@@@ ColourPET
   242  eede c4d5                		CPY RightMargin
   243  eee0 90f9               		BCC CEOL				; loop up for more
   244                          
   245  eee2 68                 		PLA					; Pull the offset from the stack
   246  eee3 a8                 		TAY					; 
   247                          
   248  eee4 adda8f             		LDA COLOURV				; The current colour
   249  eee7 c8                 CEOL2		INY					; Next colour ram location
   250  eee8 91c0               		STA (COLOURPTR),Y			; Clear Colour RAM
   251  eeea c4d5               		CPY RightMargin
   252  eeec 90f9               		BCC CEOL2				; loop up for more
   253  eeee 60                 		RTS
   254                          
   255                          ;-------------- Writes the NEW Character and Colour to the Screen
   256                          Put_ColourChar_at_Cursor
   257  eeef 48                 		PHA				; Save the character
   258  eef0 a4c6               		LDY CursorCol			; Cursor Column on Current Line
   259  eef2 adda8f             		LDA COLOURV			; Current Colour Attribute
   260  eef5 91c0               		STA (COLOURPTR),Y		; Put the Colour to ColourRAM
   261  eef7 68                 		PLA				; Restore the character
   262  eef8 a4c6               		LDY CursorCol			; Cursor Column on Current Line		
   263  eefa 91c4               		STA (ScrPtr),Y			; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
   264  eefc a902               		LDA #2				; Set blink count so cursor appears immediately
   265  eefe 85a8               		STA BLNCT			; Timer: Countdown to Toggle Cursor
   266  ef00 60                 		RTS
   267                          
   268                          ;-------------- Writes the OLD Colour at Cursor Position to the screen
   269                          Restore_Colour_at_Cursor
   270  ef01 48                 		PHA				; Push Character
   271  ef02 a4c6               		LDY CursorCol			; Cursor Column on Current Line
   272  ef04 a5ed               		LDA CURSORCOLOUR		; Get current Colour
   273  ef06 91c0               		STA (COLOURPTR),Y		; Set the Colour
   274  ef08 68                 		PLA				; Pull Character
   275  ef09 a4c6               		LDY CursorCol			; Cursor Column on Current Line		
   276  ef0b 91c4               		STA (ScrPtr),Y			; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
   277  ef0d a902               		LDA #2				; Set blink count so cursor appears immediately
   278  ef0f 85a8               		STA BLNCT			; Timer: Countdown to Toggle Cursor
   279  ef11 60                 		RTS
   280                          
   281                          ;-------------- Colour Codes Table
   282                          ;
   283                          ; These are the Colour PETSCII codes. We use C128 ordering to be compatible with it.
   284                          ;
   285                          ;	PETSCII Code	C64 colour		C128 colour (*=changed)
   286                          ;       ------------   	----------		-----------
   287                          COLOURS
   288  ef12 90                 	!byte $90	;0=black		0=black
   289  ef13 98                 	!byte $98	;12=medium grey		1=medium grey
   290  ef14 1f                 	!byte $1F	;6=blue			2=blue
   291  ef15 9a                 	!byte $9A	;14=light blue		3=light blue
   292  ef16 1e                 	!byte $1E	;5=green		4=green
   293  ef17 99                 	!byte $99	;13=light green		5=light green	(CONFLICT! PET = SCROLL UP!)
   294  ef18 97                 	!byte $97	;11=dark grey		6=dark cyan*
   295  ef19 9f                 	!byte $9F	;3=cyan			7=light cyan*
   296  ef1a 1c                 	!byte $1C	;2=red			8=red
   297  ef1b 96                 	!byte $96	;10=light red		9=light red	(CONFLICT! PET = ERASE END!)
   298  ef1c 81                 	!byte $81	;8=orange		10=dark purple*
   299  ef1d 9c                 	!byte $9C	;4=magenta		11=magenta/purple
   300  ef1e 95                 	!byte $95	;9=brown		12=dark yellow* (CONFLICT! PET = INS LINE!)
   301  ef1f 9e                 	!byte $9E	;7=yellow		13=yellow
   302  ef20 9b                 	!byte $9B	;15=light grey		14=light grey
   303  ef21 05                 	!byte $05	;1=white		15=white
   304                          
   305  ef22 00                 	!byte 0 ; separator
   306                          
   307                          !IF COLOURMODE=1 {
   308                          
   309                          ;-------------- Analog Colour Conversion Table
   310                          ; 
   311                          ; Converts colour code index to RRRGGGBB value for Analog ColourPET board
   312                          ; R and G have a range of 0 to 7, B has 0 to 3
   313                          ; If "I" is off, R and G have values of 4, B is 2.
   314                          ; If "I" is on, R and G have values of 7, B is 3.
   315                          
   316                          RGBTABLE
   317                          ;              RRRGGGBB
   318                          	!byte %00000000	;0=black
   319                          	!byte %01101101	;1=medium grey
   320                          	!byte %00000010	;2=blue
   321                          	!byte %00000011	;3=light blue
   322                          	!byte %00010000	;4=green
   323                          	!byte %00011100	;5=light green
   324                          	!byte %10010000	;6=dark cyan*
   325                          	!byte %11111100	;7=light cyan*
   326                          	!byte %10000000	;8=red
   327                          	!byte %11100000	;9=light red
   328                          	!byte %10000010	;10=dark purple*
   329                          	!byte %11100011	;11=magenta/purple
   330                          	!byte %00010010	;12=dark yellow*
   331                          	!byte %00011111	;13=yellow
   332                          	!byte %11011010	;14=light grey
   333                          	!byte %11111111	;15=white
   334                          }

; ******** Source: editrom.asm
   103                          }
   104                          
   105                          		!IF SS40 = 1      {
   106                          			!SOURCE "editsoft40.asm"
   107                          			!IF (CODEBASE=0) {
   108                          				!SOURCE "editrom40link.asm"		; Relocate linking code here to make space in main.
   109                          				!SOURCE "editrom40scrollup.asm"		; Relocate scroll up code here to make space in main.
   110                          				JMP CHECK_SCROLL_CONTROL		; Jump back to main.
   111                          			}
   112                          		}
   113                          	}
   114                          
   115                          	;----- These features can stand alone
   116                          

; ******** Source: editreboot.asm
     1                          ; PET/CBM EDIT ROM - Soft Reboot (C)2013 Steve J. Gray
     2                          ; ================
     3                          ; Soft Reboot - Hold down a combination of keys to reset the computer.
     4                          ; The RebootCodes table holds 10 or 16 values, one for each keyboard ROW. All
     5                          ; values must match to trigger the reset. Note the values are RAW Keyboard
     6                          ; column bits NOT PETSCII. When a key is DOWN the bit in that column is ZERO.
     7                          ; IE, $FF means NO keys are down. Do not fill table with all $FF's or the 
     8                          ; machine will reboot constantly.
     9                          ;
    10                          ; OPTIONS: KEYBOARD selects reboot matrix
    11                          
    12                          CheckReboot
    13                          		!IF KEYBOARD=8 {
    14                          			LDY #15				; ROW=15
    15                          		} ELSE {
    16  ef23 a009               			LDY #9				; ROW=9
    17                          		}
    18                          CheckLoop
    19  ef25 8c10e8             		STY PIA1_Port_A 			; Keyboard row select
    20  ef28 ad12e8             		LDA PIA1_Port_B				; Keyboard col - keypressed
    21  ef2b d937ef             		CMP RebootCodes,Y
    22  ef2e d006               		BNE CheckOut				; Exit if no match
    23  ef30 88                 		DEY					; ROW=ROW-1
    24  ef31 10f2               		BPL CheckLoop				; Get more if not <0
    25                          
    26                          		!IF UPET=1 {
    27  ef33 4c41ef             			JMP RebootUPet
    28                          		} ELSE {
    29                          			JMP ($FFFC)			; All keys match, so reset!
    30                          		}
    31                          
    32  ef36 60                 CheckOut	RTS
    33                          
    34                          ;-------------- Reboot Code Table
    35                          ;
    36                          ; Note: Rows are entered in reverse order compared to the keyboard matrix
    37                          ; IMPORTANT!: Be aware of keyboard "ghosting", which means pressing multiple keys
    38                          ; can sometimes cause other keys to appear pressed.
    39                          
    40                          RebootCodes
    41                          ;		----------------- Normal/Graphic Keyboard: @-SHIFT-SHIFT-DEL
    42                          !if (KEYBOARD=0) OR (KEYBOARD=5) OR (KEYBOARD=9) {
    43                          		!byte %11111111	; ROW 9 - No keys
    44                          		!byte %01111111	; ROW 8 - <DEL>
    45                          		!byte %11111111	; ROW 7 - No keys
    46                          		!byte %11111111	; ROW 6 - No keys
    47                          		!byte %11111111	; ROW 5 - No keys
    48                          		!byte %11111111	; ROW 4 - No keys
    49                          		!byte %11111111	; ROW 3 - No keys
    50                          		!byte %11111111	; ROW 2 - No keys
    51                          		!byte %11011100	; ROW 1 - @ + Both Shifts
    52                          		!byte %11111111	; ROW 0 - No keys
    53                          }
    54                          
    55                          ;		----------------- Business Keyboard: ESC-SHIFT-SHIFT-DEL
    56                          !if (KEYBOARD=1) OR (KEYBOARD=4) OR (KEYBOARD=6) OR (KEYBOARD=7) {
    57  ef37 ff                 		!byte %11111111	; ROW 9
    58  ef38 ff                 		!byte %11111111	; ROW 8
    59  ef39 be                 		!byte %10111110	; ROW 7 - (ghost), ESC
    60  ef3a ff                 		!byte %11111111	; ROW 6
    61  ef3b 7f                 		!byte %01111111	; ROW 5 - DEL
    62  ef3c ff                 		!byte %11111111	; ROW 4
    63  ef3d be                 		!byte %10111110	; ROW 3 - SHIFT, SHIFT
    64  ef3e ff                 		!byte %11111111	; ROW 2
    65  ef3f ff                 		!byte %11111111	; ROW 1
    66  ef40 ff                 		!byte %11111111	; ROW 0
    67                          }
    68                          
    69                          ;		----------------- DIN Keyboard: ESC-SHIFT-SHIFT-DEL
    70                          !if KEYBOARD=2 { 
    71                          		!byte %11011111	; ROW 9 - DEL
    72                          		!byte %11111111	; ROW 8
    73                          		!byte %10111110	; ROW 7 - (ghost), ESC
    74                          		!byte %11111111	; ROW 6
    75                          		!byte %11111111	; ROW 5
    76                          		!byte %11111111	; ROW 4
    77                          		!byte %10111110	; ROW 3 - SHIFT, SHIFT
    78                          		!byte %11111111	; ROW 2
    79                          		!byte %11111111	; ROW 1
    80                          		!byte %11111111	; ROW 0
    81                          }
    82                          
    83                          ;		--------------- C64 Keyboard: CTRL-SHIFT-SHIFT-DEL
    84                          !if KEYBOARD=3 { 
    85                          		!byte %01111111	; ROW 9 - DEL
    86                          		!byte %11111111	; ROW 8
    87                          		!byte %11111110	; ROW 7 - CTRL
    88                          		!byte %11111101	; ROW 6 - SHIFT
    89                          		!byte %10111111	; ROW 5 - SHIFT
    90                          		!byte %11111111	; ROW 4
    91                          		!byte %11111111	; ROW 3
    92                          		!byte %11111111	; ROW 2
    93                          		!byte %11111111	; ROW 1 - row not connected
    94                          		!byte %11111111	; ROW 0 - row not connected
    95                          }
    96                          
    97                          ;		--------------- B modified Keyboard: ESC-SHIFT-SHIFT-DEL
    98                          !if KEYBOARD=4 { 
    99                          		!byte %11111111	; ROW 9
   100                          		!byte %11111111	; ROW 8
   101                          		!byte %11111111	; ROW 7
   102                          		!byte %11111111	; ROW 6
   103                          		!byte %11111111	; ROW 5
   104                          		!byte %11111111	; ROW 4
   105                          		!byte %10101110	; ROW 3 - SHIFT, (ghost), SHIFT
   106                          		!byte %11111111	; ROW 2
   107                          		!byte %11111111	; ROW 1
   108                          		!byte %10101110	; ROW 0 - (ghost), DEL, ESC
   109                          }
   110                          
   111                          ;		--------------- CBM-II Keyboard (16 ROWS): ?
   112                          ;		Note: The CBM-II keyboard is 16x6. Two columns are not connected
   113                          ;		TODO: Development is in progress; wiring is TBD
   114                          !if KEYBOARD=8 { 
   115                          		!byte %11111111	; ROW 15
   116                          		!byte %11111111	; ROW 14
   117                          		!byte %11111111	; ROW 13
   118                          		!byte %11111111	; ROW 12
   119                          		!byte %11111111	; ROW 11
   120                          		!byte %11111111	; ROW 10
   121                          		!byte %11111111	; ROW 9
   122                          		!byte %11111111	; ROW 8
   123                          		!byte %11111111	; ROW 7
   124                          		!byte %11111111	; ROW 6
   125                          		!byte %11111111	; ROW 5
   126                          		!byte %11111111	; ROW 4
   127                          		!byte %11111111	; ROW 3
   128                          		!byte %11111111	; ROW 2
   129                          		!byte %11111111	; ROW 1
   130                          		!byte %11111111	; ROW 0
   131                          }

; ******** Source: editrom.asm
   117                          }			; Keyboard Reset Code
   118                          	!IF BACKARROW = 2 { !SOURCE "editbarrow.asm" }			; Back Arrow "hack" Code
   119                          	!IF EXECUDESK > 0 { !SOURCE "execudesk.asm" }			; Execudesk Code

; ******** Source: upet.asm
     1                          ; PET/CBM EDIT ROM - Micro-PET Extensions (C)2021 Andre Fachat
     2                          ; ================
     3                          ; Editor-ROM extensions for the Ultra-PET/Micro-PET:
     4                          ; 
     5                          ; Currently only a hook into the Soft Reboot is used, to get to the Micro-PET
     6                          ; Boot screen, where the actual type of PET can be selected.
     7                          ;
     8                          ; Some future extensions could be graphics options menu, or a speed selector
     9                          
    10                          !IF KEYRESET=1 {
    11                          
    12                          SPEED=$e803
    13                          LOW32K=$e802
    14                          MEMMAP=$e801
    15                          VCTRL=$e800
    16                          
    17                          SPI=$e808
    18                          SPIDATA=$e809
    19                          
    20                          FLASH=$01
    21                          
    22                          RebootUPet
    23  ef41 78                 		sei
    24                          
    25  ef42 a900               		lda #0
    26  ef44 8d03e8             		sta SPEED	; 1MHz to make sure not to overrun SPI
    27  ef47 8d01e8             		sta MEMMAP	; all RAM (writeable)
    28  ef4a 8d00e8             		sta VCTRL
    29  ef4d 8d02e8             		sta LOW32K	
    30                          
    31  ef50 a901               		lda #FLASH
    32  ef52 8d08e8             		sta SPI
    33  ef55 a903               		lda #3		; SPI Flash READ
    34  ef57 8d09e8             		sta SPIDATA
    35  ef5a a900               		lda #0
    36  ef5c 8d09e8             		sta SPIDATA
    37  ef5f 8d09e8             		sta SPIDATA
    38  ef62 8d09e8             		sta SPIDATA
    39  ef65 ad09e8             		lda SPIDATA	; trigger first byte
    40                          
    41  ef68 a200               		ldx #0
    42  ef6a ad09e8             loop		lda SPIDATA
    43  ef6d 9d00ff             		sta $ff00,x
    44  ef70 e8                 		inx
    45  ef71 d0f7               		bne loop
    46                          
    47  ef73 8e08e8             		stx SPI
    48                          
    49  ef76 6cfcff             		JMP ($FFFC)
    50                          
    51                          
    52                          }
    53                          
    54                          

; ******** Source: editrom.asm
   120                          }			; UltraPET Code (Andre Fachat)
   121                          
   122                          ;=========================================================================================================
   123                          ; INFOSTRING
   124                          ;=========================================================================================================
   125                          ; Used to include project INFO into the code area so it can be used with ESC-BackArrow
   126                          ; This string can be included twice:
   127                          ;   1. In hidden I/O area from $E800-E8FF.
   128                          ;   2. Here at end of EXT binary (which needs a label so it can be printed).
   129                          
   130                          INFOSTRING
   131                          	!IF INFO > 0      { !SOURCE "info.asm" }
   132                          
   133                          ;=========================================================================================================
   134                          ; END OF CODE
   135                          ;=========================================================================================================
   136                          ; We finish off by padding the binary to exactly 4K bytes.
   137                          ;#########################################################################################################
   138                          
   139  ef79 ffffffffffffffff...	!IF OPTROM=0 { !FILL $F000-*,$FF }				; PAD to 4K ######################
   140                          
   141                          }
   142                          ; This is the end of the check for EXT code.
