
; ******** Source: editrom.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; This is the main Assembler file. It brings in the USER-DEFINED variables and acts on them to build a
     4                          ; functional EDITOR ROM.
     5                          ;
     6                          ;---------------------- Get User Variables and validate some settings, and set output file
     7                          

; ******** Source: edit.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; A Project to create replacement EDIT ROMs for the PET/CBM line of computers.
     4                          ; Use MAKE.BAT to assemble (ACME.EXE must be in same folder or in search path).
     5                          ; For complete documentation see:
     6                          ;      http://www.6502.org/users/sjgray/projects/editrom/index.html
     7                          ;
     8                          ; Edit these VARIABLES to choose which features are included.
     9                          ;
    10                          ; The most important is the CODEBASE variable. It determines which main code to use, which will determine
    11                          ; how many features are available:
    12                          ;
    13                          ;   CODEBASE=0 for 40-column (30xx/40xx) machines with Universal Dynamic Motherboard
    14                          ;   CODEBASE=1 for 80-column (80xx/82xx/9000) machines with Universal Dynamic Motherboard
    15                          ;   CODEBASE=2 for 80-column (8296/8296D) machines (mostly DIN keyboard versions)
    16                          ;
    17                          ; Both CODEBASE=0 and CODEBASE=2 have limited customizability. You may change screen/keyboard and a few other options.
    18                          ; CODEBASE=1 is designed for maximum customizability (for example COLOURPET, ESC codes, Soft40, SS40, Wedge etc).
    19                          ;
    20                          ; If there are no options listed it means that support has not been added yet!
    21                          ;
    22                          ; NOTE!: Not all combinations may be valid!!
    23                          ; NOTE!: SuperPET's require a special adapter to use EPROMS and have compatibility issues with 4K edit roms (see web page)
    24                          ;
    25                          ;----------------------------------------------------------------------------------------------------------------------------
    26                          ; The following DATE and COMMENT strings will be placed in the IO area (if used).
    27                          ; Take care that comments do not overflow into code space!
    28                          
    29                          !macro DATE      { !pet "2022-04-10" }
    30                          !macro COMMENT   { !pet "sjg-editrom" }
    31                          
    32                          ;----------------------------------------------------------------------------------------------------------------------------
    33                          
    34                          ; VARIABLE	  FEATURE			VALID OPTIONS			NOTES / FUTURE OPTIONS
    35                          ;---------	  -------			-------------			----------------------
    36                          CODEBASE  = 0   ; Code Base			0=4000, 1=8000, 2=8296		
    37                          OPTROM    = 0   ; Location of EXT code		0=Ext Edit ($E800-EFFF), 1=$9000, 2=$A000 (note: code could also extend past end of 1)
    38                          
    39                          KEYSCAN   = 0   ; Keyboard Scanner		0=Normal,1=Business,2=DIN
    40                          KEYBOARD  = 0	; Keyboard type:		0=N-QWERTY,1=B-QWERTY,2=DIN,3=C64,4=B-SJG,5=N-SJG,6=B-QWERTZ,7=B-AZERTY,8=CBM-II (req hw mod)
    41                          REFRESH   = 1	; Screen refresh:		0=Euro,1=N.America,2=PAL,3=NTSC,4=9",82=8296D#1,83=8296D#2,90=32-line,91=35-line,92=90x35,99=Custom
    42                          REPEATOPT = 1	; Key Repeat Option		0=No (Always ON), 1=Yes
    43                          COLUMNS   = 40	; Screen Width			40,80,90,32 columns		Special cases 32 or 90.
    44                          ROWS      = 25  ; Screen Height			25,35,16 rows			Special cases 16 or 35.
    45                          HERTZ     = 60	; Line Frequency (Clock):	50=Euro,60=N.America
    46                          IRQFIX    = 0   ; Fix Jiffy Clock		0=No, 1=Yes			Still needs investigating.
    47                          BOOTCASE  = 1	; Initial Screen Mode		0=Text/Lower, 1=Upper/Graphics
    48                          
    49                          ESCCODES  = 0	; Add ESC codes? 		0=No, 1=Yes			Enable when using COLOURPET or SS40.
    50                          
    51                          AUTORUN   = 0   ; Set for BANNER and/or WEDGE	0=No, 1=Yes			Enable if you use EITHER banner and/or wedge.
    52                          BYPASS    = 0   ; Check for key to bypass 	0=No, 1=Yes			Hold key on ROW9 to bypass.
    53                          BANNER    = 16  ; Custom Banner (power on msg)	0=No, N=Banner# (1-18,98,99)    Valid when AUTORUN=1. Refer to docs or source. 99=custom message
    54                          WEDGE     = 0	; DOS Wedge			0=No, 1=Yes			Valid when AUTORUN=1.
    55                          WEDGEMSG  = 0	; Show wedge message?		0=No, 1=Yes			Valid when AUTORUN=1 and WEDGE>0.
    56                          AUTOBOOT  = 1	; AutoBOOT first file on disk	0=No, 1=Yes			Valid when AUTORUN=1.
    57                          
    58                          SOFT40    = 0	; 40 columns on 8032s?		0=No, 1=Yes			Do NOT enable SOFT40 and SS40 at the same time!
    59                          SS40      = 0	; Software Switchable Soft-40	0=No, 1=Yes			Also set ESCCODES=1, or BACKARROW>0 and BACKACTION=1.
    60                          SS40MODE  = 40  ; Initial SS40 Mode		40 or 80 columns		Valid when SS40=1.
    61                          HARD4080  = 0   ; Hardware 40/80 Board          0=No, 1=Yes			Valid when SS40=1.
    62                          VIDSWITCH = 0   ; Video Switching               0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+9 to Switch CRTC parameters.
    63                          
    64                          COLOURPET = 0	; ColourPET additions?		0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+? to set Colour (unless VIDSWITCH=1).
    65                          COLOURVER = 0	; ColourPET Hardware Version	0=Beta,1=Release		0=ColourRAM at $8400, 1=$8800 (use for VICE).
    66                          COLOURMODE= 0	; ColourPET Hardware Type	0=Digital, 1=Analog
    67                          DEFAULTFG = 5	; ColourPET Foreground colour   0 to 15 RGBI 			0=black,1=DkGry,2=DkBlu ,3=LtBlu, 4=DkGrn, 5=Grn,   6=DkCyan,7=LtCyan
    68                          DEFAULTBG = 0	; ColourPET Background colour   0 to 15 RGBI 			8=DKred,9=LTred,10=DKpur,11=LTpur,12=DkYel,13=LtYel,14=LtGry,15=White
    69                          DEFAULTBO = 0   ; ColourPET Border colour       0 to 15 RGBI
    70                          BYPASSFG  = 5   ; ColourPET Bypass FG     	0 to 15 RGBI			Colours when AUTOSTART is bypassed.
    71                          BYPASSBG  = 0   ; ColourPET Bypass BG     	0 to 15 RGBI
    72                          
    73                          MOT6845   = 0   ; Is CRTC a Motorola6845?       0=No, 1=Yes			Probably 0=No for compatibility.
    74                          REBOOT    = 0	; Add keyboard reboot? 		0=No, 1=Yes
    75                          EXECUDESK = 0	; Add Execudesk Menu?		0=No, 1=Yes, 2=Yes/OPTROM	Note: Requires BOOT to TEXT mode!
    76                          SILENT    = 0	; Disable BELL/CHIME		0=Normal, 1=Disabled
    77                          CRUNCH    = 0   ; Remove unneeded code?		0=No, 1=Yes			Removes NOPs, filler, and unreachable code.
    78                          BACKARROW = 0   ; Backarrow Hack code?		0=NO, 1=Yes, 2=Yes EXT		Where to put the Action Code. Note: B keyboard scanner only.
    79                          BACKACTION= 0   ; Backarrow Action		0=Text/Graphic, 2=40/80		Which Action?
    80                          INFO      = 0   ; Add project info to code area 0=NO, 1=Yes,2=Yes+FONT		INFO=2 shows character set at top of screen
    81                          BUGFIX    = 0   ; Correct Known bugs		0=No, 1=Yes			
    82                          ;
    83                          DEBUG 	  = 0	; Add debugging			0=No, 1=Yes
    84                          
    85                          ;----------------------------------------------------------------------------------------------------------------------------------------
    86                          ; To generate Edit ROMs that are Byte-exact matches to actual Commodore ROMS set the
    87                          ; following options (If an option is not listed assume "0"):
    88                          ;
    89                          ; 901498-01 -> CODEBASE=0,KEYSCAN=0,KEYBOARD=0,COLUMNS=40,REFRESH=1,BOOTCASE=1,HERTZ=50,REPEATOPT=0   [edit-4-40-n-50Hz]
    90                          ; 901499-01 -> CODEBASE=0,KEYSCAN=0,KEYBOARD=0,COLUMNS=40,REFRESH=1,BOOTCASE=1,HERTZ=60,REPEATOPT=0   [edit-4-40-n-60Hz]
    91                          ; 901474-04 -> CODEBASE=1,KEYSCAN=1,KEYBOARD=1,COLUMNS=80,REFRESH=0,BOOTCASE=0,HERTZ=50,REPEATOPT=1   [edit-4-80-b-50Hz]
    92                          ; 324243-04 -> CODEBASE=2,KEYSCAN=2,KEYBOARD=2,COLUMNS=80,REFRESH=0,BOOTCASE=0,HERTZ=50,REPEATOPT=0   [edit-4-80-din-50Hz] (8296D)
    93                          ;
    94                          ; Additional Edit ROMs will be listed as they are tested and verified as byte-exact.
    95                          ;----------------------------------------------------------------------------------------------------------------------------------------

; ******** Source: editrom.asm
     8                          						; Include USER-DEFINED variables
     9                          !IF COLOURPET>0 { ESCCODES=1 }						; Make sure ESC Codes is ON if SS40 or COLOURPET is enabled
    10                          !IF SS40=1      { SOFT40=0 }                         			; Make sure SOFT40 is OFF if SS40 is enabled
    11                          !IF COLOURPET=0 { !TO "editrom.bin",plain }				; Generic output file with no load address
    12                          !IF COLOURPET>0 { !TO "cpetrom.bin",plain }				; ColourPET output file with no load address
    13                          
    14                          ;---------------------- These are the symbol definitions for PET/CBM memory and IO chips
    15                          

; ******** Source: memzeropage.asm
     1                          ; PET/CBM EDIT ROM - Standard Zero Page locations/variables/storage
     2                          ; ================
     3                          ; Descriptions are from Butterfield's memory maps from Transactor
     4                          
     5                          ;		--------------- Common Usage (All Codebases)
     6                          
     7                          Basic_USR 	= $00		; USR Jump
     8                          USRADD 		= $01		; USR Jump
     9                          CHARAC 		= $03		; Search Character
    10                          ENDCHR 		= $04		; Scan between Quotes Flag
    11                          COUNT 		= $05		; Input buffer pointer. # of subscripts
    12                          DIMFLG 		= $06		; Default DIM flag
    13                          VALTYP 		= $07		; Type: FF=string, 00=numeric
    14                          INTFLG 		= $08		; Type: 80=integer, 00=floating point
    15                          GARBFL 		= $09		; Flag: DATA scan; List quote; memory
    16                          SUBFLG 		= $0a		; Flag: Subscript; FNX flag
    17                          INPFLG 		= $0b		; 0=input; $40=GET; $98=READ
    18                          TANSGN 		= $0c		; ATN sign/Comparison Evaluation Flag
    19                          DS_1 		= $0d		; Disk Status DS$ descriptor
    20                          DS_2 		= $0e		; Disk Status DS$ descriptor
    21                          DS_3 		= $0f		; Disk Status DS$ descriptor
    22                          IOPMPT 		= $10		; Current i/o device for prompt suppress
    23                          LINNUM 		= $11		; Integer value (for SYS, GOTO etc)
    24                          TEMPPT 		= $13		; Pointers for descriptor stack
    25                          LASTPT 		= $14	 	
    26                          TEMPST 		= $16		; Descriptor stack (temp strings)
    27                          INDEXA 		= $1f		; Utility pointer area
    28                          INDEXB 		= $21
    29                          FAC3EX 		= $23		; Product area for multiplication
    30                          FAC3M1 		= $24		
    31                          FAC3M2 		= $25
    32                          FAC3M3 		= $26
    33                          FAC3M4 		= $27
    34                          TXTTAB 		= $28		; Pointer: Start of BASIC
    35                          VARTAB 		= $2a		; Pointer: Start of Variables
    36                          ARYTAB 		= $2c		; Pointer: Start of Arrays
    37                          STREND 		= $2e		; Pointer: End of Arrays
    38                          FRETOP 		= $30		; Pointer: String Storage (moving down)
    39                          FRESPC 		= $32		; Pointer: Utility string
    40                          MEMSIZ 		= $34		; Pointer: Limit of Memory
    41                          CURLIN 		= $36		; Current BASIC line number
    42                          OLDLIN 		= $38		; Previous BASIC line number
    43                          OLDTXT 		= $3a		; Pointer: BASIC statement for CONT
    44                          DATLIN 		= $3c		; Current DATA line number
    45                          DATPTR 		= $3e		; Current DATA address
    46                          INPPTR 		= $40		; Input Vector
    47                          VARNAM 		= $42		; Current variable name
    48                          VARPTR 		= $44		; Current variable address
    49                          FORPNT 		= $46		; Variable pointer for FOR/NEXT
    50                          YSAVE 		= $48		; Y-Save; op-save; BASIC pointer save
    51                          ACCSYM 		= $4a		; Comparison symbol accumulator
    52                          FUNCPT 		= $4b		; Misc work area/pointers
    53                          DESCPT 		= $4d
    54                          GARBSS 		= $50
    55                          JUMPER 		= $51		; Jump vector for functions
    56                          FUNJMP 		= $52		
    57                          FACTPA 		= $54		; Misc numeric work area
    58                          TMPPTA 		= $55
    59                          TMPPTB 		= $57
    60                          FACTPB 		= $59
    61                          TMPVA2 		= $5a
    62                          TMPPTC 		= $5c
    63                          FAC1EX 		= $5e		; Accum#1: Exponent
    64                          FAC1M1 		= $5f		; Accum#1: Mantissa
    65                          FAC1M2 		= $60
    66                          FAC1M3 		= $61
    67                          FAC1M4 		= $62
    68                          FAC1SI 		= $63		; Accum#1: Sign
    69                          SGNFLG 		= $64		; Series evaluation constant pointer
    70                          BITS 		= $65		; Accum#1: hi-order (overflow)
    71                          FAC2EX 		= $66	
    72                          FAC2M1 		= $67
    73                          FAC2M2 		= $68
    74                          FAC2M3 		= $69
    75                          FAC2M4 		= $6a
    76                          FAC2SI 		= $6b
    77                          STRPTR		= $6c
    78                          FAC1M5 		= $6d
    79                          TMPPTD 		= $6e
    80                          CHRGET 		= $70
    81                          CHRGETX		= $73		; UNUSED
    82                          CHRGOT 		= $76
    83                          TXTPTR 		= $77
    84                          ISNUM 		= $7d
    85                          RNDX 		= $88
    86                          JIFFY_CLOCK 	= $8d
    87                          CINV 		= $90
    88                          CBINV 		= $92
    89                          NMINV 		= $94
    90                          STATUS		= $96
    91                          KEYPRESSED	= $97		; Which KEY down - $FF = no key
    92                          KEYFLAGS	= $98		; SHIFT KEY - $01 = Pressed
    93                          JIFFY_CORR	= $99		; Correction for JIFFY clock
    94                          STKEY		= $9b		; Keyswitch PIA - Stop and Reverse Flag
    95                          SVXT		= $9c		; Timing Constant for TAPE
    96                          VERCK		= $9d		; Tape mode: 0=Load, 1=Verify
    97                          CharsInBuffer 	= $9e		; Number of characters in keyboard buffer
    98                          ReverseFlag 	= $9f		; Screen Reverse Flag
    99                          C3PO 		= $a0		; IEEE Output - $FF=character pending
   100                          LastInputCol	= $a1		; End of Line for input pointer
   101                          InputRow 	= $a3		; Cursor Log: Row
   102                          InputCol 	= $a4		; Cursor Log: Column
   103                          BSOUR 		= $a5		; IEEE output buffer
   104                          Key_Image	= $a6		; Key Image
   105                          Blink		= $a7		; Cursor Flag: 0=Flash Cursor
   106                          BLNCT		= $a8		; Cursor Timing Countdown
   107                          CursorChar	= $a9		; Character Under Cursor
   108                          BlinkPhase	= $aa		; Cursor in Blink phase
   109                          SYNO		= $ab		; EOT (End of Tape) received from Tape
   110                          CRSW		= $ac		; Input from Screen or Keyboard
   111                          TEMPX		= $ad		; Save X
   112                          LDTND		= $ae		; How many open files?
   113                          DFLTN		= $af		; Input Device - Normally 0
   114                          DFLTO		= $b0		; Output CMD Device - Normally 3
   115                          PRTY		= $b1		; TAPE character parity
   116                          DPSW		= $b2		; Byte Received FLAG
   117                          SAVELA		= $b3		; Logical Address temporary save
   118                          TIMCMD		= $b4		; Tape buffer character / MLM command
   119                          MONCNT		= $b5		; Filename pointer / MLM Flag, counter
   120                          TMPZB7		= $b7
   121                          TMPZB9		= $b9
   122                          TMPZBA		= $ba
   123                          BUFPNT		= $bb
   124                          INBIT		= $bd
   125                          BITCI		= $be
   126                          RINONE		= $bf
   127                          PTR1		= $c0
   128                          PTR2		= $c1
   129                          RIDATA		= $c2
   130                          RIPRTY		= $c3
   131                          ScrPtr		= $c4		; Pointer to character screen line
   132                          CursorCol	= $c6		; Position of cursor on above line
   133                          SAL		= $c7		; Utility Pointer - Tape or Scrolling
   134                          EAL		= $c9		; Tape end address / End of current program
   135                          CMP0		= $cb		; Tape Timing Constants (ColourPET pointer to colour line)
   136                          BLNSW		= $cc		; Tape Timing Constants (ColourPET pointer to colour line)
   137                          QuoteMode	= $cd		; 0=Direct Cursor, else programmed
   138                          BITTS		= $ce		; Tape read timer 1 enabled
   139                          EOT		= $cf		; EOT recieved from TAPE
   140                          READERR		= $d0		; Read Character error
   141                          FNLEN		= $d1		; Number of characters in filename
   142                          LA		= $d2		; Current file Logical Address
   143                          SA		= $d3		; Current file Secondary Address
   144                          FA		= $d4		; Current file Device number
   145                          RightMargin	= $d5		; Window RIGHT margin
   146                          TAPE1		= $d6		; Pointer: Start of Tape Buffer
   147                          CursorRow	= $d8		; Line where cursor lives
   148                          DATAX		= $d9		; Last Key / Checksum / Misc
   149                          FNADR		= $da		; Filename pointer
   150                          INSRT		= $dc		; Number of inserts outstanding
   151                          ROPRTY		= $dd		; Write shift word / read character in
   152                          FSBLK		= $de		; Tape blocks remaining to write
   153                          MYCH		= $df		; Serial word buffer
   154                          CAS1		= $f9		; Cassette #1 status
   155                          CAS2		= $fa		; Cassette #2 status
   156                          STAL		= $fb		; Tape start address/ MLM
   157                          MEMUSS		= $fd		; MLM / DOS pointer / Misc
   158                          
   159                          ;		---------------- 40-Column Only Usage (Codebase 0)
   160                          ;		*** Currently, We cannot use ESC codes with CODEBASE 0 because this area is used for line linking!
   161                          ;		*** The line link table uses 24 bytes, 1 for each line (line 25 can never be linked)
   162                          ;		*** The line link table also holds the HI byte for the 40-col screen line table. It may be possible to
   163                          ;		*** Move the HI byte back into ROM like in the 80 column code, then pack the 24 bytes down to 3 using
   164                          ;		*** BITS instead. This would free 21 bytes that could be used for 80-column plus enhanced features.
   165                          ;		*** However, the code to handle BIT-based line linking would be more complicated and take more code.
   166                          
   167                          !IF CODEBASE=0 {
   168                          LineLinkTable   = $e0		; 40-Col Line Link Table (to $F8)
   169                          
   170                          } ELSE {
   171                          
   172                          ;		---------------- 80-Column Only Usage (Codebase 1 or 2)
   173                          ;		*** These are the normal 80-column screen editor locations. Since we have 80 columns there is no need
   174                          ;		*** for a line-link table, therefor we can use this for enhanced 80-column functions (windowing).
   175                          
   176                          TopMargin	= $e0		; Window TOP line
   177                          BotMargin	= $e1		; Window BOTTOM line
   178                          LeftMargin	= $e2		; Window LEFT margin
   179                          XMAX		= $e3		; Maximum characters in input buffer
   180                          RPTFLG		= $e4		; Key REPEAT flag
   181                          KOUNT		= $e5		; Repeat countdown
   182                          DELAY		= $e6		; New key marker
   183                          CHIME		= $e7		; Chime Time
   184                          HOMECT		= $e8		; Home count
   185                          SCRIV		= $e9		; Screen Input Vector  (E9/EA)
   186                          SCROV		= $eb		; Screen Output Vector (EB/EC)
   187                          ; $ED-F7 			; UNUSED
   188                          JIFFY6DIV5	= $f8		; TI clock adjust (speed by 6/5)
   189                          }
   190                          
   191                          ;		---------------- These are Customized Locations
   192                          ;      		*** With Codebase 1 the area from $ED-$F7 are unused
   193                          ;      		*** With Codebase 0 the area is part of the LineWrap Table
   194                          ;		***  ( can these move to TAPE BUFFER#1? - will conflict with tape and some ML programs)
   195                          
   196                          ; If ESC codes are not active but Backarrow Hack is set to Toggle 40/80
   197                          ; then define Screen Width Location
   198                          !IF (ESCCODES = 0) AND (BACKARROW>0) AND (BACKACTION=1) {
   199                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   200                          }
   201                          
   202                          !IF ESCCODES = 1 {
   203                            !IF CODEBASE = 0 {
   204                          
   205                          ;               *** CODEBASE 0 must avoid line-link table! We will use TAPE#2 buffer (which DOS uses)
   206                          
   207                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   208                          LASTCHAR	= $0382		; Last Key Pressed - used to remember ESC key
   209                          BELLMODE	= $0383		; 0=Disable, 1=Enable BELL/CHIME
   210                          EUROFLAG        = $0384		; 0=ASCII, 1=DIN
   211                          SCN4080BOARD    = $0385		; Flag for Hardware 40/80 Column Switcher board
   212                          
   213                          MYZP            = $00           ; LO General ZP pointer (we don't have a good location for this!)
   214                          ;                 $01           ; HI                    (we will take over the USR jump vector which is rarely used)
   215                          
   216                            } ELSE {
   217                          ;               *** CODEBASE 1/2 can safely go where line-link table would be
   218                          
   219                          SCNWIDTH	= $f0		; Screen Mode (40 or 80) for SS40
   220                          LASTCHAR	= $f1		; Last Key Pressed - used to remember ESC key
   221                          BELLMODE	= $f2		; 0=Disable, 1=Enable BELL/CHIME
   222                          EUROFLAG        = $f3		; 0=ASCII, 1=DIN
   223                          SCN4080BOARD    = $f4		; Flag for Hardware 40/80 Column Switcher board
   224                          MYZP            = $f5           ; LO General ZP pointer
   225                          ;                 $f6           ; HI
   226                          ;                 $f7		; not used
   227                          
   228                            }
   229                          }

; ******** Source: editrom.asm
    16                          					; $0000-00FF	Zero Page 

; ******** Source: memlow.asm
     1                          ; PET/CBM EDIT ROM - Standard Low Mem locations/variables/storage
     2                          ; ================
     3                          
     4                          ;------------------------ Common Usage
     5                          
     6                          STACK 			= $0100	;Processor Stack
     7                          BUF 			= $0200	;MLM work area; Input buffer
     8                          LAT 			= $0251	;File Logical Address Table
     9                          FAT 			= $025b	;File Device Number Table
    10                          SAT 			= $0265	;File Secondary Address Table
    11                          KEYD 			= $026f	;Keyboard input buffer
    12                          TAPEB1 			= $027a	;TAPE#1 input buffer
    13                          TAPEB2                  = $033a ;TAPE#2 input buffer (to $03F9)
    14                          
    15                          ;------------------------ Shared with TAPE#2 buffer
    16                          
    17                          NextTab 		= $033a	;DOS character pointer
    18                          DOS_Drive_1 		= $033b	;DOS drive 1 flag
    19                          DOS_Drive_2 		= $033c	;DOS drive 2 flag
    20                          DOS_Length 		= $033d	;DOS length/write flag
    21                          DOS_Syntax 		= $033e	;DOS syntax flags
    22                          DOS_Id 			= $033f	;DOS disk ID
    23                          DOS_Command_Length 	= $0341	;DOS command string count
    24                          DOS_Filename 		= $0342	;DOS filename buffer
    25                          DOS_Command_Buffer 	= $0353	;DOS command string buffer (to $0380)
    26                          ;			  $0381-03e8 ???
    27                          
    28                          ;------------------------ 40-Column Usage
    29                          
    30                          !IF CODEBASE=0 {
    31                          DELAY			= $03e9 ;Repeat Key countdown delay 	(40 col)
    32                          KOUNT			= $03ea ;Delay between repeats 		(40 col)
    33                          XMAX			= $03eb ;Max keyboard buffer size 	(40 col)
    34                          CHIME			= $03ec ;Chime Time 0=off 		(40 col)
    35                          JIFFY6DIV5		= $03ed ;TI clock adjust (speed by 6/5) (40 col) Was: TIADJ
    36                          RPTFLG			= $03ee ;Repeat Flag                    (40 col)
    37                          TABS			= $03ef ;TAB-STOP table			(40 col)
    38                          }
    39                          
    40                          ;------------------------ Common Usage
    41                          
    42                          TABS_SET 		= $03ee	;80 column TAB stop table ($03ee-03f7) ** Should this be $03ef ???? **
    43                          ;			  $03f8 ???
    44                          ; 			  $03f9 ???
    45                          
    46                          ;------------------------ End of TAPE#2 bufer
    47                          
    48                          Reset_Vector 		= $03fa	;Monitor extension vector
    49                          Reset_Param 		= $03fc	;IEEE timeout defeat; $FF=disable
    50                          ;			  $03fd ???
    51                          ;			  $03fe ???
    52                          ;			  $03ff ???
    53                          
    54                          ;------------------------ BASIC Program Area
    55                          

; ******** Source: editrom.asm
    17                          						; $0100-03FC	Low Memory

; ******** Source: memchips.asm
     1                          ; PET/CBM EDIT ROM - Standard Chip Registers and Screen Ram
     2                          ; ================
     3                          
     4                          ;--------------------------- Screen RAM $8000-$8FFF
     5                          
     6                          SCREEN_RAM = $8000					; 40 Col = $8000-83FF, 80 Col = $8000-87FF
     7                          
     8                          !IF COLUMNS = 80 { KBD_MATRIX = $87d0 }			; Used with Extended DIN ROM keyboard scanning routine
     9                          !IF COLUMNS = 40 { KBD_MATRIX = $83e8 }			; First unused byte in SCREEN_RAM
    10                          
    11                          
    12                          ;--------------------------- PIA #1 - 6520 Chip
    13                          
    14                          PIA1_Port_A = $e810					; Keyboard ROW select
    15                          PIA1_Cont_A = $e811
    16                          PIA1_Port_B = $e812					; Keyboard COLUMN read
    17                          PIA1_Cont_B = $e813
    18                          
    19                          ;--------------------------- PIA #2 - 6520 Chip
    20                          
    21                          PIA2_Port_A = $e820
    22                          PIA2_Cont_A = $e821
    23                          PIA2_Port_B = $e822
    24                          PIA2_Cont_B = $e823
    25                          
    26                          ;--------------------------- VIA - 6522 Chip
    27                          
    28                          VIA_Port_B = $e840					; IEEE, Screen Retrace, Cassette motor
    29                          VIA_Port_A = $e841					; Parallel Port (User Port) with handshaking
    30                          VIA_DDR_B = $e842					; Data Direction Register for PORT B
    31                          VIA_DDR_A = $e843					; Data Direction Register for PORT A
    32                          VIA_Timer_1_Lo = $e844				; Timer 1
    33                          VIA_Timer_1_Hi = $e845
    34                          VIA_Timer_1_Latch_Lo = $e846			; Timer 1 Latch
    35                          VIA_Timer_1_Latch_Hi = $e847
    36                          VIA_Timer_2_Lo = $e848				; Timer 2
    37                          VIA_Timer_2_Hi = $e849
    38                          VIA_Shift = $e84a					; Shift Register
    39                          VIA_ACR = $e84b						; Shift Register Control
    40                          VIA_PCR = $e84c
    41                          VIA_IFR = $e84d
    42                          VIA_IER = $e84e
    43                          VIA_Port_A_no_HS = $e84f				; Parallel Port, no handshaking
    44                          
    45                          ;--------------------------- CTRC - 6545 CRT Controller
    46                          
    47                          CRT_Address = $e880					; Register Select Port
    48                          CRT_Status = $e881					; Register DATA port

; ******** Source: editrom.asm
    18                          						; $E800-E8FF	Chips

; ******** Source: memkernal.asm
     1                          ; PET/CBM EDIT ROM - Standard Kernal calls
     2                          ; ================
     3                          ; These are calls from the EDIT ROM to KERNAL entry points
     4                          ;---------------------------------------------------------
     5                          ; Non-vectored calls (direct - caution: could change if KERNAL is changed)
     6                          
     7                          CHKSTOP 	= $F335 ; Check for STOP key
     8                          
     9                          ;----------------- Standard KERNAL Entry Points
    10                          
    11                          BASIN		= $ffcf ; read char from input channel -> A
    12                          BSOUT		= $ffd2	; Write A to stdout
    13                          GETIN		= $ffe4	; read char from keyboard buffer -> A
    14                          UDTIME		= $FFEA	; Update Time
    15                          
    16                          ACPTR		= $f1c0	; input IEEE -> A
    17                          CHKIN		= $ffc6	; stdin from logical file # in X
    18                          CIOUT		= $f19e	; output A -> IEEE
    19                          CKOUT		= $ffc9	; stdout to logical file # in X
    20                          CLOSE		= $f2e0	; close file
    21                          CLSEI		= $f72f	; close and unlisten
    22                          CLRCH		= $ffcc	; reset stdio to defaults
    23                          LISTN		= $f0d5	; send LISTEN
    24                          LOAD		= $f408	; LOAD
    25                          LOADOP		= $f356	; LOAD without pointer change
    26                          FILENOTFOUND	= $f425	; FILE NOT FOUND, return to BASIC
    27                          OPEN		= $f563	; open file
    28                          OPENI		= $f4a5	; open file on IEEE device
    29                          SCNT		= $f2c1	; prepare SETT for logical file A
    30                          SECND		= $f143	; send secondary address A
    31                          SETT		= $f2cd	; set LF,DN,SA from table
    32                          TALK		= $f0d2	; send TALK
    33                          TWAIT		= $f92b	; 
    34                          UNLSN		= $f1b9	; send UNLISTEN
    35                          UNTLK		= $f1ae	; send UNTALK
    36                          RESET		= $fd16	; basic cold start
    37                          STOPEQ		= $f335	; set Z flag if stop key pressed
    38                          STOPR		= $ffe1	; return to basic if stop key pressed

; ******** Source: editrom.asm
    19                          						; $F000-FFFF	Kernal

; ******** Source: membasic4.asm
     1                          ; --------- BASIC 4 ROM ROUTINES
     2                          
     3                          SCROUT	= $e202	; output A to screen
     4                          RDOA	= $d754	; read hex address -> $FB,$FC
     5                          RDOB	= $d763	; read hex byte -> A
     6                          CLRSCR	= $e015	; clear screen
     7                          CRLF	= $d534	; move cursor to next line
     8                          FPOUT	= $cf8d	; write floating point
     9                          INTOUT	= $cf83	; write integer 0-65535 X=LSB,A=MSB
    10                          SCROLD	= $e021	; scroll down
    11                          SCROLU	= $e024	; scroll up
    12                          SPAC2	= $d52e	; write 2 spaces
    13                          SPACE	= $d531	; write space
    14                          STROUTZ	= $bb1d	; A=LSB, Y=MSB			; BASIC4 STROUTZ is broken!
    15                          STROUT	= $bb24	; X=len, STRADR=ptr
    16                          WROA	= $d717	; write hex address
    17                          HEXOUT	= $d722	; write A as hex
    18                          WROB	= $d731	; write hex byte
    19                          WRTWO	= $d731	; write XA to screen
    20                          
    21                          ADRFP	= $cd7f	; uint LSB=$5f, MSB=$60 -> FAC1
    22                          ASCII	= $d73a	; hex digit -> ascii hex digit
    23                          FPINT	= $cdd1	; FAC1 -> uint $61=MSB, $62=LSB
    24                          FPSTR	= $cf93	; fp -> str $0100..NUL
    25                          HEXIT	= $d78d	; hex ascii digit A -> hex digit A
    26                          INTFP	= $c4bc	; int Y=LSB, A=MSB -> FAC1
    27                          STRFP	= $c8eb	; string -> fp
    28                          RDINT	= $b8f6	; read basic text -> LINNUM
    29                          
    30                          ABS	= $cd8e	; FAC1 = ABS(FAC1)
    31                          ADD	= $c9a0	; FAC1 = FAC1 + FAC2
    32                          ATN	= $d32C	; FAC1 = ATN(FAC1)
    33                          COS	= $d282	; FAC1 = COS(FAC1)
    34                          DIV	= $cc48	; FAC1 = FAC2 / FAC1
    35                          EXP	= $d184	; FAC1 = EXP(FAC1)
    36                          FAC12	= $cd45	; FAC2 := FAC1
    37                          
    38                          READY	= $b3ff	; basic warm start
    39                          NEWSTT	= $b74a	; set up next statement for execution
    40                          MOVBLK	= $b357	; move block
    41                          
    42                          LINKPRG	= $b4b6	; rechain lines
    43                          RSTXCLR	= $b5e9	; reset TXTPTR and perform CLR
    44                          STXTPT	= $b622	; reset TXTPTR
    45                          CLR	= $b5f0	; perform CLR
    46                          SCRTCH	= $b5d4	; perform NEW
    47                          
    48                          MAINS	= $b40f	; MAIN's return addr on stack for CHRGET routine

; ******** Source: editrom.asm
    20                          						; BASIC
    21                          
    22                          !IF COLOURPET=1 { !SOURCE "colourpet.asm" }				; Non-standard memory usage (may change without notice)
    23                          
    24                          ;---------------------- Debug stuff
    25                          
    26                          DBLINE = SCREEN_RAM + 24 * COLUMNS					; Calculate bottom line of screen for debug
    27                          
    28                          ;---------------------- Standard 2K Edit ROM code here
    29                          ; $E000-E7FF are for normal Edit ROMS
    30                          

; ******** Source: editrom40.asm
     1                          ; PET/CBM EDIT ROM  - Commented and Adapted by Steve J. Gray, Nov 17, 2015
     2                          ; ================    sjgray@rogers.com
     3                          ; 
     4                          ; ***** THIS IS 40-COLUMN CODEBASE *****
     5                          ;
     6                          ; This is reverse engineered source code for the EDIT ROMs of the Commodore PET/CBM computers.
     7                          ; The "901499-01" ROM was used as a base. Addresses inside [brackets] are original code addresses. 
     8                          ; Much of this disassembly comes from the 80-column source code, my own disassembly, and combined with
     9                          ; Edilbert Kirk's 80-column disassembly.
    10                          ;
    11                          ; The EDIT ROM is mapped from $E000 to EFFF (4K). Many Early versions used only $E000-E7FF (2K).
    12                          ; Note that the area from $E800 to $E8FF (256 bytes) is not available due to the I/O chips in this range.
    13                          ;
    14                          ; PET/CBM machines come in several flavours:
    15                          ;    * 40 or 80 column screens
    16                          ;    * Normal, Business, or DIN keyboards
    17                          ;    * 50 or 60 Hz power frequency
    18                          ;    * Specialized options, ie: Execudesk
    19                          ;
    20                          ; In addition I am adapting the EDIT roms to these additional options:
    21                          ;    * ColourPET - My own project to add colour capabilities
    22                          ;    * Alternate Keyboards - Such as the VIC/C64 keyboard
    23                          ;    * Soft40 - Simulate a 40 column screen on 80 column hardware
    24                          ;    * Soft-switchable SOFT40
    25                          ;    * Soft-switchable real 40/80 columns (requires hardware mod)
    26                          ;    * Extended screen editor - C128 or CBM-II compatible ESC sequences
    27                          ;    * Keyboard soft-reset (kinda like CTRL-ALT-DEL on PC's)
    28                          ;    * Autoboot from default drive
    29                          ;    * DOS Wedge
    30                          ;
    31                          ; See EDIT.ASM for assemble OPTIONS!
    32                          ; Use MAKE.BAT to assemble a binary file with the current options.
    33                          ;
    34                          ;-----------------------------------------------------------------------------------------------
    35                          * = $e000	; Normal start address for EDIT ROM is $E000
    36                          
    37                          ;*********************************************************************************************************
    38                          ;** Edit ROM Jump Table [E000]
    39                          ;** Note: Not all KERNAL and BASIC calls go through this table.
    40                          ;** There are FIVE hard-coded entry points: $E0A7, $E116, $E202, $E442, $E600
    41                          ;*********************************************************************************************************
    42                          
    43  e000 4c36e0             EDITOR		JMP RESET_EDITOR	; [E000] Main Initialization (called from Kernal power up reset at $FD16) 
    44  e003 4ca7e0             		JMP GETKEY		; [E003] Get Character From Keyboard Buffer	(FIXED ENTRY POINT. Must not move!)
    45  e006 4c16e1             		JMP INPUT_CHARACTER	; [E006] Input From Screen or Keyboard		(FIXED ENTRY POINT. Must not move!)
    46  e009 4c02e2             		JMP CHROUT_SCREEN	; [E009] Output to Screen			(FIXED ENTRY POINT. Must not move!)
    47  e00c 4c42e4             		JMP IRQ_MAIN		; [E00C] Main IRQ Handler			(FIXED ENTRY POINT. Must not move!)
    48  e00f 4c55e4             		JMP IRQ_NORMAL		; [E00F] Actual IRQ (clock, keyboard scan)
    49  e012 4c00e6             		JMP IRQ_END		; [E012] Return From Interrupt			(FIXED ENTRY POINT. Must not move!)
    50  e015 4c42e0             		JMP WIN_CLEAR		; [E015] Clear Window
    51  e018 4c0fe6             		JMP CRT_SET_TEXT	; [E018] Set CRTC to TEXT mode
    52  e01b 4c17e6             		JMP CRT_SET_GRAPHICS	; [E01B] Set CRTC to GRAPHICS mode
    53  e01e 4c1de6             		JMP CRT_PROGRAM		; [E01E] Program CRTC (Table pointer in A/X, chr set in Y)
    54  e021 4ceae6             		JMP WIN_SCROLL_DN	; [E021] Scroll DOWN
    55  e024 4cd1e3             		JMP WIN_SCROLL_UP	; [E024] Scroll UP
    56  e027 4cbfe4             		JMP SCAN_KEYBOARD	; [E027] Scan Keyboard
    57  e02a 4c57e6             		JMP BEEP		; [E02A] Ring BELL/CHIME
    58  e02d 4c98e0             		JMP NOTSUPPORTED 	; [E02D] Set REPEAT Flag   (Function Not supported)
    59  e030 4c98e0             		JMP NOTSUPPORTED 	; [E030] Set Window Top    (Function Not supported)
    60  e033 4c98e0             		JMP NOTSUPPORTED 	; [E033] Set Window Bottom (Function Not supported)
    61                          
    62                          ;*********************************************************************************************************
    63                          ;** RESET_EDITOR  [E04B]  (Called from Jump Table)
    64                          ;** Initializes Editor, then sets the screen to TEXT or GRAPHICS mode.
    65                          ;*********************************************************************************************************
    66                          
    67                          RESET_EDITOR
    68                          !IF COLOURPET=0 {
    69  e036 2083e6             		JSR INIT_EDITOR
    70                          } ELSE {
    71                          		JSR ColourPET_Init			; Initialize ColourPET settings
    72                          }
    73                          
    74                          !IF BOOTCASE=0 { JSR CRT_SET_TEXT }			; Set Screen to TEXT mode
    75  e039 2017e6             !IF BOOTCASE=1 { JSR CRT_SET_GRAPHICS }			; Set Screen to GRAPHICS mode
    76                          
    77  e03c 2054e6             		JSR BEEP_BEEP 				; Ring BELL
    78  e03f 2054e6             		JSR BEEP_BEEP 				; Ring BELL
    79                          
    80                          ;*********************************************************************************************************
    81                          ;** WIN_CLEAR  [$E042]  (Called from Jump Table) 
    82                          ;** This routine clears the screen. Since there is no windowing it clears EVERY byte in the screen memory,
    83                          ;** including non-visible bytes. It also calculates the HI byte of the start of each screen line and
    84                          ;** stores it into the Screen Line Link table. LO bytes are stored in ROM at $E798. These addresses are
    85                          ;** used for printing to the screen. Entries with HI BIT CLEARED are linked to the line above it.
    86                          ;*********************************************************************************************************
    87                          ; This routine will go here in it's usual spot for fixed 40/80 column option, however,
    88                          ; if we are using SS40 then the routine will not fit so we must relocate it!
    89                          

; ******** Source: editrom40cls.asm
     1                          ;*********************************************************************************************************
     2                          ;** WIN_CLEAR  [$E042]  (Called from Jump Table) 
     3                          ;** This routine clears the screen. Since there is no windowing it clears EVERY byte in the screen memory,
     4                          ;** including non-visible bytes. It also calculates the HI byte of the start of each screen line and
     5                          ;** stores it into the Screen Line Link table. LO bytes are stored in ROM at $E798. These addresses are
     6                          ;** used for printing to the screen. Entries with HI BIT CLEARED are linked to the line above it.
     7                          ;*********************************************************************************************************
     8                          ; This routine will be placed at $E042 for normal options, however when Soft40 is enabled ("SS40"=1) it
     9                          ; is too big to fit and will cause a "too much code generated" error so it must be relocated.
    10                          ; There should be enough space just before $E600.
    11                          
    12                          FULL_SCREEN 	; This codebase does not have windowing, so this label is needed for Soft40 compatibility
    13                          
    14  e042 a218               WIN_CLEAR	LDX #ROWS-1				; Start at the bottom of the screen (25-1=24 lines)
    15                          
    16                          !IF SS40=0 {						; If switchable then we need to check screen mode to properly set address of last line
    17                          
    18  e044 a9c0                !IF COLUMNS=40 {LDA #$C0				; $83C0 = First character on last line of 40-col screen
    19  e046 a083               		 LDY #$83}
    20                           !IF COLUMNS=80 {LDA #$80				; $8780 = First character on last line of 80-col screen
    21                          		 LDY #$87}
    22                          } ELSE {						; Yes, so check current mode
    23                          		LDA SCNWIDTH				; Get current Soft Screen Width
    24                          		CMP #40					; Is it >40 column mode?
    25                          		BCS WC80				; Yes, skip
    26                          		LDA #$C0				; $83C0 = First character on last line of 40-col screen
    27                          		LDY #$83	
    28                          		BCC WCLOOP				; Skip over 80 col
    29                          WC80		LDA #$80				; $8780 = First character on last line of 80-col screen
    30                          		LDY #$87	
    31                          }
    32                          
    33  e048 94e0               WCLOOP		STY LineLinkTable,X			; LOOP[      Save HI byte of screen address to table
    34  e04a 38                 		SEC					;
    35                          
    36  e04b e928               !IF SS40=0 {	SBC #COLUMNS				;   Subtract Hard-coded Screen Width (one physical line)
    37                              } ELSE {    SBC SCNWIDTH }				;   Subtract Soft Screen Width
    38                          
    39  e04d b001               		BCS WCSKIP1				;   did we move past page? No, skip ahead
    40  e04f 88                 		DEY					;   Yes, next page
    41  e050 ca                 WCSKIP1		DEX					;   Previous line
    42  e051 10f5               		BPL WCLOOP				; ] Loop up for more
    43                          
    44  e053 84c5               		STY ScrPtr+1				; Store in screen pointer HI
    45  e055 e8                 		INX					; X=0
    46  e056 869f               		STX ReverseFlag    			; Clear RVS Flag
    47  e058 86c4               		STX ScrPtr    				; Store 0 to screen Pointer LO (pointer should point to $8000 - HOME position)
    48                          
    49                          ;[$E05A]	------------------------------- Clear all Screen Memory 
    50                          
    51  e05a a920               		LDA #$20				; <SPACE>
    52  e05c 9d0080             CLS_LOOP	STA SCREEN_RAM,X			; LOOP[  Screen RAM page 1
    53  e05f 9d0081             		STA SCREEN_RAM+$100,X			;        Screen RAM page 2
    54  e062 9d0082             		STA SCREEN_RAM+$200,X			;        Screen RAM page 3
    55  e065 9d0083             		STA SCREEN_RAM+$300,X			;        Screen RAM page 4 (this also clears non-visible)
    56                          
    57                          !IF (COLUMNS >40) OR (SS40=1) {
    58                          		STA SCREEN_RAM+$400,X			;        Screen RAM page 5
    59                          		STA SCREEN_RAM+$500,X			;        Screen RAM page 6
    60                          		STA SCREEN_RAM+$600,X			;        Screen RAM page 7
    61                          		STA SCREEN_RAM+$700,X			;        Screen RAM page 8
    62                          }
    63  e068 e8                 		INX					;   Next position
    64  e069 d0f1               		BNE CLS_LOOP				; ] Loop back for more

; ******** Source: editrom40.asm
    90                          }
    91                          
    92                          ;*********************************************************************************************************
    93                          ;** CURSOR_HOME  [$E06B]
    94                          ;** Moves the cursor to the HOME position
    95                          ;*********************************************************************************************************
    96                          
    97  e06b a000               CURSOR_HOME	LDY #$00				; ROW=0, COL=0
    98  e06d 84c6               		STY CursorCol   			; Store to Cursor Column on Current Line
    99  e06f 84d8               		STY CursorRow   			; Store to Current Cursor Physical Line Number
   100                          
   101                          ;*********************************************************************************************************
   102                          ;** CURSOR_LM  [$E071]
   103                          ;** Moves Cursor to start of line. Sets Screen-line pointer, and determines if line is linked 
   104                          ;*********************************************************************************************************
   105                          
   106  e071 a6d8               CURSOR_LM	LDX CursorRow   			; Get Current Cursor Physical Line Number
   107  e073 b5e0               		LDA LineLinkTable,X			; Get Current Line's Screen Line Link entry
   108  e075 0980               		ORA #$80				; Make sure HIGH bit is set
   109  e077 85c5               		STA ScrPtr+1				; Store in Current Screen Line Address HI
   110  e079 bd98e7             		LDA Line_Addr_Lo,X			; Get the LO byte from table in ROM
   111  e07c 85c4               		STA ScrPtr    				; Store to Current Screen Line Address LO
   112                          
   113  e07e a927               !IF SS40=0 {	LDA #COLUMNS-1 				; Fixed Screen Width -1
   114                          } ELSE {        LDA SCNWIDTH				; Soft Screen Width
   115                          		SBC #1 }				; -1
   116                          
   117  e080 85d5               		STA RightMargin   			; Set Physical Screen Line Length
   118  e082 e018               		CPX #ROWS-1				; Line 24? (0-24) last line cannot be linked
   119  e084 f008               		BEQ CLM_SKIP1				; Yes, skip ahead
   120  e086 b5e1               		LDA LineLinkTable+1,X 			; Check next line in screen line link table
   121  e088 3004               		BMI CLM_SKIP1  				; Is HIGH bit set? (negative value) Yes, so NO linked line
   122  e08a a94f               		LDA #79					; No, then line is linked (two screen lines)
   123  e08c 85d5               		STA RightMargin   			; Store in Physical Screen Line Length
   124  e08e a5c6               CLM_SKIP1 	LDA CursorCol   			; Cursor Column on Current Line
   125                          
   126  e090 c928               !IF SS40=0 {    CMP #COLUMNS				; Is it greater than Fixed Screen Width?
   127                          } ELSE {	CMP SCNWIDTH }				; Is it greater than SCNWIDTH?
   128                          
   129  e092 9004               		BCC NOTSUPPORTED			; No, skip
   130                          
   131  e094 e928               !IF SS40=0 {    SBC #COLUMNS				; Yes, subtract Fixed Screen Width
   132                          } ELSE {	SBC SCNWIDTH }				; Yes, subtract SCNWIDTH
   133                          
   134  e096 85c6               		STA CursorCol   			; Cursor Column on Current Line
   135                          
   136                          ;-------------- Unsupported Functions Jump Here [$E098]
   137                          
   138  e098 60                 NOTSUPPORTED	RTS
   139                          
   140                          ;*********************************************************************************************************
   141                          ;** GETKEY [E0A7] (Called from Jump Table)
   142                          ;** Get a KEY from keyboard buffer. Reads a character from 'KEYD' then shifts remaining buffer characters
   143                          ;** If there is NO key it will return $FF.
   144                          ;*********************************************************************************************************
   145  e099 aaaaaaaaaaaaaaaa...!FILL $e0a7-*,$aa ; FIXED ENTRY POINT! This must not move! (approx 14 bytes filler for std rom)
   146                          ;#########################################################################################################
   147                          
   148                          GETKEY
   149                          !if DEBUG=1 { INC DBLINE+2,X }				; DEBUG
   150  e0a7 ac6f02             		LDY KEYD				; Get key at start of buffer
   151  e0aa a200               		LDX #0 					; Start at 0
   152                          
   153  e0ac bd7002             GK_LOOP		LDA KEYD+1,X				; LOOP[ START - Now shift the next keys in line
   154  e0af 9d6f02             		STA KEYD,X				;   to the front of the buffer
   155                          !if DEBUG=1 { STA DBLINE+10,X }				;   DEBUG - update screen
   156  e0b2 e8                 		INX
   157  e0b3 e49e               		CPX CharsInBuffer			;   Num Chars in Keyboard Buffer
   158  e0b5 d0f5               		BNE GK_LOOP				; ] Done? No, loop for another
   159                          
   160  e0b7 c69e               		DEC CharsInBuffer			; Reduce Num Chars in Keyboard Buffer
   161                          
   162  e0b9 98                 		TYA					; Put the character in Accumulator
   163                          !if DEBUG=1 { STA DBLINE+3 }				; DEBUG - 4th chr on bottom line
   164  e0ba 58                 		CLI
   165  e0bb 60                 		RTS
   166                          
   167                          ;*********************************************************************************************************
   168                          ;** GETLINE [E0BC]
   169                          ;** The PET is usually in this routine, waiting for keypresses and printing them or acting on them.
   170                          ;** This routine continually loops until a <RETURN> is pressed. When <RETURN> is pressed then the line
   171                          ;** where the cursor is, is processed. If the <RUN> key is pressed then the string is stuffed into
   172                          ;** the keyboard buffer (overwriting whatever might be there)
   173                          ;*********************************************************************************************************
   174                          
   175  e0bc 203ce6             GETLINE		JSR ChrOutMarginBeep			; Check for BELL at near-end of line 
   176                          GETLINE2	!IF DEBUG=1 { INC DBLINE+5 }		; DEBUG - 6th chr on bottom line
   177  e0bf a59e               		LDA CharsInBuffer			; Are there any keys waiting?
   178  e0c1 85a7               		STA Blink 				; 0 chars -> blink cursor
   179  e0c3 f0fa               		BEQ GETLINE2 				; loop until char in buffer
   180                          
   181                          !if DEBUG=1 { INC DBLINE+6 }				; DEBUG - 7th chr on bottom line
   182                          
   183                          ;		--------------------------------------- Got a character, so process it
   184                          
   185  e0c5 78                 		SEI
   186  e0c6 a5aa               		LDA BlinkPhase				; Flag: Last Cursor Blink On/Off
   187  e0c8 f009               		BEQ GL_1				; no, so no need to restore original character
   188  e0ca a5a9               		LDA CursorChar				; Character Under Cursor
   189  e0cc a000               		LDY #0
   190  e0ce 84aa               		STY BlinkPhase				; Reset blinkphase
   191  e0d0 2006e6             		JSR RESTORE_CHR_AT_CRSR			; Restore OLD character under cursor before processing new one
   192  e0d3 20a7e0             GL_1		JSR GETKEY				; Get Character From Keyboard Buffer
   193  e0d6 c983               		CMP #$83				; Is it the <RUN> key?
   194  e0d8 d010               		BNE GL_3				; No, skip ahead
   195                          
   196                          ;		--------------------------------------- Stuff the <RUN> string to the keyboard buffer
   197                          
   198  e0da 78                 		SEI
   199  e0db a209               		LDX #9					; Length of string
   200  e0dd 869e               		STX CharsInBuffer			; Set number of characters in buffer
   201  e0df bd8ee7             GL_2		LDA RUN_STRING-1,X			; LOOP[    Normally:  dL"*<RETURN>run<RETURN>
   202  e0e2 9d6e02             		STA KEYD-1,X				;   stuff it into the buffer
   203  e0e5 ca                 		DEX					;   next character
   204  e0e6 d0f7               		BNE GL_2				; ] Loop back for more
   205  e0e8 f0d5               		BEQ GETLINE2
   206                          
   207                          ;		--------------- Check for RETURN key
   208                          
   209  e0ea c90d               GL_3		CMP #$0D 				; Check if <RETURN> pressed
   210  e0ec d0ce               		BNE GETLINE				; if not go get more keys
   211                          
   212                          ;*********************************************************************************************************
   213                          ;** PARSE_LINE [E0EE]
   214                          ;** When the <RETURN> key is pressed the line where the cursor lives is executed
   215                          ;*********************************************************************************************************
   216                          
   217                          		!IF DEBUG=1 { INC DBLINE+7 }		; DEBUG - 8th chr on bottom line
   218                          
   219  e0ee a4d5               		LDY RightMargin   			; Physical Screen Line Length
   220  e0f0 84ac               		STY CRSW   				; Flag: INPUT or GET from Keyboard
   221                          
   222  e0f2 b1c4               PL_LOOP		LDA (ScrPtr),Y				; LOOP[  Pointer: Current Screen Line Address
   223  e0f4 c920               		CMP #$20				;   Is it <SPACE>?
   224  e0f6 d003               		BNE PL_SKIP				;   No, found end of line, skip ahead
   225  e0f8 88                 		DEY					;   Yes, move to previous position
   226  e0f9 d0f7               		BNE PL_LOOP				; ] At start of line? No, loop back for more
   227                          
   228                          ;		------------------------ Process line
   229                          
   230  e0fb c8                 PL_SKIP 	INY					; last checked was not space so move one forward
   231  e0fc 84a1               		STY LastInputCol			; Pointer: End of Logical Line for INPUT
   232  e0fe a000               		LDY #0					; COL=0, QUOTEMODE=0		[40]
   233  e100 84c6               		STY CursorCol   			; Cursor Column on Current Line	[40]
   234  e102 84cd               		STY QuoteMode   			; Flag: Editor in Quote Mode
   235  e104 a5a3               		LDA InputRow   				; Cursor Y-X Pos. at Start of INPUT
   236  e106 3016               		BMI Screen_Input
   237  e108 c5d8               		CMP CursorRow   			; Current Cursor Physical Line Number
   238  e10a d012               		BNE Screen_Input
   239  e10c a5a4               		LDA InputCol
   240  e10e 85c6               		STA CursorCol   			; Cursor Column on Current Line
   241  e110 c5a1               		CMP LastInputCol   			; Pointer: End of Logical Line for INPUT
   242  e112 900a               		BCC Screen_Input
   243  e114 b02b               		BCS Screen_Input2
   244                          
   245                          ;*********************************************************************************************************
   246                          ;** INPUT_CHARACTER [E116] (Called from Jump Table) - FIXED ENTRY POINT!!!!!
   247                          ;** Push X and Y to stack then call Input a Character routine via pointer
   248                          ;*********************************************************************************************************
   249                          !FILL $e116-*,$aa ; FIXED ENTRY POINT! This must not move!
   250                          ;#########################################################################################################
   251                          
   252  e116 98                 INPUT_CHARACTER	TYA
   253  e117 48                 		PHA
   254  e118 8a                 		TXA
   255  e119 48                 		PHA
   256                          
   257                          ; 		On 80-column core there is a JMP(SCRIV) here
   258                          ;		where SCRIV normally points to DEFAULT_SCREEN_VECTOR
   259                          
   260                          ;*********************************************************************************************************
   261                          ;** DEFAULT_SCREEN_VECTOR [E11D]
   262                          ;** Input from Screen Routine
   263                          ;*********************************************************************************************************
   264                          
   265                          DEFAULT_SCREEN_VECTOR
   266  e11a a5ac               		LDA CRSW   				; Get Input Flag: INPUT or GET from Keyboard
   267  e11c f0a1               		BEQ GETLINE2				; Is it ZERO? Yes, Loop back up to Input from Keyboard
   268                          
   269                          ;		--------------------------------------- Screen Input [$E11E]
   270                          
   271  e11e a4c6               Screen_Input	LDY CursorCol				; Cursor Column on Current Line
   272  e120 b1c4               		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   273  e122 85d9               		STA DATAX				; Current Character to Print
   274  e124 293f               		AND #$3F
   275  e126 06d9               		ASL DATAX				; Current Character to Print
   276  e128 24d9               		BIT DATAX				; Current Character to Print
   277  e12a 1002               		BPL SI_SKIP1
   278  e12c 0980               		ORA #$80
   279  e12e 9004               SI_SKIP1	BCC SI_SKIP2
   280  e130 a6cd               		LDX QuoteMode				; Flag: Editor in Quote Mode
   281  e132 d004               		BNE SI_SKIP3
   282  e134 7002               SI_SKIP2	BVS SI_SKIP3
   283  e136 0940               		ORA #$40				; '@'
   284  e138 e6c6               SI_SKIP3	INC CursorCol				; Cursor Column on Current Line
   285  e13a 2067e1             		JSR CheckQuote				; Switch Quote flag
   286  e13d c4a1               		CPY LastInputCol			; Pointer: End of Logical Line for INPUT
   287  e13f d017               		BNE SI_SKIP6
   288                          
   289                          ;		--------------------------------------- Screen Input 2 [$E141]
   290                          
   291  e141 a900               Screen_Input2	LDA #$00
   292  e143 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   293  e145 a90d               		LDA #$0D				; <RETURN>
   294  e147 a6af               		LDX DFLTN				; Default Input Device (0)
   295  e149 e003               		CPX #$03				; 3=SCREEN
   296  e14b f006               		BEQ SI_SKIP4
   297  e14d a6b0               		LDX DFLTO				; Default Output (CMD) Device (3)
   298  e14f e003               		CPX #$03	
   299  e151 f003               		BEQ SI_SKIP5
   300  e153 2002e2             SI_SKIP4	JSR CHROUT_SCREEN			; Output to screen
   301  e156 a90d               SI_SKIP5	LDA #$0D				; <RETURN>
   302  e158 85d9               SI_SKIP6 	STA DATAX  				; Current Character to Print
   303  e15a 68                 		PLA
   304  e15b aa                 		TAX
   305  e15c 68                 		PLA
   306  e15d a8                 		TAY
   307  e15e a5d9               		LDA DATAX  				; Current Character to Print
   308  e160 c9de               		CMP #$DE				; Is it <PI>?
   309  e162 d002               		BNE SI_DONE				; No, skip ahead
   310  e164 a9ff               		LDA #$FF				; Yes, substitute screen code
   311  e166 60                 SI_DONE		RTS
   312                          
   313                          ;[$E167]	--------------------------------------- Check Quote Mode 
   314                          
   315  e167 c922               CheckQuote	CMP #$22 				; Is it <QUOTE>?
   316  e169 d008               		BNE CQ_DONE				; No, skip ahead
   317  e16b a5cd               		LDA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   318  e16d 4901               		EOR #1					; toggle the BIT
   319  e16f 85cd               		STA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   320  e171 a922               		LDA #$22 				; reload the <QUOTE>
   321  e173 60                 CQ_DONE		RTS
   322                          
   323                          ;*********************************************************************************************************
   324                          ;** CHAR_TO_SCREEN [E177]
   325                          ;** This puts a character in 'A' to screen. The character is handled differently according to the entry
   326                          ;** point. For example, when QUOTE mode is ON special characters are printed in RVS using CHAR_TO_SCREEN3
   327                          ;*********************************************************************************************************
   328                          
   329  e174 0940               CHAR_TO_SCREEN	ORA #$40 				; '@'
   330  e176 a69f               CHAR_TO_SCREEN2 LDX ReverseFlag    			; Flag: Print Reverse Chars. -1=Yes
   331  e178 f002               		BEQ CTS_SKIP1
   332                          
   333  e17a 0980               CHAR_TO_SCREEN3	ORA #$80				; Toggle the upper bit (reverse characters)
   334  e17c a6dc               CTS_SKIP1	LDX INSRT  				; Flag: Insert Mode, >0 = # INSTs
   335  e17e f002               		BEQ CTS_SKIP2
   336  e180 c6dc               		DEC INSRT  				; Flag: Insert Mode, >0 = # INSTs
   337                          CTS_SKIP2
   338                          
   339                          !IF COLOURPET=0 {
   340  e182 2006e6             		JSR RESTORE_CHR_AT_CRSR
   341                          } ELSE {
   342                          		JSR Put_ColourChar_at_Cursor		; Put character AND Colour on screen
   343                          }
   344  e185 e6c6               		INC CursorCol   			; Move to next column
   345  e187 a4d5               		LDY RightMargin   			; Physical Screen Line Length (Right Margin)
   346  e189 c4c6               		CPY CursorCol   			; Get Column again. Compare to Right Margin
   347  e18b b019               		BCS IRQ_EPILOG				; Is it past the Margin? Yes, we are done
   348                          ;               ----------------------------------------
   349  e18d a6d8               		LDX CursorRow   			; Current Cursor Physical Line Number
   350  e18f c04f               		CPY #79					; 79=maximum line length (2 physical lines in 40-column mode) minus 1
   351                          							; ##### We need to decide if we will link two 80 column lines????
   352  e191 d00c               		BNE CTS_SKIP3				; It's not at the end, so skip ahead
   353  e193 20b3e1             		JSR LINKLINES				; If it is then link them! 
   354  e196 20a9e3             		JSR CURSOR_DOWN				; Move Cursor to next line
   355  e199 a900               		LDA #$00				; First character on line
   356  e19b 85c6               		STA CursorCol   			; Cursor Column on Current Line
   357  e19d f007               		BEQ IRQ_EPILOG
   358                          
   359  e19f e018               CTS_SKIP3	CPX #ROWS-1				; Last screen line?
   360  e1a1 d01b               		BNE LINKLINES2				; No, continue
   361  e1a3 20c4e1             		JSR SCROLL_UP				; Yes, Scroll screen and adjust line link
   362                          
   363                          ;*********************************************************************************************************
   364                          ;** IRQ_EPILOG [E1A6]
   365                          ;** IRQ Completion. We jump here when printing is complete.
   366                          ;*********************************************************************************************************
   367                          
   368  e1a6 68                 IRQ_EPILOG	PLA
   369  e1a7 a8                 		TAY
   370  e1a8 a5dc               		LDA INSRT				; Flag: Insert Mode, >0 = # INSTs
   371  e1aa f002               		BEQ IRQE_1
   372  e1ac 46cd               		LSR QuoteMode				; Flag: Editor in Quote Mode
   373  e1ae 68                 IRQE_1		PLA
   374  e1af aa                 		TAX
   375  e1b0 68                 		PLA
   376  e1b1 58                 		CLI					; Allow interrupts again
   377  e1b2 60                 		RTS
   378                          
   379                          ;*********************************************************************************************************
   380                          ;** LINKLINES [$E1B3]
   381                          ;** These routines are for 40-column line linking. When a character is printed to
   382                          ;** column 40 the line and the line below are linked into one 80-character logical line.
   383                          ;** IE: two physical lines become one logical line.
   384                          ;** X hold physical line#. Checks ROW to make sure it's not on last line.
   385                          ;*********************************************************************************************************
   386                          
   387  e1b3 e017               LINKLINES	CPX #ROWS-2				; Check if we are below ROW 23?
   388  e1b5 b006               		BCS LL_SKIP				; Yes, skip out
   389  e1b7 b5e2               		LDA LineLinkTable+2,X			; No, safe to link the next line to this one
   390  e1b9 0980               		ORA #$80				; Link the line by SETTING the upper bit
   391  e1bb 95e2               		STA LineLinkTable+2,X			; Store to line link table
   392  e1bd 60                 LL_SKIP		RTS
   393                          
   394                          ;		--------------------------------------- Convert 40 character line to 80 characters [$E1BE]
   395                          
   396  e1be 20cde1             LINKLINES2	JSR LINKLINES3				; Adjust line link and move to start of line
   397  e1c1 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   398                          
   399                          ;		--------------------------------------- Scroll screen UP [$E1C4]
   400                          
   401  e1c4 20d1e3             SCROLL_UP	JSR WIN_SCROLL_UP			; Scroll Screen Up
   402  e1c7 c6a3               		DEC InputRow   				; Cursor Y-X Pos. at Start of INPUT
   403  e1c9 c6d8               		DEC CursorRow   			; Current Cursor Physical Line Number
   404  e1cb a6d8               		LDX CursorRow   			; Current Cursor Physical Line Number
   405                          
   406                          ;		------------------------------- Adjust Line Link and Move to start of line [$E1CD]
   407                          
   408  e1cd 16e1               LINKLINES3	ASL LineLinkTable+1,X 			; Shift to lose HI BIT
   409  e1cf 56e1               		LSR LineLinkTable+1,X 			; HI BIT is now CLEARED
   410  e1d1 20b3e1             		JSR LINKLINES				; Set line link
   411  e1d4 a5c6               		LDA CursorCol   			; Get Cursor Column on Current Line
   412  e1d6 48                 		PHA					; Remember column
   413  e1d7 2071e0             		JSR CURSOR_LM				; Cursor to start of line
   414  e1da 68                 		PLA					; Restore column
   415  e1db 85c6               		STA CursorCol   			; Store Cursor Column on Current Line
   416  e1dd 60                 		RTS
   417                          
   418                          ;*********************************************************************************************************
   419                          ;** CURSOR_TO_EOPL [$E1DE]
   420                          ;** Back to previous line when actioning DEL or LEFT 
   421                          ;*********************************************************************************************************
   422                          
   423                          CURSOR_TO_EOPL
   424  e1de a027               !IF SS40=0 {	LDY #COLUMNS-1				; Hard-coded Screen Width-1 (ie: 39)
   425                          } ELSE {	LDY SCNWIDTH				; Soft Screen Width
   426                          		DEY }					; -1
   427                          
   428  e1e0 a6d8               		LDX CursorRow   			; Get Current Cursor Physical Line Number
   429  e1e2 d006               		BNE PL_SKIP1				; Is it Zero? No, ok to proceed, so skip ahead
   430  e1e4 86c6               		STX CursorCol   			; Yes, movement is invalid. Cursor Column on Current Line
   431  e1e6 68                 		PLA					; pull the character from the stack
   432  e1e7 68                 		PLA					; pull the character from the stack
   433  e1e8 d0bc               		BNE IRQ_EPILOG				; jump back up to finish up
   434                          
   435  e1ea b5df               PL_SKIP1	LDA LineLinkTable-1,X			; Get PREVIOUS line's Line Link value
   436  e1ec 3005               		BMI PL_SKIP2				; Is HI BIT SET? Yes, skip ahead
   437  e1ee ca                 		DEX					; No, it's ok to go back to previous line
   438  e1ef b5df               		LDA LineLinkTable-1,X			; Get PREVIOUS line's Line Link value
   439  e1f1 a04f               		LDY #COLUMNS*2-1			; Hard-coded Two Screen Lines - 1 (ie: 79)
   440                          
   441  e1f3 ca                 PL_SKIP2	DEX
   442  e1f4 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   443  e1f6 85c5               		STA ScrPtr+1				; Store to Current Screen Line Address pointer
   444  e1f8 bd98e7             		LDA Line_Addr_Lo,X			; Get LO byte from ROM table
   445  e1fb 85c4               		STA ScrPtr    				; Store to Current Screen Line Address pointer
   446  e1fd 84c6               		STY CursorCol   			; Store to Cursor Column on Current Line
   447  e1ff 84d5               		STY RightMargin   			; Store to Physical Screen Line Length
   448  e201 60                 		RTS
   449                          
   450                          ;*********************************************************************************************************
   451                          ;** CHROUT_SCREEN [E202] (Called from Jump Table)
   452                          ;** $E202 - FIXED ENTRY POINT! Some BASIC/KERNAL rouines bypass the Jump Table and jump directly here
   453                          ;** Output Character to Screen Dispatch 
   454                          ;*********************************************************************************************************
   455                          !FILL $e202-*,$aa ; FIXED ENTRY POINT! This must not move!
   456                          ;#########################################################################################################
   457                          
   458  e202 48                 CHROUT_SCREEN	PHA
   459  e203 85d9               		STA DATAX				; Current Character to Print
   460  e205 8a                 		TXA
   461  e206 48                 		PHA
   462  e207 98                 		TYA
   463  e208 48                 		PHA
   464                          ;							80-column machines have JMP(SCROV) here.
   465                          ;							where SCROV would normally point to 'CHROUT_NORMAL'
   466                          
   467                          ;*********************************************************************************************************
   468                          ;** CHROUT_NORMAL [E209]
   469                          ;** Output Character to Screen. Character to print must be in DATAX.
   470                          ;** On 80 column machines, SCROV vector would point here
   471                          ;*********************************************************************************************************
   472                          
   473  e209 a900               CHROUT_NORMAL	LDA #0
   474  e20b 85ac               		STA CRSW   				; Flag: INPUT or GET from Keyboard
   475  e20d a4c6               		LDY CursorCol   			; Cursor Column on Current Line
   476  e20f a5d9               		LDA DATAX  				; Current Character to Print
   477  e211 297f               		AND #$7F				; Mask off top bit (graphics characters)
   478                          
   479                          ;[PATCH]	--------------------------------------- Check for ESC Character
   480                          
   481                          
   482                          !IF ESCCODES=1 {
   483                          		JMP CheckESC				; Check for ESC as last Char, then ESC as current Char. If so, perform it.
   484                          ESC_DONE	STA LASTCHAR				; Save the character
   485                          
   486                          } ELSE {
   487  e213 c91b               		CMP #$1B				; <ESC>	key? **** Also SHIFT-ESC $9B (Conflicts with COLOUR CODE!)
   488  e215 d003               		BNE CHROUT_CHECK
   489  e217 4cc6e3             		JMP ESCAPE				; Cancel RVS/INS/QUOTE modes
   490                          }
   491                          ESC_DONE2
   492                          
   493                          ;[E21A]		--------------------------------------- Reload character and check HIGH BIT
   494                          
   495  e21a a5d9               CHROUT_CHECK	LDA DATAX  				; Current Character to Print
   496                          !IF COLOURPET=1 { JSR CheckColourCodes }		; Check table of color values @@@@@@@@@@@@@@@@ COLOURPET
   497  e21c 1003               		BPL CHROUT_LO				; Is top bit CLEAR? Yes, handle UNSHIFTED Character
   498  e21e 4cd5e2             		JMP CHROUT_HI				; No, Handle SHIFTED Character
   499                          
   500                          ;*********************************************************************************************************
   501                          ;** Character Output with HIGH BIT CLEAR [E224]
   502                          ;** This routine handles characters in the range 0 to 127.
   503                          ;** Checked: RETURN,DELETE,RVS,HOME,CRSR-RIGHT,CRSR-DOWN,ERASE-EOL,TEXT,BELL,TAB
   504                          ;*********************************************************************************************************
   505                          
   506                          ;		--------------------------------------- Check for RETURN
   507                          
   508  e221 c90d               CHROUT_LO	CMP #$0D				; Is it <RETURN>?
   509  e223 d003               		BNE COU_SKIP1				; No, skip ahead
   510  e225 4cbfe3             		JMP CURSOR_RETURN			; Yes, Handle <RETURN>
   511                          
   512                          ;		--------------------------------------- Check for Control Codes Range (0-31)
   513                          
   514  e228 c920               COU_SKIP1 	CMP #$20				; <SPACE>
   515  e22a 9008               		BCC COU_SKIP2				; No, it's 0-31
   516  e22c 293f               		AND #$3F				; Yes, Mask off HI BIT
   517  e22e 2067e1             		JSR CheckQuote				; Switch Quote flag if found
   518  e231 4c76e1             		JMP CHAR_TO_SCREEN2
   519                          
   520  e234 a6dc               COU_SKIP2	LDX INSRT  				; Flag: Insert Mode, >0 = # INSTs
   521  e236 f003               		BEQ COU_SKIP3				; Is FLAG=0? Yes, skip ahead
   522  e238 4c7ae1             		JMP CHAR_TO_SCREEN3
   523                          
   524                          ;		--------------------------------------- Check for DELETE
   525                          
   526  e23b c914               COU_SKIP3	CMP #$14				; Is it <DEL>?
   527  e23d d01c               		BNE COU_SKIP6				; No, skip ahead
   528                          
   529                          ;		--------------------------------------- DELETE - Check if it would wrap to previous line
   530                          
   531  e23f 88                 		DEY					; Yes, move to the left
   532  e240 84c6               		STY CursorCol   			; Cursor Column on Current Line
   533  e242 1006               		BPL COU_SKIP4
   534  e244 20dee1             		JSR CURSOR_TO_EOPL			; Back to previous line (rename this label?)
   535  e247 4c55e2             		JMP COU_SKIP5
   536                          
   537                          ;		--------------------------------------- Perform DELETE
   538                          
   539                          COU_SKIP4
   540                          !IF COLOURPET=0 {
   541  e24a c8                 		INY
   542  e24b b1c4               		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   543  e24d 88                 		DEY		
   544  e24e 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
   545  e250 c8                 		INY
   546  e251 c4d5               		CPY RightMargin   			; Physical Screen Line Length
   547  e253 d0f5               		BNE COU_SKIP4
   548                          } ELSE {
   549                          		JSR ColourPET_Scroll_Left		; Scroll both Screen and Colour LEFT	@@@@@@@@@@@@@@ ColourPET
   550                          }
   551                          
   552                          COU_SKIP5
   553  e255 a920               		LDA #$20				; <SPACE>
   554  e257 91c4               		STA (ScrPtr),Y				; Put it on the screen!
   555                          !IF COLOURPET=1 {
   556                          		LDA COLOURV				; Get the current Colour	@@@@@@@@@@@@@@@ ColourPET
   557                          		STA (COLOURPTR),Y			; Put it to Colour MEM		@@@@@@@@@@@@@@@ ColourPET
   558                          }
   559  e259 d029               		BNE COU_SKIP11
   560                          
   561  e25b a6cd               COU_SKIP6	LDX QuoteMode   			; Flag: Editor in Quote Mode
   562  e25d f003               		BEQ COU_SKIP7
   563  e25f 4c7ae1             		JMP CHAR_TO_SCREEN3
   564                          
   565                          ;		--------------------------------------- Check for RVS
   566                          
   567  e262 c912               COU_SKIP7	CMP #$12				; Is it <RVS>?
   568  e264 d004               		BNE COU_SKIP8
   569  e266 859f               		STA ReverseFlag    			; Flag: Print Reverse Chars. -1=Yes
   570  e268 f01a               		BEQ COU_SKIP11
   571                          
   572                          ;		--------------------------------------- Check for HOME
   573                          
   574  e26a c913               COU_SKIP8	CMP #$13				; Is it <HOME>?
   575  e26c d003               		BNE COU_SKIP9				; No, skip ahead
   576  e26e 206be0             		JSR CURSOR_HOME				; Cursor to start of line
   577                          
   578                          ;		--------------------------------------- Check for CURSOR RIGHT
   579                          
   580  e271 c91d               COU_SKIP9	CMP #$1D				; Is it <CRSR-RIGHT>?
   581  e273 d012               		BNE COU_SKIP12
   582  e275 c8                 		INY
   583  e276 84c6               		STY CursorCol   			; Cursor Column on Current Line
   584  e278 88                 		DEY
   585  e279 c4d5               		CPY RightMargin   			; Physical Screen Line Length
   586  e27b 9007               		BCC COU_SKIP11
   587  e27d 20a9e3             		JSR CURSOR_DOWN				; Move Cursor to next line
   588  e280 a000               		LDY #$00
   589  e282 84c6               COU_SKIP10	STY CursorCol   			; Cursor Column on Current Line
   590  e284 4ca6e1             COU_SKIP11	JMP IRQ_EPILOG				; Finish Up
   591                          
   592                          ;		--------------------------------------- Check for CURSOR DOWN
   593                          
   594  e287 c911               COU_SKIP12	CMP #$11				; Is it <CRSR-DOWN>?
   595  e289 d011               		BNE COU_SKIP14				; No, skip ahead
   596  e28b 18                 		CLC
   597  e28c 98                 		TYA
   598  e28d 6928               !IF SS40=0 {	ADC #COLUMNS				; Add Fixed Screen Width for next line
   599                          } ELSE {	ADC SCNWIDTH }				; Add Soft Screen Width
   600  e28f a8                 		TAY
   601  e290 c5d5               		CMP RightMargin   			; Compare it to Screen Line Length
   602  e292 90ee               		BCC COU_SKIP10				; Less, so it's ok
   603  e294 f0ec               		BEQ COU_SKIP10				; Equal, also ok
   604  e296 20a9e3             		JSR CURSOR_DOWN				; More, so Move Cursor to next line
   605  e299 4ca6e1             COU_FINISH	JMP IRQ_EPILOG				; Finish Up
   606                          
   607                          ;		--------------------------------------- Check for ERASE TO END OF LINE
   608                          
   609  e29c c910               COU_SKIP14	!IF BUGFIX=0 { CMP #$10 }		; Is it CTRL-P? (BUG!)  This should be #10 or #$16
   610                          		!IF BUGFIX=1 { CMP #$16 }		; Is it CTRL-V? (BUG is FIXED!)
   611  e29e d00c               		BNE COU_SKIP15				; No, skip ahead
   612                          
   613                          ;[E2D4]		--------------------------------------- Erase to End of Line
   614                          
   615                          !IF COLOURPET=1 {
   616                          		JSR ERASE_TO_EOL			; Replace with ColourPET Version
   617                          		JMP COU_FINISH				; Jump to continue
   618                          } ELSE {
   619                          
   620                          ERASE_TO_EOL						; Original Routine
   621  e2a0 a920               		LDA #$20				; Yes, set character to <SPACE>
   622  e2a2 88                 		DEY
   623  e2a3 c8                 ETEL_LOOP 	INY					; LOOP[
   624  e2a4 91c4               		STA (ScrPtr),Y				;   Store <SPACE> to screen
   625  e2a6 c4d5               		CPY RightMargin				;   Is it end of line?
   626  e2a8 90f9               		BCC ETEL_LOOP				; ] No, loop back for more
   627  e2aa b0ed               		BCS COU_FINISH				; Yes, Finish up
   628                          }
   629                          ;		--------------------------------------- Check for TEXT MODE
   630                          
   631  e2ac c90e               COU_SKIP15	CMP #$0E				; Is it <TEXT>?
   632  e2ae d005               		BNE COU_SKIP16				; No, skip ahead
   633  e2b0 200fe6             		JSR CRT_SET_TEXT			; Yes, Set screen to TEXT mode
   634  e2b3 30e4               		BMI COU_FINISH				; Finish up
   635                          
   636                          ;		--------------------------------------- Check for BELL
   637                          
   638  e2b5 c907               COU_SKIP16	CMP #$07				; Is it <BELL>?
   639  e2b7 d005               		BNE COU_SKIP17				; No, skip ahead
   640  e2b9 2057e6             		JSR BEEP				; Ring BELL
   641  e2bc f0db               		BEQ COU_FINISH				; Finish up
   642                          
   643                          ;		--------------------------------------- Check for TAB
   644                          
   645  e2be c909               COU_SKIP17	CMP #$09				; Is it <TAB>?
   646  e2c0 d0d7               		BNE COU_FINISH				; Finish up
   647                          
   648  e2c2 c4d5               COU_SKIP18	CPY RightMargin   			; Physical Screen Line Length
   649  e2c4 9007               		BCC COU_SKIP20
   650  e2c6 a4d5               		LDY RightMargin   			; Physical Screen Line Length
   651                          
   652  e2c8 84c6               COU_SKIP19	STY CursorCol   			; Cursor Column on Current Line
   653  e2ca 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   654                          
   655  e2cd c8                 COU_SKIP20	INY
   656  e2ce 2088e5             		JSR CHECK_TAB				; Check TAB
   657  e2d1 f0ef               		BEQ COU_SKIP18				; Is this a TAB position?
   658  e2d3 d0f3               		BNE COU_SKIP19				; No, Loop back
   659                          
   660                          ;*********************************************************************************************************
   661                          ;** CHROUT_HI [$E2D5]
   662                          ;** Character Output when High Bit SET (characters in the range 128 to 256).
   663                          ;** Handles: INS,CRSR-UP,RVS-OFF,CRSR-LEFT,CLR,ERASE-SOL,GRAPHICS,BELL,SET-TAB
   664                          ;*********************************************************************************************************
   665                          
   666                          CHROUT_HI
   667  e2d5 297f               		AND #$7F				; strip off top bit
   668  e2d7 c97f               		CMP #$7F				; is it $FF?
   669  e2d9 d002               		BNE COH_SKIP1				; No, skip
   670  e2db a95e               		LDA #$5E				; Yes, substitute with $5E (PI character)
   671                          
   672  e2dd c920               COH_SKIP1	CMP #$20				; Is it <SPACE>?
   673  e2df 9003               		BCC COH_SKIP2				; Less? Yes, skip ahead and check more
   674  e2e1 4c74e1             		JMP CHAR_TO_SCREEN			; 32 to 127 -> 160-255. Jump and print it
   675                          
   676                          ;[E2E4]		--------------------------------------- Check for SHIFT-RETURN
   677                          
   678  e2e4 c90d               COH_SKIP2	CMP #$0D				; Is it <SHIFT-RETURN>?
   679  e2e6 d003               		BNE COH_SKIP3				; No, skip ahead (continue)
   680  e2e8 4cbfe3             		JMP CURSOR_RETURN			; Yes, handle it
   681                          
   682                          ;[E2EB]		--------------------------------------- Check Quote Mode
   683                          
   684  e2eb a6cd               COH_SKIP3	LDX QuoteMode   			; Flag: Editor in Quote Mode
   685  e2ed d030               		BNE COH_SKIP6				; No, skip ahead
   686                          
   687                          ;[E2EF]		--------------------------------------- Check for INSERT
   688                          
   689  e2ef c914               		CMP #$14				; Is it <INS>? (SHIFT-DEL)
   690  e2f1 d028               		BNE COH_SKIP5				; No, skip ahead
   691                          
   692                          ;[E2F3]		--------------------------------------- INS was pressed
   693                          
   694  e2f3 a4d5               CHECK_INSERT	LDY RightMargin   			; Right margin
   695  e2f5 b1c4               		LDA (ScrPtr),Y				; Read the character at the end of the line
   696  e2f7 c920               		CMP #$20				; Is the character a <SPACE>?
   697  e2f9 d004               		BNE COH_SKIP4				; No, skip ahead
   698  e2fb c4c6               		CPY CursorCol				; Cursor Column on Current Line
   699  e2fd d007               		BNE DO_INSERT
   700                          
   701  e2ff c04f               COH_SKIP4	CPY #COLUMNS*2-1			; Hard Coded Screen Width*2-1 (79)
   702  e301 f081               		BEQ COU_SKIP11				; Yes, go back up for more
   703  e303 20eae6             		JSR WIN_SCROLL_DN			; Check for and perform scrolling DOWN
   704                          
   705                          ;[E306]		--------------------------------------- Do INSERT
   706                          
   707  e306 a4d5               DO_INSERT 	LDY RightMargin   			; Start at right margin
   708                          
   709                          !IF COLOURPET=0 {
   710  e308 88                 INS_LOOP1 	DEY					; LOOP[  move back one
   711  e309 b1c4               		LDA (ScrPtr),Y 				;   Get character from screen
   712  e30b c8                 		INY					;   Next character
   713  e30c 91c4               		STA (ScrPtr),Y				;   Put character back to screen
   714  e30e 88                 		DEY					;   Next position
   715  e30f c4c6               		CPY CursorCol   			;   Have we reached current Cursor position?
   716  e311 d0f5               		BNE INS_LOOP1				; ] No, loop back for more
   717                          } ELSE {
   718                          		JSR ColourPET_Insert
   719                          }	
   720  e313 a920               		LDA #$20				; <SPACE>
   721  e315 91c4               		STA (ScrPtr),Y 				; Write <SPACE> to screen at cursor position
   722  e317 e6dc               		INC INSRT				; Flag: Insert Mode, >0 = # INSTs
   723  e319 d058               		BNE COH_FINISH
   724                          
   725  e31b a6dc               COH_SKIP5	LDX INSRT  				; Flag: Insert Mode, >0 = # INSTs
   726  e31d f005               		BEQ COH_CHECK1
   727                          
   728  e31f 0940               COH_SKIP6	ORA #$40				; Set BIT 6
   729  e321 4c7ae1             		JMP CHAR_TO_SCREEN3			; Print it
   730                          
   731                          ;[E324]		--------------------------------------- Check for CURSOR UP
   732                          
   733  e324 c911               COH_CHECK1	CMP #$11				; Is it <CRSR-UP>? (SHIFT-CRSR-DOWN)
   734  e326 d02b               		BNE COH_CHECK2
   735                          
   736                          ;[E32A]		--------------------------------------- Do Cursor UP
   737                          
   738  e328 a5c6               		LDA CursorCol   			; Cursor Column on Current Line
   739  e32a c928               !IF SS40=0 {	CMP #COLUMNS				; Compare to Fixed Screen Width
   740                          } ELSE {	CMP SCNWIDTH }				; Compare to Soft Screen Width
   741  e32c 9006               		BCC COH_SKIP7				; Is it less? No, skip ahead
   742  e32e e928               !IF SS40=0 {	SBC #COLUMNS				; Yes, subtract Fixed Screen Width
   743                          } ELSE {	SBC SCNWIDTH }				; Yes, subtract Soft Screen Width
   744  e330 85c6               		STA CursorCol   			; Cursor Column on Current Line
   745  e332 b03f               		BCS COH_FINISH
   746                          
   747  e334 a6d8               COH_SKIP7	LDX CursorRow   			; Current Cursor Physical Line Number
   748  e336 f03b               		BEQ COH_FINISH
   749  e338 b5df               		LDA MYCH,X				; Serial Word Buffer
   750  e33a 1007               		BPL COH_SKIP8
   751  e33c c6d8               		DEC CursorRow   			; Current Cursor Physical Line Number
   752  e33e 2071e0             		JSR CURSOR_LM				; Cursor to start of line
   753  e341 9030               		BCC COH_FINISH
   754                          
   755  e343 ca                 COH_SKIP8	DEX
   756  e344 ca                 		DEX
   757  e345 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   758  e347 2071e0             		JSR CURSOR_LM				; Cursor to start of line
   759  e34a a5c6               		LDA CursorCol   			; Cursor Column on Current Line
   760  e34c 18                 		CLC
   761  e34d 6928               		ADC #COLUMNS
   762  e34f 85c6               		STA CursorCol				; Cursor Column on Current Line
   763  e351 d020               		BNE COH_FINISH
   764                          
   765                          ;[E353]		--------------------------------------- Check for RVS OFF
   766                          
   767  e353 c912               COH_CHECK2	CMP #$12				; Is it <OFF>? (SHIFT-RVS)
   768  e355 d006               		BNE COH_CHECK3				; No, skip ahead
   769  e357 a900               		LDA #0					; Set RVS OFF
   770  e359 859f               		STA ReverseFlag    			; Store it
   771  e35b f016               		BEQ COH_FINISH
   772                          
   773                          ;[E35D]		--------------------------------------- Check for CURSOR LEFT
   774                          
   775  e35d c91d               COH_CHECK3	CMP #$1D				; Is it <CRSR-LEFT>? (SHIFT-CRSR-RIGHT)
   776  e35f d00b               		BNE COH_CHECK4				; No, skip ahead
   777                          
   778  e361 88                 		DEY
   779  e362 84c6               		STY CursorCol   			; Cursor Column on Current Line
   780  e364 100d               		BPL COH_FINISH
   781  e366 20dee1             		JSR CURSOR_TO_EOPL
   782  e369 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   783                          
   784                          ;[E36C]		--------------------------------------- Check for CLEAR SCREEN
   785                          
   786  e36c c913               COH_CHECK4	CMP #$13				; Is it <CLR>? (SHIFT-HOME)
   787  e36e d006               		BNE COH_CHECK5				; No, skip ahead
   788  e370 2042e0             		JSR WIN_CLEAR			; Yes, Clear the Screen
   789  e373 4ca6e1             COH_FINISH	JMP IRQ_EPILOG				; Finish Up
   790                          
   791                          ;[E376]		--------------------------------------- Check for ERASE TO START OF LINE
   792                          
   793                          COH_CHECK5	
   794                          !IF COLOURPET=0 {
   795  e376 c916               		CMP #$16				; Is it <ERASE-END>? (SHIFT-CTRL-V) - CONFLICTS with COLOURPET!
   796  e378 d00d               		BNE COH_CHECK6				; No, skip ahead
   797                          } ELSE {
   798                          		JMP COH_CHECK6				; Just Skip ahead		@@@@@@@@@@ COLOURPET
   799                          }
   800                          
   801                          ;*********************************************************************************************************
   802                          ;** ERASE_TO_SOL / ESCAPE_P [E37A]
   803                          ;** Erases from cursor to Start of Line
   804                          ;*********************************************************************************************************
   805                          
   806                          ESCAPE_P
   807  e37a a920               ERASE_TO_SOL	LDA #$20				; <SPACE>
   808  e37c a000               		LDY #0					; Start at Left Margin
   809  e37e c4c6               ESOL_LOOP	CPY CursorCol   			; LOOP[  Cursor Column on Current Line
   810  e380 b0f1               		BCS COH_FINISH				;   Finish up
   811  e382 91c4               		STA (ScrPtr),Y				;   Pointer: Current Screen Line Address
   812                          !IF COLOURPET=1 {
   813                          		LDA COLOURV				;   Current Colour
   814                          		STA (COLOURPTR),Y			;   Write Current Colour to colour RAM
   815                          }
   816  e384 c8                 		INY
   817  e385 d0f7               		BNE ESOL_LOOP				; ] Loop back for more
   818                          
   819                          ;[E387]		--------------------------------------- Check for SET GRAPHICS MODE
   820                          
   821  e387 c90e               COH_CHECK6	CMP #$0E				; Is it <GRAPHICS>? (SHIFT-TEXT)
   822  e389 d005               		BNE COH_CHECK7				; No, skip ahead
   823  e38b 2017e6             		JSR CRT_SET_GRAPHICS			; Yes, Set screen to graphics mode
   824  e38e 30e3               		BMI COH_FINISH				; Finish up
   825                          
   826                          ;[E390]		--------------------------------------- Check for BELL
   827                          
   828  e390 c907               COH_CHECK7	CMP #$07				; Is it <BELL>?
   829  e392 d005               		BNE COH_CHECK8				; No, skip ahead
   830  e394 2054e6             		JSR BEEP_BEEP				; Ring the Bell
   831  e397 f0da               		BEQ COH_FINISH				; Finish up
   832                          
   833                          ;[E399]		--------------------------------------- Check for SET TAB
   834                          
   835  e399 c909               COH_CHECK8	CMP #$09				; Is it <SET-TAB>? (SHIFT-TAB)
   836  e39b d0d6               		BNE COH_FINISH				; No, Finish up
   837  e39d 2088e5             		JSR CHECK_TAB				; Set TAB
   838  e3a0 4def03             		EOR TABS   				; Table of 80 bits to set TABs (80col)
   839  e3a3 9df003             		STA $03F0,X
   840  e3a6 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   841                          
   842                          ;*********************************************************************************************************
   843                          ;** CURSOR_DOWN  [$E3A9]
   844                          ;** Do Cursor DOWN, Go to next line. If at bottom of window SCROLL UP.
   845                          ;*********************************************************************************************************
   846                          
   847  e3a9 38                 CURSOR_DOWN	SEC
   848  e3aa 46a3               		LSR InputRow   				; Cursor Y-X Pos. at Start of INPUT
   849  e3ac a6d8               		LDX CursorRow   			; Current Cursor Physical Line Number
   850                          
   851  e3ae e8                 CD_LOOP1	INX					; LOOP[
   852  e3af e019               		CPX #ROWS				;   Last line of screen?
   853  e3b1 d003               		BNE CD_SKIP
   854  e3b3 20d1e3             		JSR WIN_SCROLL_UP			;   Scroll Screen Up
   855                          
   856  e3b6 b5e0               CD_SKIP		LDA LineLinkTable,X			;   Screen Line Link Table / Editor Temps (40 col)
   857  e3b8 10f4               		BPL CD_LOOP1				; ] Is HI bit CLEAR? Yes then go back for more
   858  e3ba 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   859  e3bc 4c71e0             		JMP CURSOR_LM				; Cursor to start of line
   860                          
   861                          ;*********************************************************************************************************
   862                          ;** CURSOR_RETURN  [E3BF]
   863                          ;** Cursor to start of line, then CURSOR DOWN. Also performs ESCAPE
   864                          ;*********************************************************************************************************
   865                          
   866  e3bf 20a9e3             CURSOR_RETURN	JSR CURSOR_DOWN				; Move to next line
   867  e3c2 a900               		LDA #0					; Column 0
   868  e3c4 85c6               		STA CursorCol   			; Set Cursor Column on Current Line
   869                          
   870                          ;*********************************************************************************************************
   871                          ;** ESCAPE / ESCAPE_O [E3C6]
   872                          ;** Cancels Insert, Reverse and Quote modes
   873                          ;*********************************************************************************************************
   874                          
   875                          ESCAPE_O				
   876  e3c6 a900               ESCAPE		LDA #0
   877  e3c8 85dc               		STA INSRT  				; Flag: Insert Mode, >0 = # INSTs
   878  e3ca 859f               		STA ReverseFlag    			; Flag: Print Reverse Chars. -1=Yes
   879  e3cc 85cd               		STA QuoteMode   			; Flag: Editor in Quote Mode
   880                          
   881                          !IF ESCCODES = 1 { STA LASTCHAR }
   882                          
   883  e3ce 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   884                          
   885                          ;*********************************************************************************************************
   886                          ;** WIN_SCROLL_UP / ESCAPE_V  [E3D1] (Called from Jump Table)
   887                          ;** Scrolls entire screen UP. Also scroll up line-link table
   888                          ;*********************************************************************************************************
   889                          
   890                          ESCAPE_V
   891                          WIN_SCROLL_UP
   892  e3d1 a219               		LDX #ROWS				; Hard-coded Screen Lines (normally 25)
   893  e3d3 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   894                          
   895  e3d5 a2ff               WSU_LOOP1	LDX #$FF
   896                          
   897                          ;[E3D7]		--------------------------------------- Set up screen pointers, scroll line link table entry for the current line
   898                          
   899  e3d7 e8                 WSU_LOOP2	INX					; LOOP[
   900  e3d8 bd98e7             		LDA Line_Addr_Lo,X			;   Screen line address table LO
   901  e3db 85c4               		STA ScrPtr    				;   Set up Pointer LO for screen scrolling
   902  e3dd b5e0               		LDA LineLinkTable,X			;   Screen Line Link Table (address table HI)
   903  e3df 0980               		ORA #$80				;   Make sure HI BIT is set
   904  e3e1 85c5               		STA ScrPtr+1				;   Set up pointer HI for screen scrolling 
   905  e3e3 e018               		CPX #ROWS-1				;   Last Line?
   906  e3e5 b01d               		BCS WSU_SKIP2				;   Yes, so skip ahead to exit loop
   907  e3e7 b4e1               		LDY LineLinkTable+1,X			;   No, so get NEXT Line's Line Link entry
   908  e3e9 3002               		BMI WSU_SKIP1				;   is HI BIT set? Yes, leave it as is and skip ahead
   909  e3eb 297f               		AND #$7F				;   No, then CLEAR HI BIT
   910                          
   911  e3ed 95e0               WSU_SKIP1	STA LineLinkTable,X			;   Store it in the CURRENT Line Link entry (IE scroll the high bits UP)
   912  e3ef 98                 		TYA
   913  e3f0 0980               		ORA #$80				;   Set HI BIT
   914  e3f2 85c8               		STA SAL+1				;   $C8
   915  e3f4 bd99e7             		LDA Line_Addr_Lo+1,X			;   Screen line address table
   916  e3f7 85c7               		STA SAL    				;   Pointer: Tape Buffer/ Screen Scrolling
   917                          
   918                          ;[E3F9]		--------------------------------------- Now we scroll the video screen lines
   919                          
   920  e3f9 a027               !IF SS40=0 {	LDY #COLUMNS-1				;   Hard-coded Screen Width
   921                           } ELSE {	LDY SCNWIDTH }				;   Soft Screen Width
   922                          
   923  e3fb b1c7               WSU_LOOP3	LDA (SAL),Y 				;   LOOP[[  Read character from screen
   924  e3fd 91c4               		STA (ScrPtr),Y 				;     Write it back
   925  e3ff 88                 		DEY					;     Next character
   926  e400 10f9               		BPL WSU_LOOP3				;   ]] Loop back for more
   927  e402 30d3               		BMI WSU_LOOP2				; ] Loop back for more
   928                          
   929  e404 95e0               WSU_SKIP2	STA LineLinkTable,X			; Store to Screen Line Link Table
   930                          
   931                          ;[E406]		--------------------------------------- Clear the last screen line
   932                          
   933  e406 a027               !IF SS40=0 {	LDY #COLUMNS-1				;   Hard-coded Screen Width
   934                          } ELSE {	LDY SCNWIDTH				;   Soft Screen Width
   935                          		DEY }					;   -1
   936                          
   937  e408 a920               		LDA #$20				; <SPACE>
   938                          
   939  e40a 91c4               WSU_LOOP4	STA (ScrPtr),Y 				; LOOP[  Write <SPACE> to the screen
   940  e40c 88                 		DEY					;   Next character
   941  e40d 10fb               		BPL WSU_LOOP4				; ] Loop back for more
   942                          
   943  e40f c6d8               		DEC CursorRow   			; Current Cursor Physical Line Number
   944  e411 a5e0               		LDA LineLinkTable			; Screen Line Link Table / Editor Temps (40 col)
   945  e413 10c0               		BPL WSU_LOOP1				; ] Loop back for more
   946                          
   947                          ;*********************************************************************************************************
   948                          ;** Check Keyboard Scroll Control  [E415]
   949                          ;*********************************************************************************************************
   950                          
   951                          CHECK_SCROLL_CONTROL
   952  e415 ad12e8             		LDA PIA1_Port_B				; Keyboard COL read
   953  e418 c9fe               		CMP #$FE				; Is KEY held down?
   954  e41a d00b               		BNE CSC_SKIP				; No, skip over delay
   955                          
   956                          ;[E41C]		--------------------------------------- Scroll delay
   957                          
   958  e41c a000               		LDY #$00
   959                          
   960  e41e ea                 SCROLL_DELAY	NOP					; LOOP[
   961  e41f ca                 		DEX
   962  e420 d0fc               		BNE SCROLL_DELAY 			; ] Loop back for more
   963  e422 88                 		DEY
   964  e423 d0f9               		BNE SCROLL_DELAY 			; ] Loop back for more
   965                          
   966  e425 849e               		STY CharsInBuffer    			; No. of Chars. in Keyboard Buffer (Queue)
   967                          
   968                          ;[E427]		--------------------------------------- Scroll complete
   969                          
   970  e427 a6d8               CSC_SKIP	LDX CursorRow   			; Current Cursor Physical Line Number
   971  e429 60                 		RTS
   972                          
   973                          !IF CRUNCH = 0 {
   974  e42a aa                 		TAX					; Filler
   975  e42b aa                 		TAX					; Filler
   976  e42c aa                 		TAX					; Filler
   977  e42d aa                 		TAX					; Filler
   978                          }
   979                          
   980                          ;*********************************************************************************************************
   981                          ;** Jiffy Clock Timer Correction Patch  [E42E]
   982                          ;*********************************************************************************************************
   983                          
   984  e42e 20eaff             ADVANCE_TIMER	JSR UDTIME				; Update System Jiffy Clock. KERNAL routine $FFEA 
   985  e431 eeed03             		INC JIFFY6DIV5				; Counter to speed TI by 6/5 (40col)
   986  e434 aded03             		LDA JIFFY6DIV5				; Counter to speed TI by 6/5 (40col)
   987  e437 c906               		CMP #$06				; 6 IRQ's?
   988  e439 d01d               		BNE IRQ_NORMAL2				; No, do normal IRQ
   989  e43b a900               		LDA #0					; Reset IRQ adjustment counter
   990  e43d 8ded03             		STA JIFFY6DIV5 				; Counter to speed TI by 6/5 (40col)
   991  e440 f0ec               		BEQ ADVANCE_TIMER			; was IRQ_MAIN		; Do normal IRQ
   992                          
   993                          ;*********************************************************************************************************
   994                          ;** MAIN IRQ ENTRY [E442][E455] (Called from Jump Table) - FIXED ENTRY POINT!
   995                          ;** This entry point must not move! It is called directly from KERNAL
   996                          ;** The CRTC chip's V-Sync line is fed to a VIA to generate IRQ's. When an IRQ is triggered, the
   997                          ;** Clock is updated, the keyboard scanned, ieee polled and tape monitored.
   998                          ;*********************************************************************************************************
   999                          !FILL $e442-*,$aa ; FIXED ENTRY POINT! This routine must not move!
  1000                          ;#########################################################################################################
  1001                          

; ******** Source: irq.asm
     1                          ; PET/CBM EDIT ROM - IRQ Handler Routines
     2                          ; ================
     3                          ; The IRQ does the work of updating the clock/timer, checking interrupts and calling the keyboard scanner.
     4                          
     5                          
     6                          IRQ_MAIN
     7  e442 48                 		PHA
     8  e443 8a                 		TXA
     9  e444 48                 		PHA
    10  e445 98                 		TYA
    11  e446 48                 		PHA
    12  e447 ba                 		TSX
    13  e448 bd0401             		LDA STACK+4,X
    14  e44b 2910               		AND #16
    15  e44d f003               		BEQ Be452
    16  e44f 6c9200             		JMP (CBINV)	; Vector: BRK Instr. Interrupt [D478]
    17  e452 6c9000             Be452		JMP (CINV)	; Vector: Hardware Interrupt   [E455] Points to 'IRQ_NORMAL'
    18                          
    19                          ;*********************************************************************************************************
    20                          ;** IRQ_NORMAL [$E455]
    21                          ;*********************************************************************************************************
    22                          
    23                          ;************** IRQ (Called from Jump Table)
    24                          ; The IRQ is fired when the CRTC chip does a VSYNC, so the timing is
    25                          ; dependent on the CRTC configuration.
    26                          ; Normally: $E455
    27                          
    28                          IRQ_NORMAL
    29                          		!IF IRQFIX=1 {
    30                          			!IF CODEBASE=0 { JMP ADVANCE_TIMER }
    31                          			!IF CODEBASE=1 { JMP ADVANCE_TIMER }
    32                          			!IF CODEBASE=2 { JSR ADVANCE_TIMER }
    33                          		} ELSE {
    34  e455 20eaff             			JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA 			
    35                          		}
    36                          
    37                          ;		--------------------------------------- Blink the cursor
    38                          
    39                          IRQ_NORMAL2						; ie458
    40  e458 a5a7               		LDA Blink				; Cursor Blink enable: 0 = Flash Cursor
    41  e45a d01f               		BNE Be474				; skip it
    42  e45c c6a8               		DEC BLNCT				; Timer: Countdown to Toggle Cursor
    43  e45e d01b               		BNE Be474				; skip it
    44                          
    45  e460 a914               		LDA #$14				; default cursor blink rate (20)
    46                          !if REPEATOPT = 1 {
    47  e462 2cee03             		BIT RPTFLG				; check repeat flag
    48  e465 1002               		BPL ie468				; skip if not enabled
    49  e467 a902               		LDA #2					; make cursor blink immediately
    50                          }
    51  e469 85a8               ie468		STA BLNCT				; store to blink countdown counter
    52  e46b a4c6               		LDY CursorCol				; Column where cursor lives
    53  e46d 46aa               		LSR BlinkPhase				; Is it blinking?
    54  e46f b1c4               		LDA (ScrPtr),Y				; Get character from the screen
    55  e471 b004               		BCS Be470				; Yes, skip
    56  e473 e6aa               		INC BlinkPhase				; count
    57  e475 85a9               		STA CursorChar				; Remember the character at cursor (to be restored when cursor moves)
    58  e477 4980               Be470		EOR #$80				; Flip the reverse bit
    59  e479 91c4               		STA (ScrPtr),Y				; Put it back on the screen
    60                          
    61                          ;		--------------------------------------- Prep for keyboard scanning [$E47B]
    62                          
    63  e47b a000               Be474		LDY #0
    64  e47d ad10e8             		LDA PIA1_Port_A 			; Keyboard ROW select - PIA#1, Register 0
    65                          							; Upper bits: IEEE and Cassette
    66                          							; Lower bits: Keyboard ROW select
    67                          !if CODEBASE<2 {
    68  e480 29f0               		AND #$F0				; Mask off lower 4 bits (reset keyboard scan row)
    69  e482 8d10e8             		STA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    70  e485 ad10e8             		LDA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    71                          } 
    72                          
    73                          ;		--------------------------------------- Check IEEE and Cassette status
    74                          
    75  e488 0a                 		ASL					; Shift upper bits to lower 
    76  e489 0a                 		ASL 
    77  e48a 0a                 		ASL 
    78  e48b 1009               		BPL Be487				; Is CASSETTE#1 Sense? No, skip
    79                          
    80  e48d 84f9               		STY CAS1				; Yes, Tape Motor Interlock #1
    81  e48f ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt
    82  e492 0908               		ORA #8					; Is CASSETTE#2 Sense?
    83  e494 d009               		BNE Be490				; No, skip
    84                          
    85  e496 a5f9               Be487		LDA CAS1				; Yes, Tape Motor Interlock #1
    86  e498 d008               		BNE Be493				; No, skip
    87                          
    88  e49a ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    89  e49d 29f7               		AND #$f7				; Mask off bit 4
    90  e49f 8d13e8             Be490		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    91  e4a2 9009               Be493		BCC Be49e
    92                          
    93  e4a4 84fa               		STY CAS2				; Tape Motor Interlock #2
    94  e4a6 ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
    95  e4a9 0910               		ORA #16
    96  e4ab d009               		BNE Be4a7
    97  e4ad a5fa               Be49e		LDA CAS2				; Tape Motor Interlock #2
    98  e4af d008               		BNE Be4aa
    99  e4b1 ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
   100  e4b4 29ef               		AND #$ef
   101  e4b6 8d40e8             Be4a7		STA VIA_Port_B				; VIA Register 0 (flags)
   102  e4b9 20bfe4             Be4aa		JSR SCAN_KEYBOARD			; Scan the keyboard
   103                          
   104                          !IF REBOOT=1 {  JSR CheckReboot }			; Check for soft reset ******* should this go above Be474 ?????????????????
   105                          
   106  e4bc 4c00e6             		JMP IRQ_END				; Return from Interrupt
   107                          

; ******** Source: editrom40.asm
  1002                          
  1003                          
  1004                          ;*********************************************************************************************************
  1005                          ;** KEYBOARD SCANNER  [E4BE]
  1006                          ;** The Keyboard is scanned during the IRQ and one keystroke is stored to KEYD. Other routines transfer
  1007                          ;** this keystroke to or from a small 10-byte buffer. The keyboard scanner does the actual interfacing to
  1008                          ;** the hardware to read the rows and columns of the keyboard matrix. When a key is pressed it gets the
  1009                          ;** keycode from the keyboard matrix table. If no key is pressed, then $FF is returned.
  1010                          ;*********************************************************************************************************
  1011                          

; ******** Source: keyscan-g.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Scan - Graphic Keyboards
     2                          ; ================
     3                          ; Standard Graphic Keyboard scanner. Requires one keyboard table.
     4                          ; NOTE: Does not handle shifted numerics!
     5                          ;
     6                          ; OPTIONS: KEYBOARD=7 modifies scanner for CBM-II keyboard (16x6 matrix)
     7                          
     8                          ;--------------- Scan Keyboard (scnkey)
     9                          ; NOTE: The keyboard ROW select is reset to zero in IRQ routine
    10                          
    11                          SCAN_KEYBOARD				; [$E4BF]
    12                          
    13                          ;!if DEBUG = 1 { INC DBLINE+5 }		; DEBUG - 6th character on top line
    14                          
    15  e4bf a0ff               		LDY #$FF		; No Key
    16  e4c1 84a6               		STY Key_Image		; Key Image
    17  e4c3 c8                 		INY
    18  e4c4 8498               		STY KEYFLAGS		; Flag: Print Shifted Chars.
    19  e4c6 adee03             		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    20  e4c9 297f               		AND #$7F
    21  e4cb 8dee03             		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    22                          		!IF KEYBOARD=7 {
    23                          			LDX #$60	; 96 bytes in table. X is used as offset into the table (CBM-II keyboard)
    24                          		} ELSE {
    25  e4ce a250               			LDX #$50	; 80 bytes in table. X is used as offset into the table (normal keyboards)
    26                          		}
    27                          
    28                          SCAN_ROW
    29                          		!IF KEYBOARD=7 {
    30                          			 LDY #$06	; Number of Columns to check = 6 (CBM-II keyboard only)
    31                          		} ELSE {
    32  e4d0 a008               			 LDY #$08	; Number of Columns to check = 8 (normal keyboards)
    33                          		}
    34                          
    35  e4d2 ad12e8             		LDA PIA1_Port_B 	; Keyboard COL result
    36  e4d5 cd12e8             		CMP PIA1_Port_B 	; Keyboard COL result
    37  e4d8 d0f6               		BNE SCAN_ROW		; Debounce
    38                          
    39                          ;		----------------------- Check Result [$E4DF]
    40  e4da c9ff                   		CMP #$FF		; Are any keys pressed?  ($FF = No keys are down)
    41  e4dc d009                   		BNE SCAN_COL		; Yes, go check the bits
    42  e4de 8a                     		TXA			; No,
    43  e4df 38                     		SEC
    44  e4e0 e908                   		SBC #$08
    45  e4e2 aa                     		TAX
    46  e4e3 d02c                   		BNE SCAN_NEXT3
    47  e4e5 f02f                   		BEQ SCAN_GOT
    48                          ;		----------------------- Some keys are down
    49                          
    50  e4e7 4a                 SCAN_COL	LSR			; Shift the value right
    51  e4e8 b021               		BCS SCAN_NEXT2		; If the bit was "1" then key is NOT down. Skip
    52                          
    53                          ;		----------------------- We have a key press. Look it up in the keyboard matrix
    54                          
    55  e4ea 48                 		PHA			; Save for later
    56  e4eb bd3ee7             		LDA KEYBOARD_NORMAL-1,X ; Read Keyboard Matrix (X is offset)
    57  e4ee d006               		BNE SCAN_NOSH		; Is it SHIFT key? No, skip
    58                          
    59                          ;		----------------------- SHIFT key Detected
    60                          
    61  e4f0 a901               		LDA #$01		; Set the SHIFT flag
    62  e4f2 8598               		STA KEYFLAGS		; Flag: Print Shifted Chars.
    63  e4f4 d014               		BNE SCAN_NEXT		; No, skip
    64                          
    65                          ;		----------------------- Non-SHIFT key
    66                          
    67  e4f6 c910               SCAN_NOSH	CMP #$10		; Is it REPEAT?
    68  e4f8 d00a               		BNE SCAN_NORPT		; No, skip
    69                          
    70                          ;		----------------------- REPEAT key
    71                          
    72  e4fa adee03             		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    73  e4fd 0980               		ORA #$80
    74  e4ff 8dee03             		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    75  e502 3006               		BMI SCAN_NEXT
    76                          
    77  e504 c9ff               SCAN_NORPT	CMP #$FF		; Is it "no key"?
    78  e506 f002               		BEQ SCAN_NEXT		; Yes, skip
    79                          
    80                          ;		----------------------- Normal key
    81                          
    82  e508 85a6               		STA Key_Image		; Store the key
    83                          
    84  e50a 68                 SCAN_NEXT	PLA			; Restore value from keyboard scan for next loop
    85  e50b ca                 SCAN_NEXT2	DEX			; Decrement keyboard table offset
    86  e50c f008               		BEQ SCAN_GOT		; If 0 we have completed the entire matrix...Process Key Image
    87                          
    88  e50e 88                 		DEY			; Next COLUMN
    89  e50f d0d6               		BNE SCAN_COL		; Go back up for next column bit
    90                          
    91                          ;		------------------------ Completed all bits in ROW, Increment ROW
    92                          
    93  e511 ee10e8             SCAN_NEXT3	INC PIA1_Port_A		; Next Keyboard ROW
    94  e514 d0ba               		BNE SCAN_ROW		; More? Yes, loop back
    95                          
    96                          ;		------------------------ Process Key Image
    97                          
    98  e516 a5a6               SCAN_GOT	LDA Key_Image		; Key Image
    99  e518 c597               		CMP KEYPRESSED		; Current Key Pressed: 255 = No Key
   100  e51a f007               		BEQ SCAN_PRESS		; If key is the same then it's being held down
   101                          
   102  e51c a210               		LDX #$10
   103  e51e 8ee903             		STX DELAY		; Repeat Delay Counter
   104  e521 d033               		BNE SCAN_REC
   105                          
   106                          
   107  e523 2cee03             SCAN_PRESS	BIT RPTFLG		; Check Repeat Flag: $80 = Repeat, $40 = disable
   108  e526 3020               		BMI SCAN_DELAY2
   109  e528 705d               		BVS SCAN_OUT		; Exit
   110  e52a c9ff               		CMP #$FF		; No key?
   111  e52c f059               		BEQ SCAN_OUT		; Exit
   112  e52e c914               		CMP #$14
   113  e530 f00c               		BEQ SCAN_DELAY
   114  e532 c920               		CMP #$20
   115  e534 f008               		BEQ SCAN_DELAY
   116  e536 c91d               		CMP #$1D
   117  e538 f004               		BEQ SCAN_DELAY
   118  e53a c911               		CMP #$11
   119  e53c d049               		BNE SCAN_OUT		; Exit
   120                          
   121  e53e aee903             SCAN_DELAY	LDX DELAY		; Repeat Delay Counter
   122  e541 f005               		BEQ SCAN_DELAY2
   123  e543 cee903             		DEC DELAY		; Repeat Delay Counter
   124  e546 d03f               		BNE SCAN_OUT		; Exit
   125                          
   126  e548 ceea03             SCAN_DELAY2	DEC KOUNT		; Repeat Speed Counter
   127  e54b d03a               		BNE SCAN_OUT		; Exit
   128  e54d a204               		LDX #$04
   129  e54f 8eea03             		STX KOUNT		; Repeat Speed Counter
   130  e552 a69e               		LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   131  e554 d031               		BNE SCAN_OUT		; Exit
   132                          
   133  e556 8597               SCAN_REC	STA KEYPRESSED		; Current Key Pressed: 255 = No Key
   134  e558 c9ff               		CMP #$FF		; No Key?
   135  e55a f02b                		BEQ SCAN_OUT		; Yes, exit
   136                          
   137                          		!if CRUNCH=0 {
   138  e55c ea                 			NOP		; These NOPs are here to remove the code
   139  e55d ea                 			NOP		; used to handle SHIFTED number keys.
   140  e55e ea                 			NOP		; It appears the Business Keyboard scanner (80-column machines)
   141  e55f ea                 			NOP		; was modified for Graphic Keyboard (40-column machines).
   142  e560 ea                 			NOP
   143  e561 ea                 			NOP
   144  e562 ea                 			NOP
   145                          		}
   146  e563 4698                   		LSR KEYFLAGS		;Flag: Print Shifted Chars.
   147  e565 9013                   		BCC SCAN_NORM		;l_e57a
   148                          		!if CRUNCH=0 {
   149  e567 ea                 			NOP		; See above.
   150  e568 ea                 			NOP
   151  e569 ea                 			NOP
   152  e56a ea                 			NOP
   153  e56b ea                 			NOP
   154  e56c ea                 			NOP
   155  e56d ea                 			NOP
   156  e56e ea                 			NOP
   157  e56f ea                 			NOP
   158  e570 ea                 			NOP
   159  e571 ea                 			NOP
   160  e572 ea                 			NOP
   161  e573 ea                 			NOP
   162  e574 ea                 			NOP
   163  e575 ea                 			NOP
   164  e576 ea                 			NOP
   165  e577 ea                 			NOP
   166                          		}
   167                          
   168  e578 0980               SCAN_SHIFT	ORA #$80		; Set upper bit for Graphics Symbol
   169                          
   170                          ;		----------------------- Put the KEY into the Buffer (Key in accumulator) [$E57A]
   171                          
   172                          SCAN_NORM
   173                          
   174                          !IF ESCCODES=1 { JMP EUROSWAP }		; Check if Eurokeys need swapping
   175                          
   176  e57a a69e               SCAN_NORM2	LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   177  e57c eceb03             		CPX XMAX		; Size of Keyboard Buffer
   178  e57f b006               		BCS SCAN_OUT		; Exit if buffer full
   179  e581 9d6f02             		STA KEYD,X		; Put the key into the buffer
   180  e584 e8                 		INX			; Increment character count
   181  e585 869e               		STX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   182                          

; ******** Source: editrom40.asm
  1012  e587 60                 }		; Graphic Keyboard
  1013                          !IF KEYSCAN=1 { !SOURCE "keyscan-b.asm" }		; Business Keyboard
  1014                          !IF KEYSCAN=2 { !SOURCE "keyscan-din.asm" }		; German DIN Keyboard
  1015                          !IF KEYSCAN=3 { !SOURCE "keyscan-c64.asm" }		; C64 Keyboard  (future implementation)
  1016                          !IF KEYSCAN=4 { !SOURCE "keyscan-cbm2.asm" }		; CBM2 Keyboard (future implementation)
  1017                          
  1018                          ;*********************************************************************************************************
  1019                          ;** JUMP_TO_TAB [E588]
  1020                          ;** Tab positions are stored in a table of 80 bits (10 bytes). 
  1021                          ;*********************************************************************************************************
  1022                          
  1023  e588 98                 CHECK_TAB	TYA
  1024  e589 2907               		AND #$07				; Only look at lower 3 bits (values 0 to 7)
  1025  e58b aa                 		TAX
  1026  e58c bddce7             		LDA POWERSOF2,X				; GetTable of BIT position values
  1027  e58f 8def03             		STA TABS   				; Table of 80 bits to set TABs
  1028  e592 98                 		TYA	
  1029  e593 4a                 		LSR
  1030  e594 4a                 		LSR
  1031  e595 4a                 		LSR
  1032  e596 aa                 		TAX
  1033  e597 bdf003             		LDA TABS+1,X				; Get the BITS for that group of tabs (Table of 80 bits to set TABs)
  1034  e59a 2cef03             		BIT TABS   				; Set FLAG for testing???? (Table of 80 bits to set TABs)
  1035  e59d 60                 		RTS
  1036                          
  1037                          ;################################################################################
  1038                          ;## WIN_CLEAR  [$RELOCATED]  (Called from Jump Table) 
  1039                          ;################################################################################
  1040                          ; When the Soft40 option is enabled we must relocate this routine here since it will not fit in it's normal
  1041                          ; location. When finished we must jump back to the end of it's normal position
  1042                          
  1043                          !IF SS40=1 {
  1044                          		!SOURCE "editrom40cls.asm" 
  1045                          		JMP CURSOR_HOME				;The WIN_CLR routine flows into the HOME routine
  1046                          }
  1047                          
  1048                          ;################################################################################
  1049  e59e aaaaaaaaaaaaaaaa...		!fill $e600-*,$aa	;########################################
  1050                          ;################################################################################
  1051                          
  1052                          ;*********************************************************************************************************
  1053                          ;** IRQ_END  [E600] (Called from Jump Table) - FIXED ENTRY POINT!
  1054                          ;** The IRQ routine jumps here when completed. Do not modify this routine!
  1055                          ;*********************************************************************************************************
  1056                          !FILL $e600-*,$aa ;FIXED ENTRY POINT! This routine must not move! It is called directly from KERNAL
  1057                          ;#########################################################################################################
  1058                          
  1059  e600 68                 IRQ_END		PLA
  1060  e601 a8                 		TAY
  1061  e602 68                 		PLA
  1062  e603 aa                 		TAX
  1063  e604 68                 		PLA
  1064  e605 40                 		RTI
  1065                          
  1066                          ;*********************************************************************************************************
  1067                          ;** RESTORE_CHR_AT_CRSR  [E606]
  1068                          ;** This routine is called to put the character back at the cursor position.
  1069                          ;** It is called to put the initial character on the screen and as part of the cursor blinking routine.
  1070                          ;** NOTE: ColourPET: DOES NOT set/change COLOUR ATTRIBUTE!
  1071                          ;*********************************************************************************************************
  1072                          
  1073                          RESTORE_CHR_AT_CRSR
  1074  e606 a4c6               		LDY CursorCol  				; Cursor Column on Current Line
  1075  e608 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
  1076  e60a a902               		LDA #$02
  1077  e60c 85a8               		STA BLNCT  				; Timer: Countdown to Toggle Cursor
  1078  e60e 60                 		RTS
  1079                          
  1080                          ;*********************************************************************************************************
  1081                          ;** CRT_SET_TEXT  [$E60F]  (Called from Jump Table) 
  1082                          ;** TEXT MODE lower case, upper case and limited graphics.
  1083                          ;** Characters take 10 scanlines (normally)
  1084                          ;*********************************************************************************************************
  1085                          
  1086  e60f a9b1               CRT_SET_TEXT	LDA #<CRT_CONFIG_TEXT			; Point to CRTC Table
  1087  e611 a2e7               		LDX #>CRT_CONFIG_TEXT			; Point to CRTC Table
  1088  e613 a00e               		LDY #$0E				; Character Set = TEXT
  1089  e615 d006               		BNE CRT_PROGRAM
  1090                          
  1091                          ;*********************************************************************************************************
  1092                          ;** CRT_SET_GRAPHICS  [$E617]  (Called from Jump Table) 
  1093                          ;** GRAPHICS mode has uppercase and full graphics.
  1094                          ;** Characters take 8 scanlines
  1095                          ;*********************************************************************************************************
  1096                          
  1097                          CRT_SET_GRAPHICS
  1098  e617 a9c3               		LDA #<CRT_CONFIG_GRAPHICS      		; Point to CRTC Table
  1099  e619 a2e7               		LDX #>CRT_CONFIG_GRAPHICS      		; Point to CRTC Table
  1100  e61b a00c               		LDY #$0C				; Character Set = GRAPHICS
  1101                          
  1102                          ;*********************************************************************************************************
  1103                          ;** CRT_PROGRAM  [$E61D] (Called from Jump Table)
  1104                          ;** The CRTC controller controls the parameters for generating the display on the monitor. The CRTC chip
  1105                          ;** has several registers that must be set properly according to the type of connected display. These set
  1106                          ;** characters on the line, left and right margins, lines on the screen, height of each line and
  1107                          ;** positioning of the top of the screen. The parameters are read from a table and written to the CRTC
  1108                          ;** controller chip. The VIA chip is used to select which of the two fonts from the CHARACTER ROM is used.
  1109                          ;**
  1110                          ;** Parameters: Table pointer in A/X, CHRSET in Y
  1111                          ;** OPTIONS: 'SS40' uses new routine in upper rom
  1112                          ;*********************************************************************************************************
  1113                          
  1114                          CRT_PROGRAM
  1115                          ;		--------------------- Set 'Character Set' [$E61D]
  1116                          
  1117  e61d 85c7               		STA SAL					; Pointer LO: Tape Buffer/ Screen Scrolling
  1118  e61f 86c8               		STX SAL+1				; Pointer HI
  1119  e621 ad4ce8             		LDA VIA_PCR				; Get current register byte VIA Register C - CA2	CHIP 
  1120  e624 29f0               		AND #$f0				; mask out lower nibble
  1121  e626 85d1               		STA FNLEN				; save it to Temp Variable
  1122  e628 98                 		TYA					; Move 'Character Set' byte to A
  1123  e629 05d1               		ORA FNLEN				; update lower nibble in Temp Variable
  1124  e62b 8d4ce8             		STA VIA_PCR				; write it back to VIA Register C - CA2			CHIP
  1125                          
  1126                          ;		--------------------- Write to the CRTC controller [$E62E]
  1127                          
  1128  e62e a011               		LDY #$11				; Number of bytes to copy = 17
  1129                          
  1130  e630 b1c7               CRT_LOOP	LDA (SAL),Y				; LOOP[   Pointer: Tape Buffer/ Screen Scrolling
  1131  e632 8c80e8             		STY CRT_Address				;   Select the register to update 6545/6845 CRT		CHIP
  1132  e635 8d81e8             		STA CRT_Status				;   Write to the register
  1133  e638 88                 		DEY					;   Next character
  1134  e639 10f5               		BPL CRT_LOOP				; ] Loop for more
  1135  e63b 60                 		RTS
  1136                          
  1137                          ;*********************************************************************************************************
  1138                          ;** ChrOutMarginBeep  [E68C]
  1139                          ;** Checks the cursor position and rings the BELL if near the end of the line
  1140                          ;*********************************************************************************************************
  1141                          
  1142                          ChrOutMarginBeep
  1143  e63c 2002e2             		JSR CHROUT_SCREEN			; Output character to screen (chr code in A)
  1144  e63f aa                 		TAX					; Save the character to X
  1145  e640 a5d5               		LDA RightMargin   			; Physical Screen Line Length
  1146  e642 38                 		SEC
  1147  e643 e5c6               		SBC CursorCol   			; Cursor Column on Current Line
  1148  e645 c905               		CMP #5					; Are we at the 5th last character on the line?
  1149  e647 d039               		BNE BELLDONE				; No, exit out
  1150  e649 8a                 		TXA					; Yes, reload the character to print
  1151  e64a c91d               		CMP #$1D				; Is it <CRSR-RIGHT>?
  1152  e64c f006               		BEQ BEEP_BEEP				; Yes, do Double BELL
  1153  e64e 297f               		AND #$7F				; Mask off HI BIT
  1154  e650 c920               		CMP #$20				; Is it a control code?
  1155  e652 902e               		BCC BELLDONE				; Yes, exit out
  1156                          
  1157                          ;*********************************************************************************************************
  1158                          ;** BEEP / BEEP_BEEP [E654]/[E657]
  1159                          ;** Rings the BELL
  1160                          ;*********************************************************************************************************
  1161                          
  1162  e654 2057e6             BEEP_BEEP	JSR BEEP				; Double BELL
  1163                          BEEP							; Single BELL
  1164                          
  1165                          !if SILENT=0 {
  1166  e657 acec03             		LDY CHIME				; Chime Time FLAG
  1167                          } ELSE {
  1168                          		!IF CRUNCH=0 { NOP }			; To keep code aligned
  1169                          		RTS
  1170                          }
  1171                          
  1172                          !IF ESCCODES=1 {
  1173                          		LDA BELLMODE				; Flag to Enable BELL
  1174                          		BPL BELLENABLED				; Enabled, so do it
  1175                          		RTS
  1176                          }
  1177  e65a f026               BELLENABLED	BEQ BELLDONE
  1178  e65c a910               		LDA #16
  1179  e65e 8d4be8             		STA VIA_ACR
  1180  e661 a90f               		LDA #15
  1181  e663 8d4ae8             		STA VIA_Shift
  1182  e666 a207               		LDX #7					; Size of BELL table
  1183  e668 bdd4e7             BELLOOP1	LDA SOUND_TAB-1,X			; LOOP[
  1184  e66b 8d48e8             		STA VIA_Timer_2_Lo
  1185  e66e adec03             		LDA CHIME				; Chime Time
  1186                          
  1187  e671 88                 BELLOOP2	DEY					; LOOP[[
  1188  e672 d0fd               		BNE BELLOOP2				; ]] Delay loop
  1189  e674 38                 		SEC
  1190  e675 e901               		SBC #1
  1191  e677 d0f8               		BNE BELLOOP2				; ]] Delay loop
  1192  e679 ca                 		DEX
  1193  e67a d0ec               		BNE BELLOOP1				; ] Delay loop
  1194  e67c 8e4ae8             		STX VIA_Shift
  1195  e67f 8e4be8             		STX VIA_ACR
  1196  e682 60                 BELLDONE	RTS
  1197                          
  1198                          ;*********************************************************************************************************
  1199                          ;** INIT_EDITOR  [E683]
  1200                          ;** Initializes the Editor. Clears Clock. Sets IRQ Vector. Sets Keyboard buffer size. Clears TABs.
  1201                          ;** Sets zero-page locations. And finally, chimes the BELL.
  1202                          ;*********************************************************************************************************
  1203                          
  1204  e683 a97f               INIT_EDITOR	LDA #$7f
  1205  e685 8d4ee8             		STA VIA_IER				; VIA, Register E - I/O Timers
  1206  e688 a26d               		LDX #$6d
  1207  e68a a900               		LDA #0
  1208  e68c 958d               INITED1		STA JIFFY_CLOCK,X			; Clear Real-Time Jiffy Clock (approx) 1/60 Sec
  1209  e68e ca                 		DEX
  1210  e68f 10fb               		BPL INITED1
  1211  e691 a20a               		LDX #$0A				; 10 bytes to set
  1212  e693 9df003             INITED2		STA TABS+1,X				; LOOP[   TAB table $03F0
  1213  e696 ca                 		DEX					;   Next position
  1214  e697 10fa               		BPL INITED2				; ] Loop back for more
  1215  e699 8dee03             		STA RPTFLG				; Repeat Flag
  1216                          
  1217                          ;		--------------------------------------- Set IRQ Vector - Normally $E455 or $E900 for Execudesk
  1218                          
  1219                          !IF EXECUDESK=1 {
  1220                          		LDA #<IRQ_EDESK				; Execudesk IRQ Vector LO
  1221                          		STA CINV
  1222                          		LDA #>IRQ_EDESK				; Execudesk IRQ Vector HI
  1223                          		STA CINV+1
  1224                          } ELSE {
  1225  e69c a955               		LDA #<IRQ_NORMAL			; Normal IRQ Vector LO
  1226  e69e 8590               		STA CINV
  1227  e6a0 a9e4               		LDA #>IRQ_NORMAL			; Normal IRQ Vector HI
  1228  e6a2 8591               		STA CINV+1
  1229                          }
  1230                          
  1231                          ;		--------------------------------------- Init SS40
  1232                          
  1233                          !IF SS40=1 {
  1234                          	!IF HARD4080=1 {
  1235                          		LDA #1					; 40/80 Switcher board INSTALLED
  1236                          		STA SCN4080BOARD
  1237                          	} ELSE {
  1238                          		LDA #0					; 40/80 Switcher board NOT installed
  1239                          		STA SCN4080BOARD	
  1240                          	}
  1241                          
  1242                          	!IF SS40MODE=80 {
  1243                          		JSR SS40_INIT80				; Initialize Switchable Soft-40 to 80 columns
  1244                          	} ELSE {
  1245                          		JSR SS40_INIT40				; Initialize Switchable Soft-40 to 40 columns
  1246                          	}
  1247                          }
  1248                          ;		--------------------------------------- Continue
  1249                          
  1250  e6a4 a903               		LDA #$03				; 3=Screen
  1251  e6a6 85b0               		STA DFLTO  				; Set Default Output (CMD) to Screen
  1252  e6a8 a90f               		LDA #$0F
  1253  e6aa 8d10e8             		STA PIA1_Port_A 			; Keyboard ROW select [$E810]
  1254  e6ad 0a                 		ASL
  1255  e6ae 8d40e8             		STA VIA_Port_B				; VIA Register 0 (flags) [$E840]
  1256  e6b1 8d42e8             		STA VIA_DDR_B				;
  1257  e6b4 8e22e8             		STX PIA2_Port_B				;
  1258  e6b7 8e45e8             		STX VIA_Timer_1_Hi			;
  1259                          
  1260  e6ba a93d               		LDA #$3D
  1261  e6bc 8d13e8             		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt) [$E813]
  1262  e6bf 2c12e8             		BIT PIA1_Port_B 			; Keyboard COL read
  1263                          
  1264  e6c2 a93c               		LDA #$3C
  1265  e6c4 8d21e8             		STA PIA2_Cont_A
  1266  e6c7 8d23e8             		STA PIA2_Cont_B
  1267  e6ca 8d11e8             		STA PIA1_Cont_A
  1268  e6cd 8e22e8             		STX PIA2_Port_B
  1269                          
  1270  e6d0 a90c               		LDA #$0C
  1271  e6d2 8d4ce8             		STA VIA_PCR 				; VIA Register C (cb2) [$E84C]
  1272  e6d5 85a8               		STA BLNCT  				; Timer: Countdown to Toggle Cursor
  1273  e6d7 85a7               		STA Blink  				; Cursor Blink enable: 0 = Flash Cursor
  1274                          
  1275  e6d9 a909               		LDA #$09
  1276  e6db 8deb03             		STA XMAX  				; Max keyboard buffer size (40 col)
  1277                          
  1278  e6de a910               		LDA #$10
  1279  e6e0 8dec03             		STA CHIME 				; Chime Time 0=off (40col)
  1280  e6e3 8de903             		STA DELAY				; Repeat key countdown (40col)
  1281  e6e6 8dea03             		STA KOUNT 				; Delay between repeats (40col)
  1282                          
  1283                          ;		--------------------------------------- Patches for new features here
  1284                          
  1285                          !IF ESCCODES=1 {
  1286                          		LDA #1					; 1=Enabled
  1287                          		STA BELLMODE				; Flag to Enable BELL
  1288                          }
  1289                          
  1290                          !IF AUTORUN=1 {	JSR AUTOSTART }				; Do Autostart Prep
  1291                          
  1292  e6e9 60                 		RTS
  1293                          
  1294                          ;************** Check for screen scrolling [$E6EA]
  1295                          
  1296                          ESCAPE_W						; Esc-w Scroll Down
  1297                          WIN_SCROLL_DN
  1298  e6ea a6d8               		LDX CursorRow  				; Get Current Cursor Physical Line Number
  1299  e6ec e8                 		INX					; Next line
  1300  e6ed e018               		CPX #ROWS-1				; Will it be the last line on the screen (24)?
  1301  e6ef f033               		BEQ CLEAR_SCREEN_LINE 			; Yes, Clear a screen line and move cursor to start of line
  1302  e6f1 9003               		BCC SCROLL_DOWN				; No it's less, Scroll screen lines DOWN
  1303  e6f3 4cc4e1             		JMP SCROLL_UP				; No it's more, Scroll screen up
  1304                          
  1305                          ;*********************************************************************************************************
  1306                          ;** SCROLL_DOWN  [$E6F6]
  1307                          ;** Scrolls the current screen DOWN. 
  1308                          ;** Used to INSERT a blank line. Scrolls all lines from bottom of screen up to current line
  1309                          ;** stored in 'CursorRow'.  Adjusts ALL Line Links.
  1310                          ;*********************************************************************************************************
  1311                          
  1312  e6f6 a217               SCROLL_DOWN	LDX #ROWS-2				; Start at bottom of the screen (ROW 24 minus 1)
  1313  e6f8 b5e1               SD_LOOP1 	LDA LineLinkTable+1,X			; LOOP[  Get NEXT line's HI byte from Line Link table
  1314  e6fa 0980               		ORA #$80				;   Make sure HI bit is set
  1315  e6fc 85c8               		STA SAL+1				;   Store it to destination screen pointer
  1316  e6fe b4e0               		LDY LineLinkTable,X			;   Get CURRENT line's HI byte from Line Link Table
  1317  e700 3002               		BMI SD_SKIP				;   Is HI bit SET? Yes, skip ahead
  1318  e702 297f               		AND #$7F				;   No, CLEAR HI bit
  1319  e704 95e1               SD_SKIP		STA LineLinkTable+1,X			;   Store it back to Line link table
  1320  e706 98                 		TYA
  1321  e707 0980               		ORA #$80				;   SET HI bit
  1322  e709 85c5               		STA ScrPtr+1				;   Store to screen line SOURCE pointer
  1323                          
  1324  e70b a027               !IF SS40=0 {	LDY #COLUMNS-1				;   Hard-coded Screen Width-1 (ie: 39)
  1325                            } ELSE   {    LDY SCNWIDTH				;   Soft Screen Width
  1326                          		DEY }					;   -1
  1327                          
  1328  e70d bd99e7             		LDA Line_Addr_Lo+1,X			;   Get screen's LO byte from Screen line address table
  1329  e710 85c7               		STA SAL    				;   Store it to DESTINATION screen pointer
  1330  e712 bd98e7             		LDA Line_Addr_Lo,X			;   Get Previous lines LO byte from Screen line address table
  1331  e715 85c4               		STA ScrPtr    				;   Store it to the SOURCE pointer
  1332                          
  1333                          ;		--------------------------------------- Copy the line
  1334                          
  1335  e717 b1c4               SD_LOOP2	LDA (ScrPtr),Y 				;   LOOP[[  Read character from screen
  1336  e719 91c7               		STA (SAL),Y				;     Write to new destination
  1337  e71b 88                 		DEY					;     Next character
  1338  e71c 10f9               		BPL SD_LOOP2				;   ]] Loop back for more
  1339  e71e ca                 		DEX					;   Next line (above)
  1340  e71f e4d8               		CPX CursorRow   			;   Current Cursor Physical Line Number
  1341  e721 d0d5               		BNE SD_LOOP1				; ] Loop back for more
  1342  e723 e8                 		INX
  1343                          
  1344                          ;*********************************************************************************************************
  1345                          ;** CLEAR_SCREEN_LINE  [$E724]
  1346                          ;** Clears one line of the screen. X holds line#. Adjusts Line Link entry for specified line.
  1347                          ;*********************************************************************************************************
  1348                          
  1349                          CLEAR_SCREEN_LINE
  1350  e724 b5e0               		LDA LineLinkTable,X			; Get current line's Line Link entry
  1351  e726 0980               		ORA #$80				; Make sure HI BIT is set
  1352  e728 85c5               		STA ScrPtr+1				; Store it to the screen pointer
  1353  e72a 297f               		AND #$7F				; Clear the HI BIT again
  1354  e72c 95e0               		STA LineLinkTable,X			; Store it to the Line Link Table
  1355  e72e bd98e7             		LDA Line_Addr_Lo,X			; Get screen line's address LO byte from ROM table
  1356  e731 85c4               		STA ScrPtr    				; Store it to screen pointer LO
  1357                          
  1358  e733 a027               !IF SS40=0 {	LDY #COLUMNS-1				; Hard-coded Screen Width-1
  1359                             } ELSE {	LDY SCNWIDTH				; Soft Screen Width
  1360                          		DEY }					; -1
  1361                          
  1362  e735 a920               		LDA #$20				; <SPACE>
  1363                          
  1364  e737 91c4               CSL_LOOP	STA (ScrPtr),Y				; LOOP[    Write SPACE to screen
  1365  e739 88                 		DEY					;   Next position
  1366  e73a 10fb               		BPL CSL_LOOP				; ] Loop back for more
  1367  e73c 4c71e0             		JMP CURSOR_LM				; Cursor to start of line
  1368                          
  1369                          ;*********************************************************************************************************
  1370                          ;** Keyboard Decoding Table  [E6D1]
  1371                          ;*********************************************************************************************************
  1372                          

; ******** Source: keyboard.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Selection
     2                          ; ================
     3                          ; This adds the appropriate keyboard matrix or matrices depending on options:
     4                          ; KEYSCAN=n  -- which keyboard scanning routine is used
     5                          ; KEYBOARD=n -- to select the matrix layout
     6                          ;
     7                          ; Note: Not all keyboards are defined for all options! Please check source
     8                          ;------------------------------------------------------------------------------
     9                          

; ******** Source: keyboard-tables1.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Tables for KEYSCAN-N, KEYSCAN-B scanner code
     2                          ; ================
     3                          ; 
     4                          ; Notes:
     5                          ;	Modifier Keys: 00 = Shift, 10 = Repeat, 80 = CTRL
     6                          ;	Special Codes: Bit 7 set (+$80) = Unshiftable, FF = No Key
     7                          ;       Labelling:
     8                          ;	   KP = Keypad, S- = Shift , GR- = Graphic Code, NONE = No Key
     9                          ;          CTRL- = CTRL+key , SHC- = Shift-CTRL+key, A- = Accent
    10                          
    11                          KEYBOARD_NORMAL
    12                          
    13                          ;---------- Normal/Graphic Keyboard - QWERTY Layout (chicklet or standard type)
    14                          ;
    15                          !IF KEYBOARD=0 {
    16                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    17                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    18  e73f 3d2e10033c205b12   !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A
    19  e747 2d30003eff5d4000   !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
    20  e74f 2b32ff3f2c4e5658   !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
    21  e757 33310d3b4d42435a   !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
    22  e75f 2a35ff3a4b484653   !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
    23  e767 3634ff4c4a474441   !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
    24  e76f 2f38ff5049595257   !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
    25  e777 39375e4f55544551   !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
    26  e77f 141109295c272422   !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
    27  e787 1d135f2826252321   !byte $1d,$13,$5f,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J
    28                          }
    29                          
    30                          ;---------- Business Keyboard - QWERTY Layout
    31                          ;
    32                          !IF KEYBOARD=1 {
    33                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    34                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    35                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A
    36                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
    37                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
    38                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
    39                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
    40                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
    41                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
    42                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
    43                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
    44                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
    45                          }
    46                          
    47                          ;---------- Business Keyboard - German DIN, QWERTZ (Version 1) Layout
    48                          ;
    49                          !IF KEYBOARD=2 {
    50                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES
    51                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    52                          !byte $16,$04,$40,$03,$39,$36,$33,$5F ; CTRL-V CTRL-D @      STOP   9      6      3      BK-ARR ROW0/A  ..x....x
    53                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   M      SPACE  x      RVS    ROW1/B  ........
    54                          !byte $B2,$80,$0F,$01,$2C,$4E,$56,$59 ; KP 2   CTRL   CTRL-O KP 0   ,      n      v      y      ROW2/C  .x.x...x <- $80=CTRL (was $10=REPEAT)
    55                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D  ........ <- $00=SHIFT
    56                          !byte $B4,$5B,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E  .x......
    57                          !byte $14,$50,$49,$3A,$5A,$52,$57,$09 ; DEL    p      i      :      z      r      w      TAB    ROW5/F  ...xx...
    58                          !byte $B6,$5D,$4C,$0D,$4A,$47,$44,$41 ; KP 6   ]      l      RETURN j      g      d      a      ROW6/G  .x......
    59                          !byte $B5,$5C,$4B,$3B,$48,$46,$53,$1B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H  .......x
    60                          !byte $B9,$06,$5E,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I  ..x.....
    61                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J  ........
    62                          }
    63                          
    64                          ;---------- C64/VIC-20 Keyboard
    65                          ;
    66                          ; Keyboard will plug directly into the PET keyboard connector.
    67                          ; It is electrically compatible, but only uses an 8x8 matrix of keys.
    68                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
    69                          ;
    70                          ; * Code Change: SHIFT=01 with 00
    71                          ; * Reassign   : POUND as \=5C, CTRL as RVS=12, C= as ESC=9B
    72                          ; * Reassign   : F1 as TEXT=0E, F3 as DELETE LINE=15, F5 as ERASE TO START=16, F7 as SCROLL DOWN=19
    73                          
    74                          !IF KEYBOARD=3 {
    75                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    76                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    77                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A
    78                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B
    79                          !byte $19,$13,$2D,$30,$38,$36,$34,$32 ; F7     HOME   -      0      8      6      4      2      ROW2/C
    80                          !byte $16,$5E,$40,$4F,$55,$54,$45,$51 ; F5     UP-ARR @      O      U      T      E      Q      ROW3/D
    81                          !byte $15,$3D,$3A,$4B,$48,$46,$53,$9B ; F3     =      :      K      H      F      S      C=     ROW4/E
    82                          !byte $0E,$00,$2E,$4D,$42,$43,$5A,$20 ; F1     SHIFT  .      M      B      C      Z      SPACE  ROW5/F
    83                          !byte $11,$2F,$2C,$4E,$56,$58,$00,$03 ; DOWN   /      ,      N      V      X      SHIFT  STOP   ROW6/G
    84                          !byte $1D,$3B,$4C,$4A,$47,$44,$41,$12 ; RIGHT  ;      L      J      G      D      A      CTRL   ROW7/H
    85                          !byte $0D,$2A,$50,$49,$59,$52,$57,$DF ; RETURN *      P      I      Y      R      W      BK-ARR ROW8/I
    86                          !byte $14,$5C,$2B,$39,$37,$35,$33,$31 ; DEL    POUND  +      9      7      5      3      1      ROW9/J
    87                          }
    88                          
    89                          ;---------- Business Keyboard - Modified QWERTY Layout - BSJG
    90                          ;
    91                          ; This is a B keyboard with re-arranged layout to make it closer to C64 keyboard
    92                          ; ESC moved to top left. Cursor keys to bottom CLR/HOME and INS/DEL moved to top row
    93                          ; REPEAT moved to bottom left.
    94                          ;
    95                          !IF KEYBOARD=4 {
    96                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    97                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== ======
    98                          !byte $16,$04,$3A,$14,$39,$36,$33,$9B ; CTRL-V CTRL-D :      DEL    9      6      3      ESC    ROW0/A 
    99                          !byte $B1,$2F,$15,$1D,$4D,$20,$58,$10 ; KP 1   /      CTRL-U RIGHT  m      SPACE  x      REPT   ROW1/B 
   100                          !byte $B2,$11,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   DOWN   CTRL-O KP 0   ,      n      v      z      ROW2/C
   101                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      n      c      SHIFT  ROW3/D
   102                          !byte $B4,$DB,$4F,$DF,$55,$54,$45,$51 ; KP 4   [      o      BK-ARR u      t      e      q      ROW4/E
   103                          !byte $DE,$50,$49,$DD,$59,$52,$57,$09 ; UP-ARR p      i      ]      y      r      w      TAB    ROW5/F
   104                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   105                          !byte $B5,$3B,$4B,$DC,$48,$46,$53,$03 ; KP 5   ;      k      \      h      f      s      STOP   ROW7/H
   106                          !byte $B9,$06,$12,$B7,$B0,$37,$34,$31 ; KP     CTRL-F RVS    KP 7   0      7      4      1      ROW8/I
   107                          !byte $05,$0E,$13,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N HOME   KP 8   -      8      5      2      ROW9/J
   108                          }
   109                          
   110                          ;---------- Graphic Keyboard - Modified QWERTY Layout - NSJG
   111                          ;
   112                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none,
   113                          ; so the "@" key is used instead as it occupies the position an ESC key would normally be. The BACKARROW
   114                          ; key will become the "@" symbol so that the DOS wedge is usable (BACKARROW is rarely used).
   115                          ;
   116                          !IF KEYBOARD=5 {
   117                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   118                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   119                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    
   120                          !byte $2d,$30,$00,$3e,$ff,$5d,$9b,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      ESC    SHIFT  @ replaced with ESC
   121                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x
   122                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z
   123                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s
   124                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a
   125                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w
   126                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q
   127                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "
   128                          !byte $1d,$13,$40,$28,$26,$25,$23,$21 ; RIGHT  HOME   @      (      &      %      #      !      BACKARROW replaced by @
   129                          }
   130                          
   131                          ;---------- Business Keyboard - QWERTZ Layout
   132                          ;
   133                          !IF KEYBOARD=6 {
   134                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   135                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   136                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0 
   137                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1 
   138                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$59 ; KP 2   RPT    CTRL-O KP 0   ,      n      v      y      ROW2 
   139                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3
   140                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   ]      o      DOWN   u      t      e      q      ROW4 
   141                          !byte $14,$50,$49,$DC,$5A,$52,$57,$09 ; DEL    p      i      @      z      r      w      TAB    ROW5 
   142                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   [      l      RETURN j      g      d      a      ROW6
   143                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   \      k      ;      h      f      s      ESC    ROW7
   144                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8
   145                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9
   146                          }
   147                          
   148                          ;----------- Business Keyboard - French AZERTY Layout
   149                          ;
   150                          !IF KEYBOARD=7 {
   151                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   152                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   153                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A
   154                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
   155                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
   156                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   157                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
   158                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
   159                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   160                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
   161                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   162                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   163                          }
   164                          
   165                          ;----------- CBM-II (B-Series, P-Series) - QWERTY Layout
   166                          ;
   167                          ; The CBM-II keyboard has a 16*6 matrix, so it requires a hardware modification to work on the PET,
   168                          ; and a small modification to the keyboard scanning routine.
   169                          ; It also has many extra keys with no equivilent function, and so will have some non-functioning keys.
   170                          ;
   171                          ; *** WORK IN PROGRESS!!!!!!!
   172                          ;
   173                          !IF KEYBOARD=8 {
   174                          ;     C0  C1  C2  C3  C4  C5    COL0   COL1   COL2   COL3   COL4   COL5   NOTES 
   175                          ;     === === === === === ===   ====== ====== ====== ====== ====== ====== =====
   176                          !BYTE $E0,$1B,$09,$FF,$00,$01 ; F1     ESCAPE TAB    NONE   SHIFT  CTRL   ROW0/A
   177                          !BYTE $E1,$31,$51,$41,$5A,$FF ; F2     1      Q      A      Z      NONE   ROW1/B
   178                          !BYTE $E2,$32,$57,$53,$58,$43 ; F3     2      W      S      X      C      ROW2/C
   179                          !BYTE $E3,$33,$45,$44,$46,$56 ; F4     3      E      D      F      V      ROW3/D
   180                          !BYTE $E4,$34,$52,$54,$47,$42 ; F5     4      R      T      G      B      ROW4/E
   181                          !BYTE $E5,$35,$36,$59,$48,$4E ; F6     5      6      Y      H      N      ROW5/F
   182                          !BYTE $E6,$37,$55,$4A,$4D,$20 ; F7     7      U      J      M      SPACE  ROW6/G
   183                          !BYTE $E7,$38,$49,$4B,$2C,$2E ; F8     8      I      K      ,      .      ROW7/H
   184                          !BYTE $E8,$39,$4F,$4C,$3B,$2F ; F9     9      O      L      ;      /      ROW8/I
   185                          !BYTE $E9,$30,$2D,$50,$5B,$27 ; F10    0      -      P      [      '      ROW9/J
   186                          !BYTE $11,$3D,$5F,$5D,$0D,$DE ; DOWN   =      _      ]      RETURN PI     ROW10/K
   187                          !BYTE $91,$9D,$1D,$14,$02,$FF ; UP     LEFT   RIGHT  DEL    CMDR   NONE   ROW11/L
   188                          !BYTE $13,$3F,$37,$34,$31,$30 ; HOME   ?      7      4      1      0      ROW12/M
   189                          !BYTE $12,$04,$38,$35,$32,$2E ; RVS    CE     8      5      2      .      ROW13/N
   190                          !BYTE $8E,$2A,$39,$36,$33,$30 ; GRAPH  *      9      6      3      00     ROW14/O
   191                          !BYTE $03,$2F,$2D,$2B,$0D,$FF ; STOP   /      -      +      ENTER  NONE   ROW15/P
   192                          }
   193                          
   194                          ;----------- Normal/Graphic Keyboard - Modified QWERTY Layout with [ESC] modification
   195                          ;
   196                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none.
   197                          ; This layout changes the BACKARROW to ESC.
   198                          ;
   199                          !IF KEYBOARD=9 {
   200                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   201                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   202                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A
   203                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
   204                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   205                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   206                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   207                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   208                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   209                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   210                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   211                          !byte $1d,$13,$1b,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J   BACKARROW replaced by @
   212                          }
   213                          
   214                          ;----------- TED Series (C116/C16/Plus4) QWERTY Layout
   215                          ;
   216                          ; The TED keyboards have different connectors depending on model. Also, the pinouts
   217                          ; do not group the ROWs and COLs so you will need to make an adapter cable.
   218                          ; TED keyboards have 4 separate cursor keys meaning no SHIFT is needed. This will likely
   219                          ; conflict with the keyboard scanner which uses the TOP BIT of the character to indicate
   220                          ; it cannot be shifted. Cursor UP and LEFT are normally shifted.
   221                          ;
   222                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
   223                          ;
   224                          ; * Code Change: SHIFT=01 with 00, CTRL with 80
   225                          ; * Reassign   : POUND as \=5C, C= as TEXT/GRAPHICS mode
   226                          ; * Reassign   : F1 as TEXT=0E, F2 as DELETE LINE=15, F3 as ERASE TO START=16, HELP as SCROLL DOWN=19
   227                          ;
   228                          ; NOTE: Pin 3=LED, Pin 4=GND
   229                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   230                          ;
   231                          !IF KEYBOARD=11 {
   232                          ;PIN: 17  14  13  2   6   8   9   16
   233                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   234                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   235                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A -
   236                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B -
   237                          !byte $31,$13,$00,$03,$20,$0E,$51,$32 ;	1      CLR    CTRL   STOP   SPACE  C=     Q      2      ROW2/C 5
   238                          !byte $33,$57,$41,$00,$5A,$53,$45,$34 ; 3      W      A      SHIFT  Z      S      E      4      ROW3/D 7
   239                          !byte $35,$52,$44,$58,$43,$46,$54,$36 ; 5      R      D      X      C      F      T      6      ROW4/E 11
   240                          !byte $37,$59,$47,$56,$42,$48,$55,$38 ; 7      Y      G      V      B      H      U      8      ROW5/F 10
   241                          !byte $39,$49,$4A,$4E,$4D,$4B,$4F,$30 ; 9      I      J      N      M      K      O      0      ROW6/G 12
   242                          !byte $11,$50,$4C,$2C,$2E,$3B,$2D,$91 ; DOWN   P      L      ,      .      :      -      UP     ROW7/H 1
   243                          !byte $9D,$2A,$3B,$2F,$1B,$3D,$2B,$1D ; LEFT   *      ;      /      ESC    =      +      RIGHT  ROW8/I 15
   244                          !byte $14,$0D,$5C,$40,$0E,$15,$16,$19 ; DEL    RETURN POUND  @      F1     F2     F3     HELP   ROW9/J 18
   245                          }
   246                          
   247                          ;----------- C128 Keyboard - Requires hardware mod for larger matrix
   248                          ;
   249                          ; This table is taken from a C128 ROM disassembly and re-formatted
   250                          ; This has not been tested! It looks like the ROWS and COLUMNS are
   251                          ; reversed compared to the PET/CBM keyboard scanner. This will either
   252                          ; require re-ordering the matrix, or re-wiring/adapting the connector.
   253                          ;
   254                          ; CHANGES:
   255                          ;           SHIFT ($01) to SHIFT ($00)
   256                          ;           CTRL  ($04) to CTRL  ($80)
   257                          ;           ALT   ($08) to SHIFT ($00)
   258                          ;           NOSCRL($FF) to SHIFT ($00)
   259                          ; PIN
   260                          ; 1   GROUND
   261                          ; 2   NO PIN (keyed)
   262                          ; 4   +5V
   263                          ; 
   264                          ; Keys not in matrix:
   265                          ;    RESTORE  = pin 1 and pin 3
   266                          ;    40/80    = pin 1 and pin 24
   267                          ;    CAPS LOCK= pin 1 and pin 25
   268                          ;
   269                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   270                          ;
   271                          !IF KEYBOARD=12 {
   272                          
   273                          ;PIN: 12  11  10  5   8   7   6   9
   274                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   275                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   276                          !byte $14,$0D,$1D,$88,$85,$86,$87,$11 ; DEL    RETURN RIGHT  .      .      .      .      DOWN   ROW0   13
   277                          !byte $33,$57,$41,$34,$5A,$53,$45,$00 ; 3      w      a      4      z      s      e      SHIFT  ROW1   19
   278                          !byte $35,$52,$44,$36,$43,$46,$54,$58 ; 5      r      d      6      c      f      t      x      ROW2   18
   279                          !byte $37,$59,$47,$38,$42,$48,$55,$56 ; 7      y      g      8      b      h      u      v      ROW3   17
   280                          !byte $39,$49,$4A,$30,$4D,$4B,$4F,$4E ; 9      i      j      0      m      k      o      n      ROW4   16
   281                          !byte $2B,$50,$4C,$2D,$2E,$3A,$40,$2C ; +      p      l      -      .      :      @      ,      ROW5   15
   282                          !byte $5C,$2A,$3B,$13,$00,$3D,$5E,$2F ; \      *      ;      HOME   SHIFT  =      ^      /      ROW6   14
   283                          !byte $31,$5F,$80,$32,$20,$02,$51,$03 ; 1      BARROW CTRL   2      SPACE  CBM    q      STOP   ROW7   20
   284                          !byte $84,$38,$35,$09,$32,$34,$37,$31 ; HELP   8      5      TAB    2      4      7      1      ROW8   21
   285                          !byte $1B,$2B,$2D,$0A,$0D,$36,$39,$33 ; ESC    +      -      LF     ENTER  6      9      3      ROW9   22
   286                          !byte $08,$30,$2E,$91,$11,$9D,$1D,$00 ; ALT    0      .      UP     DOWN   LEFT   RIGHT  NOSCRL ROW10  23

; ******** Source: keyboard.asm
    10                          }	; Graphic (Normal) Keyboard Scanner - Simple
    11                          !if KEYSCAN=1 { !source "keyboard-tables1.asm" }	; Business Keyboard Scanner - Simple with code for specific shifted keys
    12                          !if KEYSCAN=2 { !source "keyboard-tables2.asm" }	; Extended Keyboard Scanner - Two Tables (Normal and Shifted)

; ******** Source: editrom40.asm
  1373                          
  1374                          
  1375                          ;*********************************************************************************************************
  1376                          ;** SHIFT RUN/STOP string  [E721]
  1377                          ;*********************************************************************************************************
  1378                          
  1379  e78f 44cc222a0d         RUN_STRING	!byte $44,$cc,$22,$2a,$0d		; dL"*<RETURN>
  1380  e794 52554e0d           		!byte $52,$55,$4e,$0d			; run<RETURN>
  1381                          
  1382                          ;*********************************************************************************************************
  1383                          ;** Screen Line Address Table [$E798]
  1384                          ;** This codebase has line linking so there is only one screen line table for the LO bytes.
  1385                          ;** High bytes are calculated and put in the Link-link table
  1386                          ;*********************************************************************************************************
  1387                          

; ******** Source: screen0v.asm
     1                          ; PET/CBM EDIT ROM - Screen line LO address table - Screen 1 @ $8000 Video (characters)
     2                          ; ================   For CODEBASE 0
     3                          ; Variables: ROWS,COLUMNS
     4                          ; These tables are used to calculate the starting address of each line on the screen.
     5                          ; The standard screens are 40x25 and 80x25. Experimental screens can be up to 90x35.
     6                          ; 32 and 64 are included for future support of non-cbm type screens.
     7                          ; When ROWS>25 it assumes maximum 35 rows although less are supported as well.
     8                          
     9                          ;---------- 32 characters wide (32x32 = 1K RAM)
    10                          !IF COLUMNS=32 {
    11                          Line_Addr_Lo	!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    12                          		!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    13                          }
    14                          
    15                          ;---------- 40 characters wide 
    16                          !IF COLUMNS=40 {
    17  e798 00285078a0c8f018...Line_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    18  e7a8 80a8d0f820487098...		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    19                          }
    20                          
    21                          ;---------- 64 characters wide (64x32 = 2K RAM)
    22                          !IF COLUMNS=64 {
    23                          Line_Addr_Lo	!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    24                          		!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    25                          }
    26                          
    27                          ;---------- 80 characters wide 
    28                          !IF COLUMNS=80 {
    29                          Line_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0
    30                          		!byte $20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0
    31                          		!byte $40,$90,$e0,$30,$80
    32                          }
    33                          
    34                          ;---------- 90 characters wide
    35                          !IF COLUMNS=90 {
    36                          Line_Addr_Lo	!byte $00,$5a,$b4,$0e,$68,$c2,$1c,$76,$d0,$2a,$84,$de,$38,$92,$ec,$46
    37                          		!byte $a0,$fa,$54,$ea,$08,$62,$bc,$16,$70,$ca,$24,$7e,$d8,$32,$8c,$e6
    38                          		!byte $40,$9a,$f4
    39                          }

; ******** Source: editrom40.asm
  1388                          
  1389                          
  1390                          ;*********************************************************************************************************
  1391                          ;** CRTC Chip Register Setup Tables (2K ROMs) [E7B1]
  1392                          ;*********************************************************************************************************
  1393                          

; ******** Source: crtc-tables.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Table Selection
     2                          ; ================
     3                          ; Sets the CRTC Table depending on options
     4                          ; COLUMNS ---- 40 or 80 column hardware (with special cases 90 and 32)
     5                          ; SOFT40 ----- Software Defined 40-column modes
     6                          
     7                          
     8                          !IF COLUMNS=40 {

; ******** Source: crtc-reg-normal.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Tables
     2                          ; ================
     3                          ; For "normal" configurations (ie: for single main screen)
     4                          ; Sets the CRTC Table depending on options:
     5                          ; COLUMNS = 32,40,64,80,90
     6                          ;
     7                          ;======================================
     8                          ; NORMAL 4000/8000/8296/SuperPET MODELS
     9                          ;======================================
    10                          ; Common settings for "normal" machines (4000,8000,8296,SuperPET) with 12" monitor
    11                          ; NOTE: The 8296D uses a different monitor than the 8296 and requires a different register table (see below)
    12                          
    13                          ; REGISTER#->>>      DECIMAL: 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17
    14                          ;                        HEX: 00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  
    15                          ;                             ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==
    16                          ;
    17                          ;---------------------- 40/80x25, 50 Hz, 20 kHz for 12" Internal Monitor (inverted video R12=$10)
    18                          !IF REFRESH=0 {
    19                          CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$27,$00,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    20                          CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$31,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    21                          }
    22                          
    23                          ;---------------------- 40/80x25, 60 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    24                          !IF REFRESH=1 {
    25  e7b1 3128290f2003191d...CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$20,$03,$19,$1d,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    26  e7c3 3128290f28051921...CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    27                          }
    28                          
    29                          ;---------------------- 40/80x25, 50 Hz, 15.625 kHz (PAL)  for External Monitor (inverted video)
    30                          !IF REFRESH=2 {
    31                          CRT_CONFIG_TEXT:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    32                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    33                          }
    34                          
    35                          ;---------------------- 40/80x25, 60 Hz, 15.748 kHz (NTSC) for External Monitor (inverted video)
    36                          !IF REFRESH=3 {
    37                          CRT_CONFIG_TEXT:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    38                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    39                          }
    40                          
    41                          ;---------------------- 40/80x25, 50 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    42                          !IF REFRESH=4 {
    43                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    44                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    45                          }
    46                          
    47                          ;---------------------- 40/80x25, 60 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    48                          !IF REFRESH=5 {
    49                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    50                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    51                          }
    52                          
    53                          ;===============
    54                          ; 8296D MACHINES
    55                          ;===============
    56                          ; The 8296D has a different monitor than standard machines and requires slightly modified timing
    57                          
    58                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V1)
    59                          !IF REFRESH=82 {
    60                          CRT_CONFIG_TEXT:	!byte $3A,$28,$2C,$08,$20,$09,$19,$1D,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    61                          CRT_CONFIG_GRAPHICS:	!byte $3A,$28,$2C,$08,$29,$03,$19,$22,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    62                          }
    63                          
    64                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V2)
    65                          !IF REFRESH=83 {
    66                          CRT_CONFIG_TEXT:	!byte $32,$28,$28,$08,$26,$02,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    67                          CRT_CONFIG_GRAPHICS:	!byte $32,$28,$28,$08,$30,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    68                          }
    69                          
    70                          
    71                          ;======================
    72                          ; Extended/Experimental
    73                          ;======================
    74                          ; NOTE: Screens larger than 25 lines are for 8296 ONLY!!! The 8296 has additional screen RAM.
    75                          ;       These settings push the monitor to it's maximum possible resolution. Because of this you loose
    76                          ;       the ability to expand the line height in 'text' mode.
    77                          
    78                          ;---------------------- 40/80x32, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    79                          !IF REFRESH=90 {
    80                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    81                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    82                          }
    83                          
    84                          ;---------------------- 40/80x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    85                          !IF REFRESH=91 {
    86                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    87                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    88                          }
    89                          
    90                          ;---------------------- 45/90x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    91                          !IF REFRESH=92 {
    92                          CRT_CONFIG_TEXT:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    93                          CRT_CONFIG_GRAPHICS:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    94                          }
    95                          
    96                          ;=======================
    97                          ; CUSTOM - You Define It
    98                          ;=======================
    99                          
   100                          ;---------------------- CUSTOM - Your parameters here!
   101                          !IF REFRESH=99 {
   102                          CRT_CONFIG_TEXT:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
   103                          CRT_CONFIG_GRAPHICS:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
   104                          }
   105                          

; ******** Source: crtc-tables.asm
     9                          }
    10                          	!IF SOFT40=1 { !SOURCE "crtc-reg-soft40.asm" }
    11                          } ELSE {
    12                          	!SOURCE "crtc-reg-normal.asm"

; ******** Source: editrom40.asm
  1394                          
  1395                          
  1396                          ;*********************************************************************************************************
  1397                          ;** BELL Sound Table  [E7D5]
  1398                          ;*********************************************************************************************************
  1399                          
  1400  e7d5 0e1e3e7e3e1e0e     SOUND_TAB	!byte $0e,$1e,$3e,$7e,$3e,$1e,$0e	; BELL chime values
  1401                          
  1402                          ;*********************************************************************************************************
  1403                          ;*** POWERS OF 2 TABLE  [$E7DC]
  1404                          ; This table is used by the TAB routine.
  1405                          ;*********************************************************************************************************
  1406                          
  1407  e7dc 8040201008040201   POWERSOF2       !byte $80,$40,$20,$10,$08,$04,$02,$01	; BIT table
  1408                          
  1409                          ;*********************************************************************************************************
  1410                          ;** VERSION BYTE?
  1411                          ;*********************************************************************************************************
  1412                          
  1413                          !IF HERTZ=50 {	!byte $29 }				; 901498-01 [edit-4-40-n-50]
  1414  e7e4 bb                 !IF HERTZ=60 {	!byte $BB }				; 901499-01 [edit-4-40-n-60]
  1415                          
  1416                          ;*********************************************************************************************************
  1417                          ;** SMALL PATCHES HERE
  1418                          ;*********************************************************************************************************
  1419                          
  1420                          !IF BACKARROW = 1 { !SOURCE "editbarrow.asm" }		; Patch for Back Arrow
  1421                          
  1422                          ;*********************************************************************************************************
  1423                          ;** FILLER
  1424                          ;*********************************************************************************************************
  1425  e7e5 aaaaaaaaaaaaaaaa...!FILL $e800-*,$aa	; Fill to end of 2K
  1426                          ;#########################################################################################################

; ******** Source: editrom.asm
    31                          				; 40-column CODEBASE
    32                          !IF CODEBASE=1 {!SOURCE "editrom80.asm"}				; 80-column CODEBASE
    33                          !IF CODEBASE=2 {!SOURCE "editrom82.asm"}				; 80-column EXTENDED CODEBASE
    34                          
    35                          ;---------------------- Extended 4K Edit ROM code here
    36                          ;
    37                          ; $E800-E8FF is not visible as I/O is in this space (the IO.ASM file can be used to place comments here)
    38                          ; $E900-EFFF for Extended ROM start address
    39                          
    40                          !IF CODEBASE = 2 {
    41                          	!SOURCE "editromext.asm" 
    42                          } ELSE {		
    43                          	!IF (COLOURPET + ESCCODES + WEDGE + EXECUDESK + SS40 + AUTORUN > 0) | (BACKARROW=2) {
    44                          		!IF OPTROM=0 {!SOURCE "io.asm"}				; Filler not visible due to I/O space!
    45                          		!IF OPTROM=1 { *=$9000 }  				; Assemble to option ROM at $9000
    46                          		!IF OPTROM=2 { *=$A000 }  				; Assemble to option ROM at $A000
    47                          		!IF OPTROM=99 {!SOURCE "io.asm"}			; Special case for development purposes
    48                          		
    49                          		!IF AUTORUN   = 1 { !SOURCE "editautorun.asm" }
    50                          		!IF BANNER > 0    { !SOURCE "editbanner.asm" }
    51                          		!IF WEDGE = 1	  { !SOURCE "editwedge.asm" }
    52                          		!IF COLOURPET = 1 { !SOURCE "colourpetsubs.asm" }
    53                          		!IF ESCCODES = 1  { !SOURCE "editescape.asm" }
    54                          		!IF REBOOT = 1    { !SOURCE "editreboot.asm" }
    55                          		!IF SS40 = 1      { !SOURCE "editsoft40.asm" }
    56                          		!IF BACKARROW = 2 { !SOURCE "editbarrow.asm" }
    57                          		!IF EXECUDESK > 0 { !SOURCE "execudesk.asm" }
    58                          INFOSTRING	
    59                          		!IF INFO > 0      { !SOURCE "info.asm" }
    60                          
    61                          		!IF OPTROM=0 { !FILL $F000-*,$FF }			; PAD to 4K ##########################
    62                          	}
    63                          }
