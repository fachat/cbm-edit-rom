
; ******** Source: editrom.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; This is the main Assembler file. It brings in the USER-DEFINED variables and acts on them to build a
     4                          ; functional EDITOR ROM.
     5                          ;
     6                          ;---------------------- Get User Variables and validate some settings, and set output file
     7                          

; ******** Source: edit.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; A Project to create replacement EDIT ROMs for the PET/CBM line of computers.
     4                          ; Use MAKE.BAT to assemble (ACME.EXE must be in same folder or in search path).
     5                          ; For complete documentation see:
     6                          ;      http://www.6502.org/users/sjgray/projects/editrom/index.html
     7                          ;
     8                          ; Edit these settings to choose which features are included.
     9                          ;
    10                          ; The most important is the CODEBASE setting. It determines which main code to use, which will determine
    11                          ; how many features are available:
    12                          ;
    13                          ;   CODEBASE=0 for 40-column (30xx/40xx) machines with Universal Dynamic Motherboard. Line Linking.
    14                          ;   CODEBASE=1 for 80-column (80xx/82xx/9000) machines with Universal Dynamic Motherboard. No Line Linking.
    15                          ;   CODEBASE=2 for 80-column (8296/8296D) machines (mostly DIN keyboard versions). No Line Linking.
    16                          ;
    17                          ; If there are no options listed it means that support has not been added yet!
    18                          ;
    19                          ; NOTE!: Not all combinations may be valid!!
    20                          ; NOTE!: SuperPET's require a special adapter to use EPROMS and have compatibility issues with 4K edit roms (see web page)
    21                          ;
    22                          ;----------------------------------------------------------------------------------------------------------------------------
    23                          ; The following DATE and COMMENT strings will be placed in the IO area (if used).
    24                          ; Take care that comments do not overflow into code space!
    25                          
    26                          !macro DATE      { !pet "2022-04-26" }
    27                          !macro COMMENT   { !pet "sjg-editrom" }
    28                          
    29                          ;----------------------------------------------------------------------------------------------------------------------------
    30                          
    31                          ; NAME		FEATURE				VALID OPTIONS			NOTES / FUTURE OPTIONS
    32                          ;---------	-------				-------------			----------------------
    33                          CODEBASE  = 0   ; Code Base			0=4000, 1=8000, 2=8296		
    34                          OPTROM    = 0   ; Location of EXT code		0=$E800-EFFF, 1=$9000, 2=$A000  Normal is 0.
    35                          
    36                          KEYSCAN   = 1   ; Keyboard Scanner		0=Normal,1=Business,2=DIN
    37                          KEYBOARD  = 1	; Keyboard type:		0=N-QWERTY,1=B-QWERTY,2=DIN,3=C64,4=B-SJG,5=N-SJG,6=B-QWERTZ,7=B-AZERTY,8=CBM-II (req hw mod)
    38                          REFRESH   = 1	; Screen refresh:		0=Euro,1=N.America,2=PAL,3=NTSC,4=9",82=8296D#1,83=8296D#2,90=32-line,91=35-line,92=90x35,99=Custom
    39                          REPEATOPT = 0	; Key Repeat Option		0=No (Always ON), 1=Yes
    40                          COLUMNS   = 40	; Screen Width			40,80,90,32 columns		Special cases 32 or 90.
    41                          ROWS      = 25  ; Screen Height			25,35,16 rows			Special cases 16 or 35.
    42                          HERTZ     = 50	; Line Frequency (Clock):	50=Euro,60=N.America
    43                          IRQFIX    = 0   ; Fix Jiffy Clock?		0=No, 1=Yes			Still needs investigating.
    44                          FONTSET   = 1	; Initial Screen Font		0=Text/Lower, 1=Upper/Graphics	Generally: 40xx machines=1, 8xxx machines=0
    45                          
    46                          ESCCODES  = 1	; Add ESC codes? 		0=No, 1=Yes			Enable when using COLOURPET or SS40.
    47                          VIDSWITCH = 0   ; Video Mode Select ESC codes?  0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+9 to Switch CRTC parameters.
    48                          
    49                          AUTORUN   = 1   ; Set for BANNER and/or WEDGE	0=No, 1=Yes			Enable if you use EITHER banner,wedge, or disk boot
    50                          BYPASS    = 0   ; Check for key to bypass? 	0=No, 1=Yes			Valid when AUTORUN=1. Hold key on ROW9 to bypass.
    51                          BANNER    = 5   ; Custom Banner (power on msg)?	0=No, N=Banner# (1-19,98,99)    Valid when AUTORUN=1. Refer to docs or source. 99=custom message
    52                          WEDGE     = 1	; DOS Wedge?			0=No, 1=Yes			Valid when AUTORUN=1.
    53                          WEDGEMSG  = 0	; Show wedge message?		0=No, 1=Yes			Valid when AUTORUN=1 and WEDGE>0.
    54                          DISKBOOT  = 1	; Boot first file on disk?	0=No, 1=Yes			Valid when AUTORUN=1.
    55                          
    56                          SOFT40    = 0	; 40 columns on 8032s?		0=No, 1=Yes			Do NOT enable SOFT40 and SS40 at the same time!
    57                          SS40      = 0	; Software Switchable Soft-40	0=No, 1=Yes			Also set ESCCODES=1. Also if BACKARROW>0 and BACKACTION=1.
    58                          SS40MODE  = 80  ; Initial SS40 Mode		40 or 80 columns		Valid when SS40=1.
    59                          HARD4080  = 0   ; Hardware 40/80 Board?         0=No, 1=Yes			Valid when SS40=1.
    60                          
    61                          KEYRESET  = 1	; Add keyboard reset? 		0=No, 1=Yes
    62                          SILENT    = 0	; Disable BELL/CHIME		0=Normal, 1=Disabled
    63                          CRUNCH    = 1   ; Remove unneeded code?		0=No, 1=Yes			Removes NOPs, filler, and unreachable code.
    64                          BACKARROW = 2   ; SHIFT-Backarrow Hack code?	0=NO, 1=Yes, 2=Yes EXT		Enable Shift-Backarrow, and where to put the code.
    65                          BACKACTION= 0   ; Backarrow Action		0=Text/Graphic, 1=40/80		Which Backarrow Action? NOTE: 40/80 requires ESC Codes!
    66                          
    67                          EXECUDESK = 0	; Add Execudesk Menu?		0=No, 1=Yes, 2=Yes/OPTROM	Note: Requires BOOT to TEXT mode!
    68                          COLOURPET = 1	; ColourPET additions?		0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+? to set Colour (unless VIDSWITCH=1).
    69                          UPET      = 1   ; Is a Ultra-PET/Micro-PET?     0=No, 1=Yes                     For special Reboot - Andre Fachat's project
    70                          
    71                          COLOURVER = 1	; ColourPET Hardware Version	0=Beta,1=Normal/uPET		0=ColourRAM at $8400, 1=$8800 (use for VICE).
    72                          COLOURMODE= 0	; ColourPET Hardware Type	0=Digital, 1=Analog
    73                          DEFAULTFG = 2	; ColourPET Foreground colour   0 to 15 RGBI 			0=black,1=DkGry,2=DkBlu ,3=LtBlu, 4=DkGrn, 5=Grn,   6=DkCyan,7=LtCyan
    74                          DEFAULTBG = 2	; ColourPET Background colour   0 to 15 RGBI 			8=DKred,9=LTred,10=DKpur,11=LTpur,12=DkYel,13=LtYel,14=LtGry,15=White
    75                          DEFAULTBO = 2   ; ColourPET Border colour       0 to 15 RGBI
    76                          BYPASSFG  = 5   ; ColourPET Bypass FG     	0 to 15 RGBI			Colours when AUTOSTART is bypassed.
    77                          BYPASSBG  = 0   ; ColourPET Bypass BG     	0 to 15 RGBI
    78                          
    79                          MOT6845   = 0   ; Is CRTC a Motorola6845?       0=No, 1=Yes			Probably 0=No for compatibility.
    80                          INFO      = 0   ; Add proj info to code area?	0=NO, 1=Yes,2=Yes+FONT		INFO=2 shows character set at top of screen
    81                          
    82                          BUGFIX    = 1   ; Correct Known bugs?		0=No, 1=Yes			Fix known bugs
    83                          DEBUG 	  = 0	; Add debugging?		0=No, 1=Yes			Add code to display debug info on screen

; ******** Source: editrom.asm
     8                          					; Include USER-DEFINED variables
     9                          	!IF COLOURPET>0 { ESCCODES=1 }					; Make sure ESC Codes is ON if SS40 or COLOURPET is enabled
    10                          	!IF SS40=1      { SOFT40=0 }                         		; Make sure SOFT40 is OFF if SS40 is enabled
    11                          
    12                          	!IF COLOURPET=0 { !TO "editrom.bin",plain }			; Generic output file with no load address
    13                          	!IF COLOURPET>0 { !TO "cpetrom.bin",plain }			; ColourPET output file with no load address
    14                          
    15                          ;---------------------- These are the symbol definitions for PET/CBM memory and IO chips
    16                          

; ******** Source: memzeropage.asm
     1                          ; PET/CBM EDIT ROM - Standard Zero Page locations/variables/storage
     2                          ; ================
     3                          ; Descriptions are from Butterfield's memory maps from Transactor
     4                          
     5                          ;		--------------- Common Usage (All Codebases)
     6                          
     7                          Basic_USR 	= $00		; USR Jump
     8                          USRADD 		= $01		; USR Jump
     9                          CHARAC 		= $03		; Search Character
    10                          ENDCHR 		= $04		; Scan between Quotes Flag
    11                          COUNT 		= $05		; Input buffer pointer. # of subscripts
    12                          DIMFLG 		= $06		; Default DIM flag
    13                          VALTYP 		= $07		; Type: FF=string, 00=numeric
    14                          INTFLG 		= $08		; Type: 80=integer, 00=floating point
    15                          GARBFL 		= $09		; Flag: DATA scan; List quote; memory
    16                          SUBFLG 		= $0a		; Flag: Subscript; FNX flag
    17                          INPFLG 		= $0b		; 0=input; $40=GET; $98=READ
    18                          TANSGN 		= $0c		; ATN sign/Comparison Evaluation Flag
    19                          DS_1 		= $0d		; Disk Status DS$ descriptor
    20                          DS_2 		= $0e		; Disk Status DS$ descriptor
    21                          DS_3 		= $0f		; Disk Status DS$ descriptor
    22                          IOPMPT 		= $10		; Current i/o device for prompt suppress
    23                          LINNUM 		= $11		; Integer value (for SYS, GOTO etc)
    24                          TEMPPT 		= $13		; Pointers for descriptor stack
    25                          LASTPT 		= $14	 	
    26                          TEMPST 		= $16		; Descriptor stack (temp strings)
    27                          INDEXA 		= $1f		; Utility pointer area
    28                          INDEXB 		= $21
    29                          FAC3EX 		= $23		; Product area for multiplication
    30                          FAC3M1 		= $24		
    31                          FAC3M2 		= $25
    32                          FAC3M3 		= $26
    33                          FAC3M4 		= $27
    34                          TXTTAB 		= $28		; Pointer: Start of BASIC
    35                          VARTAB 		= $2a		; Pointer: Start of Variables
    36                          ARYTAB 		= $2c		; Pointer: Start of Arrays
    37                          STREND 		= $2e		; Pointer: End of Arrays
    38                          FRETOP 		= $30		; Pointer: String Storage (moving down)
    39                          FRESPC 		= $32		; Pointer: Utility string
    40                          MEMSIZ 		= $34		; Pointer: Limit of Memory
    41                          CURLIN 		= $36		; Current BASIC line number
    42                          OLDLIN 		= $38		; Previous BASIC line number
    43                          OLDTXT 		= $3a		; Pointer: BASIC statement for CONT
    44                          DATLIN 		= $3c		; Current DATA line number
    45                          DATPTR 		= $3e		; Current DATA address
    46                          INPPTR 		= $40		; Input Vector
    47                          VARNAM 		= $42		; Current variable name
    48                          VARPTR 		= $44		; Current variable address
    49                          FORPNT 		= $46		; Variable pointer for FOR/NEXT
    50                          YSAVE 		= $48		; Y-Save; op-save; BASIC pointer save
    51                          ACCSYM 		= $4a		; Comparison symbol accumulator
    52                          FUNCPT 		= $4b		; Misc work area/pointers
    53                          DESCPT 		= $4d
    54                          GARBSS 		= $50
    55                          JUMPER 		= $51		; Jump vector for functions
    56                          FUNJMP 		= $52		
    57                          FACTPA 		= $54		; Misc numeric work area
    58                          TMPPTA 		= $55
    59                          TMPPTB 		= $57
    60                          FACTPB 		= $59
    61                          TMPVA2 		= $5a
    62                          TMPPTC 		= $5c
    63                          FAC1EX 		= $5e		; Accum#1: Exponent
    64                          FAC1M1 		= $5f		; Accum#1: Mantissa
    65                          FAC1M2 		= $60
    66                          FAC1M3 		= $61
    67                          FAC1M4 		= $62
    68                          FAC1SI 		= $63		; Accum#1: Sign
    69                          SGNFLG 		= $64		; Series evaluation constant pointer
    70                          BITS 		= $65		; Accum#1: hi-order (overflow)
    71                          FAC2EX 		= $66	
    72                          FAC2M1 		= $67
    73                          FAC2M2 		= $68
    74                          FAC2M3 		= $69
    75                          FAC2M4 		= $6a
    76                          FAC2SI 		= $6b
    77                          STRPTR		= $6c
    78                          FAC1M5 		= $6d
    79                          TMPPTD 		= $6e
    80                          CHRGET 		= $70
    81                          CHRGETX		= $73		; UNUSED
    82                          CHRGOT 		= $76
    83                          TXTPTR 		= $77
    84                          ISNUM 		= $7d
    85                          RNDX 		= $88
    86                          JIFFY_CLOCK 	= $8d
    87                          CINV 		= $90
    88                          CBINV 		= $92
    89                          NMINV 		= $94
    90                          STATUS		= $96
    91                          KEYPRESSED	= $97		; Which KEY down - $FF = no key
    92                          KEYFLAGS	= $98		; SHIFT KEY - $01 = Pressed
    93                          JIFFY_CORR	= $99		; Correction for JIFFY clock
    94                          STKEY		= $9b		; Keyswitch PIA - Stop and Reverse Flag
    95                          SVXT		= $9c		; Timing Constant for TAPE
    96                          VERCK		= $9d		; Tape mode: 0=Load, 1=Verify
    97                          CharsInBuffer 	= $9e		; Number of characters in keyboard buffer
    98                          ReverseFlag 	= $9f		; Screen Reverse Flag
    99                          C3PO 		= $a0		; IEEE Output - $FF=character pending
   100                          LastInputCol	= $a1		; End of Line for input pointer
   101                          InputRow 	= $a3		; Cursor Log: Row
   102                          InputCol 	= $a4		; Cursor Log: Column
   103                          BSOUR 		= $a5		; IEEE output buffer
   104                          Key_Image	= $a6		; Key Image
   105                          Blink		= $a7		; Cursor Flag: 0=Flash Cursor
   106                          BLNCT		= $a8		; Cursor Timing Countdown
   107                          CursorChar	= $a9		; Character Under Cursor
   108                          BlinkPhase	= $aa		; Cursor in Blink phase
   109                          SYNO		= $ab		; EOT (End of Tape) received from Tape
   110                          CRSW		= $ac		; Input from Screen or Keyboard
   111                          TEMPX		= $ad		; Save X
   112                          LDTND		= $ae		; How many open files?
   113                          DFLTN		= $af		; Input Device - Normally 0
   114                          DFLTO		= $b0		; Output CMD Device - Normally 3
   115                          PRTY		= $b1		; TAPE character parity
   116                          DPSW		= $b2		; Byte Received FLAG
   117                          SAVELA		= $b3		; Logical Address temporary save
   118                          TIMCMD		= $b4		; Tape buffer character / MLM command
   119                          MONCNT		= $b5		; Filename pointer / MLM Flag, counter
   120                          TMPZB7		= $b7
   121                          TMPZB9		= $b9
   122                          TMPZBA		= $ba
   123                          BUFPNT		= $bb
   124                          INBIT		= $bd
   125                          BITCI		= $be
   126                          RINONE		= $bf
   127                          PTR1		= $c0
   128                          PTR2		= $c1
   129                          RIDATA		= $c2
   130                          RIPRTY		= $c3
   131                          ScrPtr		= $c4		; Pointer to character screen line
   132                          CursorCol	= $c6		; Position of cursor on above line
   133                          SAL		= $c7		; Utility Pointer - Tape or Scrolling
   134                          EAL		= $c9		; Tape end address / End of current program
   135                          CMP0		= $cb		; Tape Timing Constants (ColourPET pointer to colour line)
   136                          BLNSW		= $cc		; Tape Timing Constants (ColourPET pointer to colour line)
   137                          QuoteMode	= $cd		; 0=Direct Cursor, else programmed
   138                          BITTS		= $ce		; Tape read timer 1 enabled
   139                          EOT		= $cf		; EOT recieved from TAPE
   140                          READERR		= $d0		; Read Character error
   141                          FNLEN		= $d1		; Number of characters in filename
   142                          LA		= $d2		; Current file Logical Address
   143                          SA		= $d3		; Current file Secondary Address
   144                          FA		= $d4		; Current file Device number
   145                          RightMargin	= $d5		; Window RIGHT margin
   146                          TAPE1		= $d6		; Pointer: Start of Tape Buffer
   147                          CursorRow	= $d8		; Line where cursor lives
   148                          DATAX		= $d9		; Last Key / Checksum / Misc
   149                          FNADR		= $da		; Filename pointer
   150                          INSRT		= $dc		; Number of inserts outstanding
   151                          ROPRTY		= $dd		; Write shift word / read character in
   152                          FSBLK		= $de		; Tape blocks remaining to write
   153                          MYCH		= $df		; Serial word buffer
   154                          CAS1		= $f9		; Cassette #1 status
   155                          CAS2		= $fa		; Cassette #2 status
   156                          STAL		= $fb		; Tape start address/ MLM
   157                          MEMUSS		= $fd		; MLM / DOS pointer / Misc
   158                          
   159                          ;		---------------- 40-Column Only Usage (Codebase 0)
   160                          ;		*** Currently, We cannot use ESC codes with CODEBASE 0 because this area is used for line linking!
   161                          ;		*** The line link table uses 24 bytes, 1 for each line (line 25 can never be linked)
   162                          ;		*** The line link table also holds the HI byte for the 40-col screen line table. It may be possible to
   163                          ;		*** Move the HI byte back into ROM like in the 80 column code, then pack the 24 bytes down to 3 using
   164                          ;		*** BITS instead. This would free 21 bytes that could be used for 80-column plus enhanced features.
   165                          ;		*** However, the code to handle BIT-based line linking would be more complicated and take more code.
   166                          
   167                          !IF CODEBASE=0 {
   168                          LineLinkTable   = $e0		; 40-Col Line Link Table (to $F8)
   169                          
   170                          } ELSE {
   171                          
   172                          ;		---------------- 80-Column Only Usage (Codebase 1 or 2)
   173                          ;		*** These are the normal 80-column screen editor locations. Since we have 80 columns there is no need
   174                          ;		*** for a line-link table, therefor we can use this for enhanced 80-column functions (windowing).
   175                          
   176                          TopMargin	= $e0		; Window TOP line
   177                          BotMargin	= $e1		; Window BOTTOM line
   178                          LeftMargin	= $e2		; Window LEFT margin
   179                          XMAX		= $e3		; Maximum characters in input buffer
   180                          RPTFLG		= $e4		; Key REPEAT flag
   181                          KOUNT		= $e5		; Repeat countdown
   182                          DELAY		= $e6		; New key marker
   183                          CHIME		= $e7		; Chime Time
   184                          HOMECT		= $e8		; Home count
   185                          SCRIV		= $e9		; Screen Input Vector  (E9/EA)
   186                          SCROV		= $eb		; Screen Output Vector (EB/EC)
   187                          ; $ED-F7 			; UNUSED
   188                          JIFFY6DIV5	= $f8		; TI clock adjust (speed by 6/5)
   189                          }
   190                          
   191                          ;		---------------- These are Customized Locations
   192                          ;      		*** With Codebase 1 the area from $ED-$F7 are unused
   193                          ;      		*** With Codebase 0 the area is part of the LineWrap Table
   194                          ;		***  ( can these move to TAPE BUFFER#1? - will conflict with tape and some ML programs)
   195                          
   196                          ; If ESC codes are not active but Backarrow Hack is set to Toggle 40/80
   197                          ; then define Screen Width Location
   198                          !IF (ESCCODES = 0) AND (BACKARROW>0) AND (BACKACTION=1) {
   199                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   200                          }
   201                          
   202                          !IF ESCCODES = 1 {
   203                            !IF CODEBASE = 0 {
   204                          
   205                          ;               *** CODEBASE 0 must avoid line-link table! We will use TAPE#2 buffer (which DOS uses)
   206                          
   207                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   208                          LASTCHAR	= $0382		; Last Key Pressed - used to remember ESC key
   209                          BELLMODE	= $0383		; 0=Disable, 1=Enable BELL/CHIME
   210                          EUROFLAG        = $0384		; 0=ASCII, 1=DIN
   211                          SCN4080BOARD    = $0385		; Flag for Hardware 40/80 Column Switcher board
   212                          
   213                          MYZP            = $00           ; LO General ZP pointer (we don't have a good location for this!)
   214                          ;                 $01           ; HI                    (we will take over the USR jump vector which is rarely used)
   215                          
   216                            } ELSE {
   217                          ;               *** CODEBASE 1/2 can safely go where line-link table would be
   218                          
   219                          SCNWIDTH	= $f0		; Screen Mode (40 or 80) for SS40
   220                          LASTCHAR	= $f1		; Last Key Pressed - used to remember ESC key
   221                          BELLMODE	= $f2		; 0=Disable, 1=Enable BELL/CHIME
   222                          EUROFLAG        = $f3		; 0=ASCII, 1=DIN
   223                          SCN4080BOARD    = $f4		; Flag for Hardware 40/80 Column Switcher board
   224                          MYZP            = $f5           ; LO General ZP pointer
   225                          ;                 $f6           ; HI
   226                          ;                 $f7		; not used
   227                          
   228                            }
   229                          }

; ******** Source: editrom.asm
    17                          				; $0000-00FF	Zero Page 

; ******** Source: memlow.asm
     1                          ; PET/CBM EDIT ROM - Standard Low Mem locations/variables/storage
     2                          ; ================
     3                          
     4                          ;------------------------ Common Usage
     5                          
     6                          STACK 			= $0100	;Processor Stack
     7                          BUF 			= $0200	;MLM work area; Input buffer
     8                          LAT 			= $0251	;File Logical Address Table
     9                          FAT 			= $025b	;File Device Number Table
    10                          SAT 			= $0265	;File Secondary Address Table
    11                          KEYD 			= $026f	;Keyboard input buffer
    12                          TAPEB1 			= $027a	;TAPE#1 input buffer
    13                          TAPEB2                  = $033a ;TAPE#2 input buffer (to $03F9)
    14                          
    15                          ;------------------------ Shared with TAPE#2 buffer
    16                          
    17                          NextTab 		= $033a	;DOS character pointer
    18                          DOS_Drive_1 		= $033b	;DOS drive 1 flag
    19                          DOS_Drive_2 		= $033c	;DOS drive 2 flag
    20                          DOS_Length 		= $033d	;DOS length/write flag
    21                          DOS_Syntax 		= $033e	;DOS syntax flags
    22                          DOS_Id 			= $033f	;DOS disk ID
    23                          DOS_Command_Length 	= $0341	;DOS command string count
    24                          DOS_Filename 		= $0342	;DOS filename buffer
    25                          DOS_Command_Buffer 	= $0353	;DOS command string buffer (to $0380)
    26                          ;			  $0381-03e8 ???
    27                          
    28                          ;------------------------ 40-Column Usage
    29                          
    30                          !IF CODEBASE=0 {
    31                          DELAY			= $03e9 ;Repeat Key countdown delay 	(40 col)
    32                          KOUNT			= $03ea ;Delay between repeats 		(40 col)
    33                          XMAX			= $03eb ;Max keyboard buffer size 	(40 col)
    34                          CHIME			= $03ec ;Chime Time 0=off 		(40 col)
    35                          JIFFY6DIV5		= $03ed ;TI clock adjust (speed by 6/5) (40 col) Was: TIADJ
    36                          RPTFLG			= $03ee ;Repeat Flag                    (40 col)
    37                          TABS			= $03ef ;TAB-STOP table			(40 col)
    38                          }
    39                          
    40                          ;------------------------ Common Usage
    41                          
    42                          TABS_SET 		= $03ee	;80 column TAB stop table ($03ee-03f7) ** Should this be $03ef ???? **
    43                          ;			  $03f8 ???
    44                          ; 			  $03f9 ???
    45                          
    46                          ;------------------------ End of TAPE#2 bufer
    47                          
    48                          Reset_Vector 		= $03fa	;Monitor extension vector
    49                          Reset_Param 		= $03fc	;IEEE timeout defeat; $FF=disable
    50                          ;			  $03fd ???
    51                          ;			  $03fe ???
    52                          ;			  $03ff ???
    53                          
    54                          ;------------------------ BASIC Program Area
    55                          

; ******** Source: editrom.asm
    18                          					; $0100-03FC	Low Memory

; ******** Source: memchips.asm
     1                          ; PET/CBM EDIT ROM - Standard Chip Registers and Screen Ram
     2                          ; ================
     3                          
     4                          ;--------------------------- Screen RAM $8000-$8FFF
     5                          
     6                          SCREEN_RAM = $8000					; 40 Col = $8000-83FF, 80 Col = $8000-87FF
     7                          
     8                          !IF COLUMNS = 80 { KBD_MATRIX = $87d0 }			; Used with Extended DIN ROM keyboard scanning routine
     9                          !IF COLUMNS = 40 { KBD_MATRIX = $83e8 }			; First unused byte in SCREEN_RAM
    10                          
    11                          
    12                          ;--------------------------- PIA #1 - 6520 Chip
    13                          
    14                          PIA1_Port_A = $e810					; Keyboard ROW select
    15                          PIA1_Cont_A = $e811
    16                          PIA1_Port_B = $e812					; Keyboard COLUMN read
    17                          PIA1_Cont_B = $e813
    18                          
    19                          ;--------------------------- PIA #2 - 6520 Chip
    20                          
    21                          PIA2_Port_A = $e820
    22                          PIA2_Cont_A = $e821
    23                          PIA2_Port_B = $e822
    24                          PIA2_Cont_B = $e823
    25                          
    26                          ;--------------------------- VIA - 6522 Chip
    27                          
    28                          VIA_Port_B = $e840					; IEEE, Screen Retrace, Cassette motor
    29                          VIA_Port_A = $e841					; Parallel Port (User Port) with handshaking
    30                          VIA_DDR_B = $e842					; Data Direction Register for PORT B
    31                          VIA_DDR_A = $e843					; Data Direction Register for PORT A
    32                          VIA_Timer_1_Lo = $e844				; Timer 1
    33                          VIA_Timer_1_Hi = $e845
    34                          VIA_Timer_1_Latch_Lo = $e846			; Timer 1 Latch
    35                          VIA_Timer_1_Latch_Hi = $e847
    36                          VIA_Timer_2_Lo = $e848				; Timer 2
    37                          VIA_Timer_2_Hi = $e849
    38                          VIA_Shift = $e84a					; Shift Register
    39                          VIA_ACR = $e84b						; Shift Register Control
    40                          VIA_PCR = $e84c
    41                          VIA_IFR = $e84d
    42                          VIA_IER = $e84e
    43                          VIA_Port_A_no_HS = $e84f				; Parallel Port, no handshaking
    44                          
    45                          ;--------------------------- CTRC - 6545 CRT Controller
    46                          
    47                          CRT_Address = $e880					; Register Select Port
    48                          CRT_Status = $e881					; Register DATA port

; ******** Source: editrom.asm
    19                          					; $E800-E8FF	Chips

; ******** Source: memkernal.asm
     1                          ; PET/CBM EDIT ROM - Standard Kernal calls
     2                          ; ================
     3                          ; These are calls from the EDIT ROM to KERNAL entry points
     4                          ;---------------------------------------------------------
     5                          ; Non-vectored calls (direct - caution: could change if KERNAL is changed)
     6                          
     7                          CHKSTOP 	= $F335 ; Check for STOP key
     8                          
     9                          ;----------------- Standard KERNAL Entry Points
    10                          
    11                          BASIN		= $ffcf ; read char from input channel -> A
    12                          BSOUT		= $ffd2	; Write A to stdout
    13                          GETIN		= $ffe4	; read char from keyboard buffer -> A
    14                          UDTIME		= $FFEA	; Update Time
    15                          
    16                          ACPTR		= $f1c0	; input IEEE -> A
    17                          CHKIN		= $ffc6	; stdin from logical file # in X
    18                          CIOUT		= $f19e	; output A -> IEEE
    19                          CKOUT		= $ffc9	; stdout to logical file # in X
    20                          CLOSE		= $f2e0	; close file
    21                          CLSEI		= $f72f	; close and unlisten
    22                          CLRCH		= $ffcc	; reset stdio to defaults
    23                          LISTN		= $f0d5	; send LISTEN
    24                          LOAD		= $f408	; LOAD
    25                          LOADOP		= $f356	; LOAD without pointer change
    26                          FILENOTFOUND	= $f425	; FILE NOT FOUND, return to BASIC
    27                          OPEN		= $f563	; open file
    28                          OPENI		= $f4a5	; open file on IEEE device
    29                          SCNT		= $f2c1	; prepare SETT for logical file A
    30                          SECND		= $f143	; send secondary address A
    31                          SETT		= $f2cd	; set LF,DN,SA from table
    32                          TALK		= $f0d2	; send TALK
    33                          TWAIT		= $f92b	; 
    34                          UNLSN		= $f1b9	; send UNLISTEN
    35                          UNTLK		= $f1ae	; send UNTALK
    36                          RESET		= $fd16	; basic cold start
    37                          STOPEQ		= $f335	; set Z flag if stop key pressed
    38                          STOPR		= $ffe1	; return to basic if stop key pressed

; ******** Source: editrom.asm
    20                          					; $F000-FFFF	Kernal

; ******** Source: membasic4.asm
     1                          ; --------- BASIC 4 ROM ROUTINES
     2                          
     3                          SCROUT	= $e202	; output A to screen
     4                          RDOA	= $d754	; read hex address -> $FB,$FC
     5                          RDOB	= $d763	; read hex byte -> A
     6                          CLRSCR	= $e015	; clear screen
     7                          CRLF	= $d534	; move cursor to next line
     8                          FPOUT	= $cf8d	; write floating point
     9                          INTOUT	= $cf83	; write integer 0-65535 X=LSB,A=MSB
    10                          SCROLD	= $e021	; scroll down
    11                          SCROLU	= $e024	; scroll up
    12                          SPAC2	= $d52e	; write 2 spaces
    13                          SPACE	= $d531	; write space
    14                          STROUTZ	= $bb1d	; A=LSB, Y=MSB			; BASIC4 STROUTZ is broken!
    15                          STROUT	= $bb24	; X=len, STRADR=ptr
    16                          WROA	= $d717	; write hex address
    17                          HEXOUT	= $d722	; write A as hex
    18                          WROB	= $d731	; write hex byte
    19                          WRTWO	= $d731	; write XA to screen
    20                          
    21                          ADRFP	= $cd7f	; uint LSB=$5f, MSB=$60 -> FAC1
    22                          ASCII	= $d73a	; hex digit -> ascii hex digit
    23                          FPINT	= $cdd1	; FAC1 -> uint $61=MSB, $62=LSB
    24                          FPSTR	= $cf93	; fp -> str $0100..NUL
    25                          HEXIT	= $d78d	; hex ascii digit A -> hex digit A
    26                          INTFP	= $c4bc	; int Y=LSB, A=MSB -> FAC1
    27                          STRFP	= $c8eb	; string -> fp
    28                          RDINT	= $b8f6	; read basic text -> LINNUM
    29                          
    30                          ABS	= $cd8e	; FAC1 = ABS(FAC1)
    31                          ADD	= $c9a0	; FAC1 = FAC1 + FAC2
    32                          ATN	= $d32C	; FAC1 = ATN(FAC1)
    33                          COS	= $d282	; FAC1 = COS(FAC1)
    34                          DIV	= $cc48	; FAC1 = FAC2 / FAC1
    35                          EXP	= $d184	; FAC1 = EXP(FAC1)
    36                          FAC12	= $cd45	; FAC2 := FAC1
    37                          
    38                          READY	= $b3ff	; basic warm start
    39                          NEWSTT	= $b74a	; set up next statement for execution
    40                          MOVBLK	= $b357	; move block
    41                          
    42                          LINKPRG	= $b4b6	; rechain lines
    43                          RSTXCLR	= $b5e9	; reset TXTPTR and perform CLR
    44                          STXTPT	= $b622	; reset TXTPTR
    45                          CLR	= $b5f0	; perform CLR
    46                          SCRTCH	= $b5d4	; perform NEW
    47                          
    48                          MAINS	= $b40f	; MAIN's return addr on stack for CHRGET routine

; ******** Source: editrom.asm
    21                          					; BASIC
    22                          

; ******** Source: memcpet.asm
     1                          ; PET/CBM EDIT ROM - ColourPET - Add colour to a standard PET/CBM machine
     2                          ; ================
     3                          ; The EVEN ram is re-defined for use as colour RAM. There are 8 bits (one byte) that corresponds
     4                          ; to each character on the screen. These 8 bits are defined differently according to the hardware.
     5                          ;
     6                          ; DIGITAL VERSION (development in progress):
     7                          ; ---------------
     8                          ; Supports 16 colours
     9                          ; The 4 bits are arranged like: RGBI (1 level for RGB plus INTENSITY)
    10                          ; The foreground colour is stored in the lower nibble
    11                          ; The background colour is stored in the upper nibble
    12                          ; The border colour is set via a register (to be determined)
    13                          ;
    14                          ; ANALOG VERSION (future development):
    15                          ; --------------
    16                          ; Supports 256 colours
    17                          ; The 8 bits arrangment is to be determined:
    18                          ;	Option 1: RRRGGGBB  (8 levels for RED, 8 for GREEN, and 4 for BLUE. May result in unbalanced colours)
    19                          ;	Option 2: RRGGBBII  (4 levels for RED/GREEN/BLUE (64 colours), then 4 intensity levels for that colour)
    20                          ;
    21                          ; The foreground colour is definable as above
    22                          ; The background colour is selectable for the entire screen using a register (to be determined)
    23                          ; The border colour is set via a register (to be determined)
    24                          ; ---------------------------------------------------------------------------------------------
    25                          
    26                          ;---------------- Zero Page Storage
    27                          ; NOTE: These locations were used for TAPE. Do not use TAPE on ColourPET!!!!!!!!
    28                          
    29                          COLOURPTR	= $C0		; Pointer for screen writes (WAS: Tape Pointer)
    30                          COLOURPTR2	= $C2		; Pointer for scrolling etc (WAS: Tape Pointer)
    31                          CURSORCOLOUR    = $ED		; Storage for Colour at Cursor position
    32                          
    33                          ;---------------- Colour Screen RAM
    34                          
    35                          !if COLOURVER = 0 { COLOUR_RAM = $8400 }		; 40 Col = $8400-87FF, 80 Col = $8800-8FFF
    36                          !if COLOURVER = 1 { COLOUR_RAM = $8800 }		; 40 Col = $8800-8BFF, 80 Col = $8800-8FFF
    37                          
    38                          
    39                          ;---------------- Storage (Currently in Screen RAM - To be moved?)
    40                          
    41                          COLOURSTOR = COLOUR_RAM + 25 * COLUMNS + 9	; Calculate Last visible colour mem then add offset for safety
    42                          
    43                          COLOURV 	= COLOURSTOR+1	; Combined FG and BG value
    44                          COLOURFG	= COLOURSTOR+2	; Foreground Colour
    45                          COLOURBG	= COLOURSTOR+3	; Background Colour
    46                          COLOURBORDER	= COLOURSTOR+4	; Border Colour
    47                          COLOURCOUNT	= COLOURSTOR+5	; Count to track colour change codes 	(1=FG,2=BG,3=BORDER)
    48                          
    49                          COLOURREGBG	= COLOURSTOR+6	; Colour Background Register		(dummy location for now)
    50                          COLOURREGBORDER = COLOURSTOR+7	; Colour Border Register		(dummy location for now)
    51                          COLOURREGMODE   = COLOURSTOR+8	; Colour Mode Register 			(For future use)
    52                          

; ******** Source: editrom.asm
    23                          }			; Non-standard memory usage (may change without notice)
    24                          
    25                          ;---------------------- Debug stuff
    26                          
    27                          	DBLINE = SCREEN_RAM + 24 * COLUMNS				; Calculate bottom line of screen for debug
    28                          
    29                          ;=======================================================================
    30                          ; Standard 2K Edit ROM code starts here
    31                          ;=======================================================================
    32                          ; $E000-E7FF are for normal Edit ROMS.
    33                          ; The CODEBASE setting determines which BASE features are included,
    34                          ; which roughly determines which machine they were targetted to.
    35                          ; This area MAY include NEW code depending on SETTINGS. Some new code may
    36                          ; require standard code to be relocated to EXT code area.
    37                          

; ******** Source: editrom40.asm
     1                          ; PET/CBM EDIT ROM  - Commented and Adapted by Steve J. Gray, Nov 17, 2015
     2                          ; ================    sjgray@rogers.com
     3                          ; 
     4                          ; ***** THIS IS 40-COLUMN CODEBASE *****
     5                          ;
     6                          ; This is reverse engineered source code for the EDIT ROMs of the Commodore PET/CBM computers.
     7                          ; The "901499-01" ROM was used as a base. Addresses inside [brackets] are original code addresses. 
     8                          ; Much of this disassembly comes from the 80-column source code, my own disassembly, and combined with
     9                          ; Edilbert Kirk's 80-column disassembly.
    10                          ;
    11                          ; The EDIT ROM is mapped from $E000 to EFFF (4K). Many Early versions used only $E000-E7FF (2K).
    12                          ; Note that the area from $E800 to $E8FF (256 bytes) is not available due to the I/O chips in this range.
    13                          ;
    14                          ; PET/CBM machines come in several flavours:
    15                          ;    * 40 or 80 column screens
    16                          ;    * Normal, Business, or DIN keyboards
    17                          ;    * 50 or 60 Hz power frequency
    18                          ;    * Specialized options, ie: Execudesk
    19                          ;
    20                          ; In addition I am adapting the EDIT roms to these additional options:
    21                          ;    * ColourPET - My own project to add colour capabilities
    22                          ;    * Alternate Keyboards - Such as the VIC/C64 keyboard
    23                          ;    * Soft40 - Simulate a 40 column screen on 80 column hardware
    24                          ;    * Soft-switchable SOFT40
    25                          ;    * Soft-switchable real 40/80 columns (requires hardware mod)
    26                          ;    * Extended screen editor - C128 or CBM-II compatible ESC sequences
    27                          ;    * Keyboard soft-reset (kinda like CTRL-ALT-DEL on PC's)
    28                          ;    * Autoboot from default drive
    29                          ;    * DOS Wedge
    30                          ;
    31                          ; See EDIT.ASM for assemble OPTIONS!
    32                          ; Use MAKE.BAT to assemble a binary file with the current options.
    33                          ;
    34                          ;-----------------------------------------------------------------------------------------------
    35                          * = $e000	; Normal start address for EDIT ROM is $E000
    36                          
    37                          ;*********************************************************************************************************
    38                          ;** Edit ROM Jump Table [E000]
    39                          ;** Note: Not all KERNAL and BASIC calls go through this table.
    40                          ;** There are FIVE hard-coded entry points: $E0A7, $E116, $E202, $E442, $E600
    41                          ;*********************************************************************************************************
    42                          
    43  e000 4c36e0             EDITOR		JMP RESET_EDITOR	; [E000] Main Initialization (called from Kernal power up reset at $FD16) 
    44  e003 4ca7e0             		JMP GETKEY		; [E003] Get Character From Keyboard Buffer	(FIXED ENTRY POINT. Must not move!)
    45  e006 4c16e1             		JMP INPUT_CHARACTER	; [E006] Input From Screen or Keyboard		(FIXED ENTRY POINT. Must not move!)
    46  e009 4c02e2             		JMP CHROUT_SCREEN	; [E009] Output to Screen			(FIXED ENTRY POINT. Must not move!)
    47  e00c 4c42e4             		JMP IRQ_MAIN		; [E00C] Main IRQ Handler			(FIXED ENTRY POINT. Must not move!)
    48  e00f 4c55e4             		JMP IRQ_NORMAL		; [E00F] Actual IRQ (clock, keyboard scan)
    49  e012 4c00e6             		JMP IRQ_END		; [E012] Return From Interrupt			(FIXED ENTRY POINT. Must not move!)
    50  e015 4c42e0             		JMP WIN_CLEAR		; [E015] Clear Window
    51  e018 4c0fe6             		JMP CRT_SET_TEXT	; [E018] Set CRTC to TEXT mode
    52  e01b 4c17e6             		JMP CRT_SET_GRAPHICS	; [E01B] Set CRTC to GRAPHICS mode
    53  e01e 4c1de6             		JMP CRT_PROGRAM		; [E01E] Program CRTC (Table pointer in A/X, chr set in Y)
    54  e021 4cf8e6             		JMP WIN_SCROLL_DN	; [E021] Scroll DOWN
    55  e024 4cc9e3             		JMP WIN_SCROLL_UP	; [E024] Scroll UP
    56  e027 4cbbe4             		JMP SCAN_KEYBOARD	; [E027] Scan Keyboard
    57  e02a 4c57e6             		JMP BEEP		; [E02A] Ring BELL/CHIME
    58  e02d 4c9be0             		JMP NOTSUPPORTED 	; [E02D] Set REPEAT Flag   (Function Not supported)
    59  e030 4c9be0             		JMP NOTSUPPORTED 	; [E030] Set Window Top    (Function Not supported)
    60  e033 4c9be0             		JMP NOTSUPPORTED 	; [E033] Set Window Bottom (Function Not supported)
    61                          
    62                          ;*********************************************************************************************************
    63                          ;** RESET_EDITOR  [E04B]  (Called from Jump Table)
    64                          ;** Initializes Editor, then sets the screen to TEXT or GRAPHICS mode.
    65                          ;*********************************************************************************************************
    66                          
    67                          RESET_EDITOR
    68                          !IF COLOURPET=0 {
    69                          		JSR INIT_EDITOR
    70                          } ELSE {
    71  e036 20f5ed             		JSR ColourPET_Init			; Initialize ColourPET settings
    72                          }
    73                          
    74                          !IF FONTSET=0	{ JSR CRT_SET_TEXT }			; Set Screen to TEXT mode
    75  e039 2017e6             !IF FONTSET=1	{ JSR CRT_SET_GRAPHICS }		; Set Screen to GRAPHICS mode
    76                          
    77  e03c 2054e6             		JSR BEEP_BEEP 				; Ring BELL
    78  e03f 2054e6             		JSR BEEP_BEEP 				; Ring BELL
    79                          
    80                          ;*********************************************************************************************************
    81                          ;** WIN_CLEAR  [$E042]  (Called from Jump Table) 
    82                          ;** This routine clears the screen. Since there is no windowing it clears EVERY byte in the screen memory,
    83                          ;** including non-visible bytes. It also calculates the HI byte of the start of each screen line and
    84                          ;** stores it into the Screen Line Link table. LO bytes are stored in ROM at $E798. These addresses are
    85                          ;** used for printing to the screen. Entries with HI BIT CLEARED are linked to the line above it.
    86                          ;*********************************************************************************************************
    87                          ; This routine will go here in it's usual spot for fixed 40/80 column option, however,
    88                          ; if we are using SS40 then the routine will not fit so we must relocate it!
    89                          

; ******** Source: editrom40cls.asm
     1                          ;*********************************************************************************************************
     2                          ;** WIN_CLEAR  [$E042]  (Called from Jump Table) 
     3                          ;** This routine clears the screen. Since there is no windowing it clears EVERY byte in the screen memory,
     4                          ;** including non-visible bytes. It also calculates the HI byte of the start of each screen line and
     5                          ;** stores it into the Screen Line Link table. LO bytes are stored in ROM at $E798. These addresses are
     6                          ;** used for printing to the screen. Entries with HI BIT CLEARED are linked to the line above it.
     7                          ;*********************************************************************************************************
     8                          ; This routine will be placed at $E042 for normal options, however when Soft40 is enabled ("SS40"=1) it
     9                          ; is too big to fit and will cause a "too much code generated" error so it must be relocated.
    10                          ; There should be enough space just before $E600.
    11                          
    12                          FULL_SCREEN 	; This codebase does not have windowing, so this label is needed for Soft40 compatibility
    13                          
    14  e042 a218               WIN_CLEAR	LDX #ROWS-1				; Start at the bottom of the screen (25-1=24 lines)
    15                          
    16                          !IF SS40=0 {						; If switchable then we need to check screen mode to properly set address of last line
    17                          
    18  e044 a9c0                !IF COLUMNS=40 {LDA #$C0				; $83C0 = First character on last line of 40-col screen
    19  e046 a083               		 LDY #$83}
    20                           !IF COLUMNS=80 {LDA #$80				; $8780 = First character on last line of 80-col screen
    21                          		 LDY #$87}
    22                          } ELSE {						; Yes, so check current mode
    23                          		LDA SCNWIDTH				; Get current Soft Screen Width
    24                          		CMP #40					; Is it >40 column mode?
    25                          		BCS WC80				; Yes, skip
    26                          		LDA #$C0				; $83C0 = First character on last line of 40-col screen
    27                          		LDY #$83	
    28                          		BCC WCLOOP				; Skip over 80 col
    29                          WC80		LDA #$80				; $8780 = First character on last line of 80-col screen
    30                          		LDY #$87	
    31                          }
    32                          
    33  e048 94e0               WCLOOP		STY LineLinkTable,X			; LOOP[      Save HI byte of screen address to table
    34  e04a 38                 		SEC					;
    35                          
    36  e04b e928               !IF SS40=0 {	SBC #COLUMNS				;   Subtract Hard-coded Screen Width (one physical line)
    37                              } ELSE {    SBC SCNWIDTH }				;   Subtract Soft Screen Width
    38                          
    39  e04d b001               		BCS WCSKIP1				;   did we move past page? No, skip ahead
    40  e04f 88                 		DEY					;   Yes, next page
    41  e050 ca                 WCSKIP1		DEX					;   Previous line
    42  e051 10f5               		BPL WCLOOP				; ] Loop up for more
    43                          
    44  e053 84c5               		STY ScrPtr+1				; Store in screen pointer HI
    45  e055 e8                 		INX					; X=0
    46  e056 869f               		STX ReverseFlag    			; Clear RVS Flag
    47  e058 86c4               		STX ScrPtr    				; Store 0 to screen Pointer LO (pointer should point to $8000 - HOME position)
    48                          
    49                          ;[$E05A]	------------------------------- Clear all Screen Memory 
    50                          
    51  e05a a920               		LDA #$20				; <SPACE>
    52  e05c 9d0080             CLS_LOOP	STA SCREEN_RAM,X			; LOOP[  Screen RAM page 1
    53  e05f 9d0081             		STA SCREEN_RAM+$100,X			;        Screen RAM page 2
    54  e062 9d0082             		STA SCREEN_RAM+$200,X			;        Screen RAM page 3
    55  e065 9d0083             		STA SCREEN_RAM+$300,X			;        Screen RAM page 4 (this also clears non-visible)
    56                          
    57                          !IF (COLUMNS >40) OR (SS40=1) {
    58                          		STA SCREEN_RAM+$400,X			;        Screen RAM page 5
    59                          		STA SCREEN_RAM+$500,X			;        Screen RAM page 6
    60                          		STA SCREEN_RAM+$600,X			;        Screen RAM page 7
    61                          		STA SCREEN_RAM+$700,X			;        Screen RAM page 8
    62                          }
    63  e068 e8                 		INX					;   Next position
    64  e069 d0f1               		BNE CLS_LOOP				; ] Loop back for more
    65                          
    66                          !IF (COLOURPET=1) {
    67  e06b 201eee             		JSR ClearColourRAM
    68                          }
    69                          

; ******** Source: editrom40.asm
    90                          }
    91                          
    92                          ;*********************************************************************************************************
    93                          ;** CURSOR_HOME  [$E06B]
    94                          ;** Moves the cursor to the HOME position
    95                          ;*********************************************************************************************************
    96                          
    97  e06e a000               CURSOR_HOME	LDY #$00				; ROW=0, COL=0
    98  e070 84c6               		STY CursorCol   			; Store to Cursor Column on Current Line
    99  e072 84d8               		STY CursorRow   			; Store to Current Cursor Physical Line Number
   100                          
   101                          ;*********************************************************************************************************
   102                          ;** CURSOR_LM  [$E071]
   103                          ;** Moves Cursor to start of line. Sets Screen-line pointer, and determines if line is linked 
   104                          ;*********************************************************************************************************
   105                          
   106  e074 a6d8               CURSOR_LM	LDX CursorRow   			; Get Current Cursor Physical Line Number
   107  e076 b5e0               		LDA LineLinkTable,X			; Get Current Line's Screen Line Link entry
   108  e078 0980               		ORA #$80				; Make sure HIGH bit is set
   109  e07a 85c5               		STA ScrPtr+1				; Store in Current Screen Line Address HI
   110  e07c bda6e7             		LDA Line_Addr_Lo,X			; Get the LO byte from table in ROM
   111  e07f 85c4               		STA ScrPtr    				; Store to Current Screen Line Address LO
   112                          
   113  e081 a927               !IF SS40=0 {	LDA #COLUMNS-1 				; Fixed Screen Width -1
   114                          } ELSE {        LDA SCNWIDTH				; Soft Screen Width
   115                          		SBC #1 }				; -1
   116                          
   117  e083 85d5               		STA RightMargin   			; Set Physical Screen Line Length
   118  e085 e018               		CPX #ROWS-1				; Line 24? (0-24) last line cannot be linked
   119  e087 f008               		BEQ CLM_SKIP1				; Yes, skip ahead
   120  e089 b5e1               		LDA LineLinkTable+1,X 			; Check next line in screen line link table
   121  e08b 3004               		BMI CLM_SKIP1  				; Is HIGH bit set? (negative value) Yes, so NO linked line
   122  e08d a94f               		LDA #79					; No, then line is linked (two screen lines)
   123  e08f 85d5               		STA RightMargin   			; Store in Physical Screen Line Length
   124  e091 a5c6               CLM_SKIP1 	LDA CursorCol   			; Cursor Column on Current Line
   125                          
   126  e093 c928               !IF SS40=0 {    CMP #COLUMNS				; Is it greater than Fixed Screen Width?
   127                          } ELSE {	CMP SCNWIDTH }				; Is it greater than SCNWIDTH?
   128                          
   129  e095 9004               		BCC NOTSUPPORTED			; No, skip
   130                          
   131  e097 e928               !IF SS40=0 {    SBC #COLUMNS				; Yes, subtract Fixed Screen Width
   132                          } ELSE {	SBC SCNWIDTH }				; Yes, subtract SCNWIDTH
   133                          
   134  e099 85c6               		STA CursorCol   			; Cursor Column on Current Line
   135                          
   136                          ;-------------- Unsupported Functions Jump Here [$E098]
   137                          
   138  e09b 60                 NOTSUPPORTED	RTS
   139                          
   140                          ;*********************************************************************************************************
   141                          ;** GETKEY [E0A7] (Called from Jump Table)
   142                          ;** Get a KEY from keyboard buffer. Reads a character from 'KEYD' then shifts remaining buffer characters
   143                          ;** If there is NO key it will return $FF.
   144                          ;*********************************************************************************************************
   145                          
   146  e09c aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e0a7-*,$aa }	; FIXED ENTRY POINT! This must not move! (approx 14 bytes filler for std rom)
   147                          
   148                          ;#########################################################################################################
   149                          
   150                          GETKEY
   151                          !if DEBUG=1 { INC DBLINE+2,X }				; DEBUG
   152  e0a7 ac6f02             		LDY KEYD				; Get key at start of buffer
   153  e0aa a200               		LDX #0 					; Start at 0
   154                          
   155  e0ac bd7002             GK_LOOP		LDA KEYD+1,X				; LOOP[ START - Now shift the next keys in line
   156  e0af 9d6f02             		STA KEYD,X				;   to the front of the buffer
   157                          !if DEBUG=1 { STA DBLINE+10,X }				;   DEBUG - update screen
   158  e0b2 e8                 		INX
   159  e0b3 e49e               		CPX CharsInBuffer			;   Num Chars in Keyboard Buffer
   160  e0b5 d0f5               		BNE GK_LOOP				; ] Done? No, loop for another
   161                          
   162  e0b7 c69e               		DEC CharsInBuffer			; Reduce Num Chars in Keyboard Buffer
   163                          
   164  e0b9 98                 		TYA					; Put the character in Accumulator
   165                          !if DEBUG=1 { STA DBLINE+3 }				; DEBUG - 4th chr on bottom line
   166  e0ba 58                 		CLI
   167  e0bb 60                 		RTS
   168                          
   169                          ;*********************************************************************************************************
   170                          ;** GETLINE [E0BC]
   171                          ;** The PET is usually in this routine, waiting for keypresses and printing them or acting on them.
   172                          ;** This routine continually loops until a <RETURN> is pressed. When <RETURN> is pressed then the line
   173                          ;** where the cursor is, is processed. If the <RUN> key is pressed then the string is stuffed into
   174                          ;** the keyboard buffer (overwriting whatever might be there)
   175                          ;*********************************************************************************************************
   176                          
   177  e0bc 203ce6             GETLINE		JSR ChrOutMarginBeep			; Check for BELL at near-end of line 
   178                          GETLINE2	!IF DEBUG=1 { INC DBLINE+5 }		; DEBUG - 6th chr on bottom line
   179  e0bf a59e               		LDA CharsInBuffer			; Are there any keys waiting?
   180  e0c1 85a7               		STA Blink 				; 0 chars -> blink cursor
   181  e0c3 f0fa               		BEQ GETLINE2 				; loop until char in buffer
   182                          
   183                          !if DEBUG=1 { INC DBLINE+6 }				; DEBUG - 7th chr on bottom line
   184                          
   185                          ;		--------------------------------------- Got a character, so process it
   186                          
   187  e0c5 78                 		SEI
   188  e0c6 a5aa               		LDA BlinkPhase				; Flag: Last Cursor Blink On/Off
   189  e0c8 f009               		BEQ GL_1				; no, so no need to restore original character
   190  e0ca a5a9               		LDA CursorChar				; Character Under Cursor
   191  e0cc a000               		LDY #0
   192  e0ce 84aa               		STY BlinkPhase				; Reset blinkphase
   193  e0d0 2006e6             		JSR RESTORE_CHR_AT_CRSR			; Restore OLD character under cursor before processing new one
   194  e0d3 20a7e0             GL_1		JSR GETKEY				; Get Character From Keyboard Buffer
   195  e0d6 c983               		CMP #$83				; Is it the <RUN> key?
   196  e0d8 d010               		BNE GL_3				; No, skip ahead
   197                          
   198                          ;		--------------------------------------- Stuff the <RUN> string to the keyboard buffer
   199                          
   200  e0da 78                 		SEI
   201  e0db a209               		LDX #9					; Length of string
   202  e0dd 869e               		STX CharsInBuffer			; Set number of characters in buffer
   203  e0df bd9ce7             GL_2		LDA RUN_STRING-1,X			; LOOP[    Normally:  dL"*<RETURN>run<RETURN>
   204  e0e2 9d6e02             		STA KEYD-1,X				;   stuff it into the buffer
   205  e0e5 ca                 		DEX					;   next character
   206  e0e6 d0f7               		BNE GL_2				; ] Loop back for more
   207  e0e8 f0d5               		BEQ GETLINE2
   208                          
   209                          ;		--------------- Check for RETURN key
   210                          
   211  e0ea c90d               GL_3		CMP #$0D 				; Check if <RETURN> pressed
   212  e0ec d0ce               		BNE GETLINE				; if not go get more keys
   213                          
   214                          ;*********************************************************************************************************
   215                          ;** PARSE_LINE [E0EE]
   216                          ;** When the <RETURN> key is pressed the line where the cursor lives is executed
   217                          ;*********************************************************************************************************
   218                          
   219                          		!IF DEBUG=1 { INC DBLINE+7 }		; DEBUG - 8th chr on bottom line
   220                          
   221  e0ee a4d5               		LDY RightMargin   			; Physical Screen Line Length
   222  e0f0 84ac               		STY CRSW   				; Flag: INPUT or GET from Keyboard
   223                          
   224  e0f2 b1c4               PL_LOOP		LDA (ScrPtr),Y				; LOOP[  Pointer: Current Screen Line Address
   225  e0f4 c920               		CMP #$20				;   Is it <SPACE>?
   226  e0f6 d003               		BNE PL_SKIP				;   No, found end of line, skip ahead
   227  e0f8 88                 		DEY					;   Yes, move to previous position
   228  e0f9 d0f7               		BNE PL_LOOP				; ] At start of line? No, loop back for more
   229                          
   230                          ;		------------------------ Process line
   231                          
   232  e0fb c8                 PL_SKIP 	INY					; last checked was not space so move one forward
   233  e0fc 84a1               		STY LastInputCol			; Pointer: End of Logical Line for INPUT
   234  e0fe a000               		LDY #0					; COL=0, QUOTEMODE=0		[40]
   235  e100 84c6               		STY CursorCol   			; Cursor Column on Current Line	[40]
   236  e102 84cd               		STY QuoteMode   			; Flag: Editor in Quote Mode
   237  e104 a5a3               		LDA InputRow   				; Cursor Y-X Pos. at Start of INPUT
   238  e106 3016               		BMI Screen_Input
   239  e108 c5d8               		CMP CursorRow   			; Current Cursor Physical Line Number
   240  e10a d012               		BNE Screen_Input
   241  e10c a5a4               		LDA InputCol
   242  e10e 85c6               		STA CursorCol   			; Cursor Column on Current Line
   243  e110 c5a1               		CMP LastInputCol   			; Pointer: End of Logical Line for INPUT
   244  e112 900a               		BCC Screen_Input
   245  e114 b02b               		BCS Screen_Input2
   246                          
   247                          ;*********************************************************************************************************
   248                          ;** INPUT_CHARACTER [E116] (Called from Jump Table) - FIXED ENTRY POINT!!!!!
   249                          ;** Push X and Y to stack then call Input a Character routine via pointer
   250                          ;*********************************************************************************************************
   251                          
   252                          		!IF NOFILL=0 { !FILL $e116-*,$aa }	; FIXED ENTRY POINT! This must not move!
   253                          
   254                          ;#########################################################################################################
   255                          
   256  e116 98                 INPUT_CHARACTER	TYA
   257  e117 48                 		PHA
   258  e118 8a                 		TXA
   259  e119 48                 		PHA
   260                          
   261                          ; 		On 80-column core there is a JMP(SCRIV) here
   262                          ;		where SCRIV normally points to DEFAULT_SCREEN_VECTOR
   263                          
   264                          ;*********************************************************************************************************
   265                          ;** DEFAULT_SCREEN_VECTOR [E11D]
   266                          ;** Input from Screen Routine
   267                          ;*********************************************************************************************************
   268                          
   269                          DEFAULT_SCREEN_VECTOR
   270  e11a a5ac               		LDA CRSW   				; Get Input Flag: INPUT or GET from Keyboard
   271  e11c f0a1               		BEQ GETLINE2				; Is it ZERO? Yes, Loop back up to Input from Keyboard
   272                          
   273                          ;		--------------------------------------- Screen Input [$E11E]
   274                          
   275  e11e a4c6               Screen_Input	LDY CursorCol				; Cursor Column on Current Line
   276  e120 b1c4               		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   277  e122 85d9               		STA DATAX				; Current Character to Print
   278  e124 293f               		AND #$3F
   279  e126 06d9               		ASL DATAX				; Current Character to Print
   280  e128 24d9               		BIT DATAX				; Current Character to Print
   281  e12a 1002               		BPL SI_SKIP1
   282  e12c 0980               		ORA #$80
   283  e12e 9004               SI_SKIP1	BCC SI_SKIP2
   284  e130 a6cd               		LDX QuoteMode				; Flag: Editor in Quote Mode
   285  e132 d004               		BNE SI_SKIP3
   286  e134 7002               SI_SKIP2	BVS SI_SKIP3
   287  e136 0940               		ORA #$40				; '@'
   288  e138 e6c6               SI_SKIP3	INC CursorCol				; Cursor Column on Current Line
   289  e13a 2067e1             		JSR CheckQuote				; Switch Quote flag
   290  e13d c4a1               		CPY LastInputCol			; Pointer: End of Logical Line for INPUT
   291  e13f d017               		BNE SI_SKIP6
   292                          
   293                          ;		--------------------------------------- Screen Input 2 [$E141]
   294                          
   295  e141 a900               Screen_Input2	LDA #$00
   296  e143 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   297  e145 a90d               		LDA #$0D				; <RETURN>
   298  e147 a6af               		LDX DFLTN				; Default Input Device (0)
   299  e149 e003               		CPX #$03				; 3=SCREEN
   300  e14b f006               		BEQ SI_SKIP4
   301  e14d a6b0               		LDX DFLTO				; Default Output (CMD) Device (3)
   302  e14f e003               		CPX #$03	
   303  e151 f003               		BEQ SI_SKIP5
   304  e153 2002e2             SI_SKIP4	JSR CHROUT_SCREEN			; Output to screen
   305  e156 a90d               SI_SKIP5	LDA #$0D				; <RETURN>
   306  e158 85d9               SI_SKIP6 	STA DATAX  				; Current Character to Print
   307  e15a 68                 		PLA
   308  e15b aa                 		TAX
   309  e15c 68                 		PLA
   310  e15d a8                 		TAY
   311  e15e a5d9               		LDA DATAX  				; Current Character to Print
   312  e160 c9de               		CMP #$DE				; Is it <PI>?
   313  e162 d002               		BNE SI_DONE				; No, skip ahead
   314  e164 a9ff               		LDA #$FF				; Yes, substitute screen code
   315  e166 60                 SI_DONE		RTS
   316                          
   317                          ;[$E167]	--------------------------------------- Check Quote Mode 
   318                          
   319  e167 c922               CheckQuote	CMP #$22 				; Is it <QUOTE>?
   320  e169 d008               		BNE CQ_DONE				; No, skip ahead
   321  e16b a5cd               		LDA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   322  e16d 4901               		EOR #1					; toggle the BIT
   323  e16f 85cd               		STA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   324  e171 a922               		LDA #$22 				; reload the <QUOTE>
   325  e173 60                 CQ_DONE		RTS
   326                          
   327                          ;*********************************************************************************************************
   328                          ;** CHAR_TO_SCREEN [E177]
   329                          ;** This puts a character in 'A' to screen. The character is handled differently according to the entry
   330                          ;** point. For example, when QUOTE mode is ON special characters are printed in RVS using CHAR_TO_SCREEN3
   331                          ;*********************************************************************************************************
   332                          
   333  e174 0940               CHAR_TO_SCREEN	ORA #$40 				; '@'
   334  e176 a69f               CHAR_TO_SCREEN2 LDX ReverseFlag    			; Flag: Print Reverse Chars. -1=Yes
   335  e178 f002               		BEQ CTS_SKIP1
   336                          
   337  e17a 0980               CHAR_TO_SCREEN3	ORA #$80				; Toggle the upper bit (reverse characters)
   338  e17c a6dc               CTS_SKIP1	LDX INSRT  				; Flag: Insert Mode, >0 = # INSTs
   339  e17e f002               		BEQ CTS_SKIP2
   340  e180 c6dc               		DEC INSRT  				; Flag: Insert Mode, >0 = # INSTs
   341                          CTS_SKIP2
   342                          
   343                          !IF COLOURPET=0 {
   344                          		JSR RESTORE_CHR_AT_CRSR
   345                          } ELSE {
   346  e182 20beee             		JSR Put_ColourChar_at_Cursor		; Put character AND Colour on screen
   347                          }
   348  e185 e6c6               		INC CursorCol   			; Move to next column
   349  e187 a4d5               		LDY RightMargin   			; Physical Screen Line Length (Right Margin)
   350  e189 c4c6               		CPY CursorCol   			; Get Column again. Compare to Right Margin
   351  e18b b019               		BCS IRQ_EPILOG				; Is it past the Margin? Yes, we are done
   352                          ;               ----------------------------------------
   353  e18d a6d8               		LDX CursorRow   			; Current Cursor Physical Line Number
   354  e18f c04f               		CPY #79					; 79=maximum line length (2 physical lines in 40-column mode) minus 1
   355                          							; ##### We need to decide if we will link two 80 column lines????
   356  e191 d00c               		BNE CTS_SKIP3				; It's not at the end, so skip ahead
   357  e193 20b3e1             		JSR LINKLINES				; If it is then link them! 
   358  e196 209ee3             		JSR CURSOR_DOWN				; Move Cursor to next line
   359  e199 a900               		LDA #$00				; First character on line
   360  e19b 85c6               		STA CursorCol   			; Cursor Column on Current Line
   361  e19d f007               		BEQ IRQ_EPILOG
   362                          
   363  e19f e018               CTS_SKIP3	CPX #ROWS-1				; Last screen line?
   364                          
   365  e1a1 d01b               !IF SS40=0 {	BNE LINKLINES2				; No, continue
   366                          } ELSE {	JMP LINKLINES2 }			; No, continue (code has been relocated too far for branching)
   367                          
   368  e1a3 20c4e1             		JSR SCROLL_UP				; Yes, Scroll screen and adjust line link
   369                          
   370                          ;*********************************************************************************************************
   371                          ;** IRQ_EPILOG [E1A6]
   372                          ;** IRQ Completion. We jump here when printing is complete.
   373                          ;*********************************************************************************************************
   374                          
   375  e1a6 68                 IRQ_EPILOG	PLA
   376  e1a7 a8                 		TAY
   377  e1a8 a5dc               		LDA INSRT				; Flag: Insert Mode, >0 = # INSTs
   378  e1aa f002               		BEQ IRQE_1
   379  e1ac 46cd               		LSR QuoteMode				; Flag: Editor in Quote Mode
   380  e1ae 68                 IRQE_1		PLA
   381  e1af aa                 		TAX
   382  e1b0 68                 		PLA
   383  e1b1 58                 		CLI					; Allow interrupts again
   384  e1b2 60                 		RTS
   385                          
   386                          ;*********************************************************************************************************
   387                          ;** LINKLINES [$E1B3]
   388                          ;** These routines are for 40-column line linking. When a character is printed to
   389                          ;** column 40 the line and the line below are linked into one 80-character logical line.
   390                          ;** IE: two physical lines become one logical line.
   391                          ;** X hold physical line#. Checks ROW to make sure it's not on last line.
   392                          ;*********************************************************************************************************
   393                          ; If SS40=0 then we include the code here in it's normal location, otherwise we relocate it to EXT space.
   394                          

; ******** Source: editrom40link.asm
     1                          ;*********************************************************************************************************
     2                          ;** LINKLINES [$E1B3]
     3                          ;** These routines are for 40-column line linking. When a character is printed to
     4                          ;** column 40 the line and the line below are linked into one 80-character logical line.
     5                          ;** IE: two physical lines become one logical line.
     6                          ;** X hold physical line#. Checks ROW to make sure it's not on last line.
     7                          ;*********************************************************************************************************
     8                          
     9  e1b3 e017               LINKLINES	CPX #ROWS-2				; Check if we are below ROW 23?
    10  e1b5 b006               		BCS LL_SKIP				; Yes, skip out
    11  e1b7 b5e2               		LDA LineLinkTable+2,X			; No, safe to link the next line to this one
    12  e1b9 0980               		ORA #$80				; Link the line by SETTING the upper bit
    13  e1bb 95e2               		STA LineLinkTable+2,X			; Store to line link table
    14  e1bd 60                 LL_SKIP		RTS
    15                          
    16                          ;		--------------------------------------- Convert 40 character line to 80 characters [$E1BE]
    17                          
    18  e1be 20cde1             LINKLINES2	JSR LINKLINES3				; Adjust line link and move to start of line
    19  e1c1 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
    20                          
    21                          ;		--------------------------------------- Scroll screen UP [$E1C4]
    22                          
    23  e1c4 20c9e3             SCROLL_UP	JSR WIN_SCROLL_UP			; Scroll Screen Up
    24  e1c7 c6a3               		DEC InputRow   				; Cursor Y-X Pos. at Start of INPUT
    25  e1c9 c6d8               		DEC CursorRow   			; Current Cursor Physical Line Number
    26  e1cb a6d8               		LDX CursorRow   			; Current Cursor Physical Line Number
    27                          
    28                          ;		------------------------------- Adjust Line Link and Move to start of line [$E1CD]
    29                          
    30  e1cd 16e1               LINKLINES3	ASL LineLinkTable+1,X 			; Shift to lose HI BIT
    31  e1cf 56e1               		LSR LineLinkTable+1,X 			; HI BIT is now CLEARED
    32  e1d1 20b3e1             		JSR LINKLINES				; Set line link
    33  e1d4 a5c6               		LDA CursorCol   			; Get Cursor Column on Current Line
    34  e1d6 48                 		PHA					; Remember column
    35  e1d7 2074e0             		JSR CURSOR_LM				; Cursor to start of line
    36  e1da 68                 		PLA					; Restore column
    37  e1db 85c6               		STA CursorCol   			; Store Cursor Column on Current Line
    38  e1dd 60                 		RTS

; ******** Source: editrom40.asm
   395                          }
   396                          
   397                          ;*********************************************************************************************************
   398                          ;** CURSOR_TO_EOPL [$E1DE]
   399                          ;** Back to previous line when actioning DEL or LEFT 
   400                          ;*********************************************************************************************************
   401                          
   402                          CURSOR_TO_EOPL
   403  e1de a027               !IF SS40=0 {	LDY #COLUMNS-1				; Hard-coded Screen Width-1 (ie: 39)
   404                          } ELSE {	LDY SCNWIDTH				; Soft Screen Width
   405                          		DEY }					; -1
   406                          
   407  e1e0 a6d8               		LDX CursorRow   			; Get Current Cursor Physical Line Number
   408  e1e2 d006               		BNE PL_SKIP1				; Is it Zero? No, ok to proceed, so skip ahead
   409  e1e4 86c6               		STX CursorCol   			; Yes, movement is invalid. Cursor Column on Current Line
   410  e1e6 68                 		PLA					; pull the character from the stack
   411  e1e7 68                 		PLA					; pull the character from the stack
   412  e1e8 d0bc               		BNE IRQ_EPILOG				; jump back up to finish up
   413                          
   414  e1ea b5df               PL_SKIP1	LDA LineLinkTable-1,X			; Get PREVIOUS line's Line Link value
   415  e1ec 3005               		BMI PL_SKIP2				; Is HI BIT SET? Yes, skip ahead
   416  e1ee ca                 		DEX					; No, it's ok to go back to previous line
   417  e1ef b5df               		LDA LineLinkTable-1,X			; Get PREVIOUS line's Line Link value
   418  e1f1 a04f               		LDY #COLUMNS*2-1			; Hard-coded Two Screen Lines - 1 (ie: 79)
   419                          
   420  e1f3 ca                 PL_SKIP2	DEX
   421  e1f4 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   422  e1f6 85c5               		STA ScrPtr+1				; Store to Current Screen Line Address pointer
   423  e1f8 bda6e7             		LDA Line_Addr_Lo,X			; Get LO byte from ROM table
   424  e1fb 85c4               		STA ScrPtr    				; Store to Current Screen Line Address pointer
   425  e1fd 84c6               		STY CursorCol   			; Store to Cursor Column on Current Line
   426  e1ff 84d5               		STY RightMargin   			; Store to Physical Screen Line Length
   427  e201 60                 		RTS
   428                          
   429                          ;*********************************************************************************************************
   430                          ;** CHROUT_SCREEN [E202] (Called from Jump Table)
   431                          ;** $E202 - FIXED ENTRY POINT! Some BASIC/KERNAL rouines bypass the Jump Table and jump directly here
   432                          ;** Output Character to Screen Dispatch 
   433                          ;*********************************************************************************************************
   434                          
   435                          		!IF NOFILL=0 { !FILL $e202-*,$aa }	; FIXED ENTRY POINT! This must not move!
   436                          
   437                          ;#########################################################################################################
   438                          
   439  e202 48                 CHROUT_SCREEN	PHA
   440  e203 85d9               		STA DATAX				; Current Character to Print
   441  e205 8a                 		TXA
   442  e206 48                 		PHA
   443  e207 98                 		TYA
   444  e208 48                 		PHA
   445                          ;							80-column machines have JMP(SCROV) here.
   446                          ;							where SCROV would normally point to 'CHROUT_NORMAL'
   447                          
   448                          ;*********************************************************************************************************
   449                          ;** CHROUT_NORMAL [E209]
   450                          ;** Output Character to Screen. Character to print must be in DATAX.
   451                          ;** On 80 column machines, SCROV vector would point here
   452                          ;*********************************************************************************************************
   453                          
   454  e209 a900               CHROUT_NORMAL	LDA #0
   455  e20b 85ac               		STA CRSW   				; Flag: INPUT or GET from Keyboard
   456  e20d a4c6               		LDY CursorCol   			; Cursor Column on Current Line
   457  e20f a5d9               		LDA DATAX  				; Current Character to Print
   458  e211 297f               		AND #$7F				; Mask off top bit (graphics characters)
   459                          
   460                          ;[PATCH]	--------------------------------------- Check for ESC Character
   461                          
   462                          
   463                          !IF ESCCODES=1 {
   464  e213 4cafeb             		JMP CheckESC				; Check for ESC as last Char, then ESC as current Char. If so, perform it.
   465  e216 8d8203             ESC_DONE	STA LASTCHAR				; Save the character
   466                          
   467                          } ELSE {
   468                          		CMP #$1B				; <ESC>	key? **** Also SHIFT-ESC $9B (Conflicts with COLOUR CODE!)
   469                          		BNE CHROUT_CHECK
   470                          		JMP ESCAPE				; Cancel RVS/INS/QUOTE modes
   471                          }
   472                          ESC_DONE2
   473                          
   474                          ;[E21A]		--------------------------------------- Reload character and check HIGH BIT
   475                          
   476  e219 a5d9               CHROUT_CHECK	LDA DATAX  				; Current Character to Print
   477  e21b 20baed             !IF COLOURPET=1 { JSR CheckColourCodes }		; Check table of color values @@@@@@@@@@@@@@@@ COLOURPET
   478  e21e 1003               		BPL CHROUT_LO				; Is top bit CLEAR? Yes, handle UNSHIFTED Character
   479  e220 4ccee2             		JMP CHROUT_HI				; No, Handle SHIFTED Character
   480                          
   481                          ;*********************************************************************************************************
   482                          ;** Character Output with HIGH BIT CLEAR [E224]
   483                          ;** This routine handles characters in the range 0 to 127.
   484                          ;** Checked: RETURN,DELETE,RVS,HOME,CRSR-RIGHT,CRSR-DOWN,ERASE-EOL,TEXT,BELL,TAB
   485                          ;*********************************************************************************************************
   486                          
   487                          ;		--------------------------------------- Check for RETURN
   488                          
   489  e223 c90d               CHROUT_LO	CMP #$0D				; Is it <RETURN>?
   490  e225 d003               		BNE COU_SKIP1				; No, skip ahead
   491  e227 4cb4e3             		JMP CURSOR_RETURN			; Yes, Handle <RETURN>
   492                          
   493                          ;		--------------------------------------- Check for Control Codes Range (0-31)
   494                          
   495  e22a c920               COU_SKIP1 	CMP #$20				; <SPACE>
   496  e22c 9008               		BCC COU_SKIP2				; No, it's 0-31
   497  e22e 293f               		AND #$3F				; Yes, Mask off HI BIT
   498  e230 2067e1             		JSR CheckQuote				; Switch Quote flag if found
   499  e233 4c76e1             		JMP CHAR_TO_SCREEN2
   500                          
   501  e236 a6dc               COU_SKIP2	LDX INSRT  				; Flag: Insert Mode, >0 = # INSTs
   502  e238 f003               		BEQ COU_SKIP3				; Is FLAG=0? Yes, skip ahead
   503  e23a 4c7ae1             		JMP CHAR_TO_SCREEN3
   504                          
   505                          ;		--------------------------------------- Check for DELETE
   506                          
   507  e23d c914               COU_SKIP3	CMP #$14				; Is it <DEL>?
   508  e23f d019               		BNE COU_SKIP6				; No, skip ahead
   509                          
   510                          ;		--------------------------------------- DELETE - Check if it would wrap to previous line
   511                          
   512  e241 88                 		DEY					; Yes, move to the left
   513  e242 84c6               		STY CursorCol   			; Cursor Column on Current Line
   514  e244 1006               		BPL COU_SKIP4
   515  e246 20dee1             		JSR CURSOR_TO_EOPL			; Back to previous line (rename this label?)
   516  e249 4c4fe2             		JMP COU_SKIP5
   517                          
   518                          ;		--------------------------------------- Perform DELETE
   519                          
   520                          COU_SKIP4
   521                          !IF COLOURPET=0 {
   522                          		INY
   523                          		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   524                          		DEY		
   525                          		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
   526                          		INY
   527                          		CPY RightMargin   			; Physical Screen Line Length
   528                          		BNE COU_SKIP4
   529                          } ELSE {
   530  e24c 2074ee             		JSR ColourPET_Scroll_Left		; Scroll both Screen and Colour LEFT	@@@@@@@@@@@@@@ ColourPET
   531                          }
   532                          
   533                          COU_SKIP5
   534  e24f a920               		LDA #$20				; <SPACE>
   535  e251 91c4               		STA (ScrPtr),Y				; Put it on the screen!
   536                          !IF COLOURPET=1 {
   537  e253 adf28b             		LDA COLOURV				; Get the current Colour		@@@@@@@@@@@@@@@ ColourPET
   538  e256 91c0               		STA (COLOURPTR),Y			; Put it to Colour MEM			@@@@@@@@@@@@@@@ ColourPET
   539                          }
   540  e258 d029               		BNE COU_SKIP11
   541                          
   542  e25a a6cd               COU_SKIP6	LDX QuoteMode   			; Flag: Editor in Quote Mode
   543  e25c f003               		BEQ COU_SKIP7
   544  e25e 4c7ae1             		JMP CHAR_TO_SCREEN3
   545                          
   546                          ;		--------------------------------------- Check for RVS
   547                          
   548  e261 c912               COU_SKIP7	CMP #$12				; Is it <RVS>?
   549  e263 d004               		BNE COU_SKIP8
   550  e265 859f               		STA ReverseFlag    			; Flag: Print Reverse Chars. -1=Yes
   551  e267 f01a               		BEQ COU_SKIP11
   552                          
   553                          ;		--------------------------------------- Check for HOME
   554                          
   555  e269 c913               COU_SKIP8	CMP #$13				; Is it <HOME>?
   556  e26b d003               		BNE COU_SKIP9				; No, skip ahead
   557  e26d 206ee0             		JSR CURSOR_HOME				; Cursor to start of line
   558                          
   559                          ;		--------------------------------------- Check for CURSOR RIGHT
   560                          
   561  e270 c91d               COU_SKIP9	CMP #$1D				; Is it <CRSR-RIGHT>?
   562  e272 d012               		BNE COU_SKIP12
   563  e274 c8                 		INY
   564  e275 84c6               		STY CursorCol   			; Cursor Column on Current Line
   565  e277 88                 		DEY
   566  e278 c4d5               		CPY RightMargin   			; Physical Screen Line Length
   567  e27a 9007               		BCC COU_SKIP11
   568  e27c 209ee3             		JSR CURSOR_DOWN				; Move Cursor to next line
   569  e27f a000               		LDY #$00
   570  e281 84c6               COU_SKIP10	STY CursorCol   			; Cursor Column on Current Line
   571  e283 4ca6e1             COU_SKIP11	JMP IRQ_EPILOG				; Finish Up
   572                          
   573                          ;		--------------------------------------- Check for CURSOR DOWN
   574                          
   575  e286 c911               COU_SKIP12	CMP #$11				; Is it <CRSR-DOWN>?
   576  e288 d011               		BNE COU_SKIP14				; No, skip ahead
   577  e28a 18                 		CLC
   578  e28b 98                 		TYA
   579  e28c 6928               !IF SS40=0 {	ADC #COLUMNS				; Add Fixed Screen Width for next line
   580                          } ELSE {	ADC SCNWIDTH }				; Add Soft Screen Width
   581  e28e a8                 		TAY
   582  e28f c5d5               		CMP RightMargin   			; Compare it to Screen Line Length
   583  e291 90ee               		BCC COU_SKIP10				; Less, so it's ok
   584  e293 f0ec               		BEQ COU_SKIP10				; Equal, also ok
   585  e295 209ee3             		JSR CURSOR_DOWN				; More, so Move Cursor to next line
   586  e298 4ca6e1             COU_FINISH	JMP IRQ_EPILOG				; Finish Up
   587                          
   588                          ;		--------------------------------------- Check for ERASE TO END OF LINE
   589                          
   590                          COU_SKIP14	!IF BUGFIX=0 { CMP #$10 }		; Is it CTRL-P? (BUG!)  This should be #10 or #$16
   591  e29b c916               		!IF BUGFIX=1 { CMP #$16 }		; Is it CTRL-V? (BUG is FIXED!)
   592  e29d d006               		BNE COU_SKIP15				; No, skip ahead
   593                          
   594                          ;[E2D4]		--------------------------------------- Erase to End of Line
   595                          
   596                          !IF COLOURPET=1 {
   597  e29f 20a6ee             		JSR ERASE_TO_EOL			; Replace with ColourPET Version
   598  e2a2 4c98e2             		JMP COU_FINISH				; Jump to continue
   599                          } ELSE {
   600                          
   601                          ERASE_TO_EOL						; Original Routine
   602                          		LDA #$20				; Yes, set character to <SPACE>
   603                          		DEY
   604                          ETEL_LOOP 	INY					; LOOP[
   605                          		STA (ScrPtr),Y				;   Store <SPACE> to screen
   606                          		CPY RightMargin				;   Is it end of line?
   607                          		BCC ETEL_LOOP				; ] No, loop back for more
   608                          		BCS COU_FINISH				; Yes, Finish up
   609                          }
   610                          ;		--------------------------------------- Check for TEXT MODE
   611                          
   612  e2a5 c90e               COU_SKIP15	CMP #$0E				; Is it <TEXT>?
   613  e2a7 d005               		BNE COU_SKIP16				; No, skip ahead
   614  e2a9 200fe6             		JSR CRT_SET_TEXT			; Yes, Set screen to TEXT mode
   615  e2ac 30ea               		BMI COU_FINISH				; Finish up
   616                          
   617                          ;		--------------------------------------- Check for BELL
   618                          
   619  e2ae c907               COU_SKIP16	CMP #$07				; Is it <BELL>?
   620  e2b0 d005               		BNE COU_SKIP17				; No, skip ahead
   621  e2b2 2057e6             		JSR BEEP				; Ring BELL
   622  e2b5 f0e1               		BEQ COU_FINISH				; Finish up
   623                          
   624                          ;		--------------------------------------- Check for TAB
   625                          
   626  e2b7 c909               COU_SKIP17	CMP #$09				; Is it <TAB>?
   627  e2b9 d0dd               		BNE COU_FINISH				; Finish up
   628                          
   629  e2bb c4d5               COU_SKIP18	CPY RightMargin   			; Physical Screen Line Length
   630  e2bd 9007               		BCC COU_SKIP20
   631  e2bf a4d5               		LDY RightMargin   			; Physical Screen Line Length
   632                          
   633  e2c1 84c6               COU_SKIP19	STY CursorCol   			; Cursor Column on Current Line
   634  e2c3 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   635                          
   636  e2c6 c8                 COU_SKIP20	INY
   637  e2c7 207be5             		JSR CHECK_TAB				; Check TAB
   638  e2ca f0ef               		BEQ COU_SKIP18				; Is this a TAB position?
   639  e2cc d0f3               		BNE COU_SKIP19				; No, Loop back
   640                          
   641                          ;*********************************************************************************************************
   642                          ;** CHROUT_HI [$E2D5]
   643                          ;** Character Output when High Bit SET (characters in the range 128 to 256).
   644                          ;** Handles: INS,CRSR-UP,RVS-OFF,CRSR-LEFT,CLR,ERASE-SOL,GRAPHICS,BELL,SET-TAB
   645                          ;*********************************************************************************************************
   646                          
   647                          CHROUT_HI
   648  e2ce 297f               		AND #$7F				; strip off top bit
   649  e2d0 c97f               		CMP #$7F				; is it $FF?
   650  e2d2 d002               		BNE COH_SKIP1				; No, skip
   651  e2d4 a95e               		LDA #$5E				; Yes, substitute with $5E (PI character)
   652                          
   653  e2d6 c920               COH_SKIP1	CMP #$20				; Is it <SPACE>?
   654  e2d8 9003               		BCC COH_SKIP2				; Less? Yes, skip ahead and check more
   655  e2da 4c74e1             		JMP CHAR_TO_SCREEN			; 32 to 127 -> 160-255. Jump and print it
   656                          
   657                          ;[E2E4]		--------------------------------------- Check for SHIFT-RETURN
   658                          
   659  e2dd c90d               COH_SKIP2	CMP #$0D				; Is it <SHIFT-RETURN>?
   660  e2df d003               		BNE COH_SKIP3				; No, skip ahead (continue)
   661  e2e1 4cb4e3             		JMP CURSOR_RETURN			; Yes, handle it
   662                          
   663                          ;[E2EB]		--------------------------------------- Check Quote Mode
   664                          
   665  e2e4 a6cd               COH_SKIP3	LDX QuoteMode   			; Flag: Editor in Quote Mode
   666  e2e6 d028               		BNE COH_SKIP6				; No, skip ahead
   667                          
   668                          ;[E2EF]		--------------------------------------- Check for INSERT
   669                          
   670  e2e8 c914               		CMP #$14				; Is it <INS>? (SHIFT-DEL)
   671  e2ea d020               		BNE COH_SKIP5				; No, skip ahead
   672                          
   673                          ;[E2F3]		--------------------------------------- INS was pressed
   674                          
   675  e2ec a4d5               CHECK_INSERT	LDY RightMargin   			; Right margin
   676  e2ee b1c4               		LDA (ScrPtr),Y				; Read the character at the end of the line
   677  e2f0 c920               		CMP #$20				; Is the character a <SPACE>?
   678  e2f2 d004               		BNE COH_SKIP4				; No, skip ahead
   679  e2f4 c4c6               		CPY CursorCol				; Cursor Column on Current Line
   680  e2f6 d007               		BNE DO_INSERT
   681                          
   682  e2f8 c04f               COH_SKIP4	CPY #COLUMNS*2-1			; Hard Coded Screen Width*2-1 (79)
   683  e2fa f087               		BEQ COU_SKIP11				; Yes, go back up for more
   684  e2fc 20f8e6             		JSR WIN_SCROLL_DN			; Check for and perform scrolling DOWN
   685                          
   686                          ;[E306]		--------------------------------------- Do INSERT
   687                          
   688  e2ff a4d5               DO_INSERT 	LDY RightMargin   			; Start at right margin
   689                          
   690                          !IF COLOURPET=0 {
   691                          INS_LOOP1 	DEY					; LOOP[  move back one
   692                          		LDA (ScrPtr),Y 				;   Get character from screen
   693                          		INY					;   Next character
   694                          		STA (ScrPtr),Y				;   Put character back to screen
   695                          		DEY					;   Next position
   696                          		CPY CursorCol   			;   Have we reached current Cursor position?
   697                          		BNE INS_LOOP1				; ] No, loop back for more
   698                          } ELSE {
   699  e301 2086ee             		JSR ColourPET_Insert
   700                          }	
   701  e304 a920               		LDA #$20				; <SPACE>
   702  e306 91c4               		STA (ScrPtr),Y 				; Write <SPACE> to screen at cursor position
   703  e308 e6dc               		INC INSRT				; Flag: Insert Mode, >0 = # INSTs
   704  e30a d058               		BNE COH_FINISH
   705                          
   706  e30c a6dc               COH_SKIP5	LDX INSRT  				; Flag: Insert Mode, >0 = # INSTs
   707  e30e f005               		BEQ COH_CHECK1
   708                          
   709  e310 0940               COH_SKIP6	ORA #$40				; Set BIT 6
   710  e312 4c7ae1             		JMP CHAR_TO_SCREEN3			; Print it
   711                          
   712                          ;[E324]		--------------------------------------- Check for CURSOR UP
   713                          
   714  e315 c911               COH_CHECK1	CMP #$11				; Is it <CRSR-UP>? (SHIFT-CRSR-DOWN)
   715  e317 d02b               		BNE COH_CHECK2
   716                          
   717                          ;[E32A]		--------------------------------------- Do Cursor UP
   718                          
   719  e319 a5c6               		LDA CursorCol   			; Cursor Column on Current Line
   720  e31b c928               !IF SS40=0 {	CMP #COLUMNS				; Compare to Fixed Screen Width
   721                          } ELSE {	CMP SCNWIDTH }				; Compare to Soft Screen Width
   722  e31d 9006               		BCC COH_SKIP7				; Is it less? No, skip ahead
   723  e31f e928               !IF SS40=0 {	SBC #COLUMNS				; Yes, subtract Fixed Screen Width
   724                          } ELSE {	SBC SCNWIDTH }				; Yes, subtract Soft Screen Width
   725  e321 85c6               		STA CursorCol   			; Cursor Column on Current Line
   726  e323 b03f               		BCS COH_FINISH
   727                          
   728  e325 a6d8               COH_SKIP7	LDX CursorRow   			; Current Cursor Physical Line Number
   729  e327 f03b               		BEQ COH_FINISH
   730  e329 b5df               		LDA MYCH,X				; Serial Word Buffer
   731  e32b 1007               		BPL COH_SKIP8
   732  e32d c6d8               		DEC CursorRow   			; Current Cursor Physical Line Number
   733  e32f 2074e0             		JSR CURSOR_LM				; Cursor to start of line
   734  e332 9030               		BCC COH_FINISH
   735                          
   736  e334 ca                 COH_SKIP8	DEX
   737  e335 ca                 		DEX
   738  e336 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   739  e338 2074e0             		JSR CURSOR_LM				; Cursor to start of line
   740  e33b a5c6               		LDA CursorCol   			; Cursor Column on Current Line
   741  e33d 18                 		CLC
   742  e33e 6928               		ADC #COLUMNS
   743  e340 85c6               		STA CursorCol				; Cursor Column on Current Line
   744  e342 d020               		BNE COH_FINISH
   745                          
   746                          ;[E353]		--------------------------------------- Check for RVS OFF
   747                          
   748  e344 c912               COH_CHECK2	CMP #$12				; Is it <OFF>? (SHIFT-RVS)
   749  e346 d006               		BNE COH_CHECK3				; No, skip ahead
   750  e348 a900               		LDA #0					; Set RVS OFF
   751  e34a 859f               		STA ReverseFlag    			; Store it
   752  e34c f016               		BEQ COH_FINISH
   753                          
   754                          ;[E35D]		--------------------------------------- Check for CURSOR LEFT
   755                          
   756  e34e c91d               COH_CHECK3	CMP #$1D				; Is it <CRSR-LEFT>? (SHIFT-CRSR-RIGHT)
   757  e350 d00b               		BNE COH_CHECK4				; No, skip ahead
   758                          
   759  e352 88                 		DEY
   760  e353 84c6               		STY CursorCol   			; Cursor Column on Current Line
   761  e355 100d               		BPL COH_FINISH
   762  e357 20dee1             		JSR CURSOR_TO_EOPL
   763  e35a 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   764                          
   765                          ;[E36C]		--------------------------------------- Check for CLEAR SCREEN
   766                          
   767  e35d c913               COH_CHECK4	CMP #$13				; Is it <CLR>? (SHIFT-HOME)
   768  e35f d006               		BNE COH_CHECK5				; No, skip ahead
   769  e361 2042e0             		JSR WIN_CLEAR				; Yes, Clear the Screen
   770  e364 4ca6e1             COH_FINISH	JMP IRQ_EPILOG				; Finish Up
   771                          
   772                          ;[E376]		--------------------------------------- Check for ERASE TO START OF LINE
   773                          
   774                          COH_CHECK5	
   775                          !IF COLOURPET=0 {
   776                          		CMP #$16				; Is it <ERASE-END>? (SHIFT-CTRL-V) - CONFLICTS with COLOURPET!
   777                          		BNE COH_CHECK6				; No, skip ahead
   778                          } ELSE {
   779  e367 4c7ce3             		JMP COH_CHECK6				; Just Skip ahead		@@@@@@@@@@ COLOURPET
   780                          }
   781                          
   782                          ;*********************************************************************************************************
   783                          ;** ERASE_TO_SOL / ESCAPE_P [E37A]
   784                          ;** Erases from cursor to Start of Line
   785                          ;*********************************************************************************************************
   786                          
   787                          ESCAPE_P
   788                          ERASE_TO_SOL
   789  e36a a920               		LDA #$20				; <SPACE>
   790  e36c a000               		LDY #0					; Start at Left Margin
   791  e36e c4c6               ESOL_LOOP	CPY CursorCol   			; LOOP[  Cursor Column on Current Line
   792  e370 b0f2               		BCS COH_FINISH				;   Finish up
   793  e372 91c4               		STA (ScrPtr),Y				;   Pointer: Current Screen Line Address
   794                          !IF COLOURPET=1 {
   795  e374 adf28b             		LDA COLOURV				;   Current Colour
   796  e377 91c0               		STA (COLOURPTR),Y			;   Write Current Colour to colour RAM
   797                          }
   798  e379 c8                 		INY
   799  e37a d0f2               		BNE ESOL_LOOP				; ] Loop back for more
   800                          
   801                          ;[E387]		--------------------------------------- Check for SET GRAPHICS MODE
   802                          
   803  e37c c90e               COH_CHECK6	CMP #$0E				; Is it <GRAPHICS>? (SHIFT-TEXT)
   804  e37e d005               		BNE COH_CHECK7				; No, skip ahead
   805  e380 2017e6             		JSR CRT_SET_GRAPHICS			; Yes, Set screen to graphics mode
   806  e383 30df               		BMI COH_FINISH				; Finish up
   807                          
   808                          ;[E390]		--------------------------------------- Check for BELL
   809                          
   810  e385 c907               COH_CHECK7	CMP #$07				; Is it <BELL>?
   811  e387 d005               		BNE COH_CHECK8				; No, skip ahead
   812  e389 2054e6             		JSR BEEP_BEEP				; Ring the Bell
   813  e38c f0d6               		BEQ COH_FINISH				; Finish up
   814                          
   815                          ;[E399]		--------------------------------------- Check for SET TAB
   816                          
   817  e38e c909               COH_CHECK8	CMP #$09				; Is it <SET-TAB>? (SHIFT-TAB)
   818  e390 d0d2               		BNE COH_FINISH				; No, Finish up
   819  e392 207be5             		JSR CHECK_TAB				; Set TAB
   820  e395 4def03             		EOR TABS   				; Table of 80 bits to set TABs (80col)
   821  e398 9df003             		STA $03F0,X
   822  e39b 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   823                          
   824                          ;*********************************************************************************************************
   825                          ;** CURSOR_DOWN  [$E3A9]
   826                          ;** Do Cursor DOWN, Go to next line. If at bottom of window SCROLL UP.
   827                          ;*********************************************************************************************************
   828                          
   829  e39e 38                 CURSOR_DOWN	SEC
   830  e39f 46a3               		LSR InputRow   				; Cursor Y-X Pos. at Start of INPUT
   831  e3a1 a6d8               		LDX CursorRow   			; Current Cursor Physical Line Number
   832                          
   833  e3a3 e8                 CD_LOOP1	INX					; LOOP[
   834  e3a4 e019               		CPX #ROWS				;   Last line of screen?
   835  e3a6 d003               		BNE CD_SKIP
   836  e3a8 20c9e3             		JSR WIN_SCROLL_UP			;   Scroll Screen Up
   837                          
   838  e3ab b5e0               CD_SKIP		LDA LineLinkTable,X			;   Screen Line Link Table / Editor Temps (40 col)
   839  e3ad 10f4               		BPL CD_LOOP1				; ] Is HI bit CLEAR? Yes then go back for more
   840  e3af 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
   841  e3b1 4c74e0             		JMP CURSOR_LM				; Cursor to start of line
   842                          
   843                          ;*********************************************************************************************************
   844                          ;** CURSOR_RETURN  [E3BF]
   845                          ;** Cursor to start of line, then CURSOR DOWN. Also performs ESCAPE
   846                          ;*********************************************************************************************************
   847                          
   848  e3b4 209ee3             CURSOR_RETURN	JSR CURSOR_DOWN				; Move to next line
   849  e3b7 a900               		LDA #0					; Column 0
   850  e3b9 85c6               		STA CursorCol   			; Set Cursor Column on Current Line
   851                          
   852                          ;*********************************************************************************************************
   853                          ;** ESCAPE / ESCAPE_O [E3C6]
   854                          ;** Cancels Insert, Reverse and Quote modes
   855                          ;*********************************************************************************************************
   856                          
   857                          ESCAPE_O				
   858  e3bb a900               ESCAPE		LDA #0
   859  e3bd 85dc               		STA INSRT  				; Flag: Insert Mode, >0 = # INSTs
   860  e3bf 859f               		STA ReverseFlag    			; Flag: Print Reverse Chars. -1=Yes
   861  e3c1 85cd               		STA QuoteMode   			; Flag: Editor in Quote Mode
   862                          
   863  e3c3 8d8203             !IF ESCCODES = 1 { STA LASTCHAR }
   864                          
   865  e3c6 4ca6e1             		JMP IRQ_EPILOG				; Finish Up
   866                          
   867                          ;*********************************************************************************************************
   868                          ;** WIN_SCROLL_UP / ESCAPE_V  [E3D1] (Called from Jump Table)
   869                          ;** Scrolls entire screen UP. Also scroll up line-link table
   870                          ;*********************************************************************************************************
   871                          ; IF SS40=0 then we include the routine here in it's normal location, otherwise relocate it to EXT space.
   872                          

; ******** Source: editrom40scrollup.asm
     1                          ;*********************************************************************************************************
     2                          ;** WIN_SCROLL_UP / ESCAPE_V  [E3D1] (Called from Jump Table)
     3                          ;** Scrolls entire screen UP. Also scroll up line-link table
     4                          ;*********************************************************************************************************
     5                          
     6                          ESCAPE_V
     7                          WIN_SCROLL_UP
     8  e3c9 a219               		LDX #ROWS				; Hard-coded Screen Lines (normally 25)
     9  e3cb 86d8               		STX CursorRow   			; Current Cursor Physical Line Number
    10                          
    11  e3cd a2ff               WSU_LOOP1	LDX #$FF
    12                          
    13                          ;[E3D7]		--------------------------------------- Set up screen pointers, scroll line link table entry for the current line
    14                          
    15  e3cf e8                 WSU_LOOP2	INX					; LOOP[
    16  e3d0 bda6e7             		LDA Line_Addr_Lo,X			;   Screen line address table LO
    17  e3d3 85c4               		STA ScrPtr    				;   Set up Pointer LO for screen scrolling
    18  e3d5 b5e0               		LDA LineLinkTable,X			;   Screen Line Link Table (address table HI)
    19  e3d7 0980               		ORA #$80				;   Make sure HI BIT is set
    20  e3d9 85c5               		STA ScrPtr+1				;   Set up pointer HI for screen scrolling 
    21  e3db e018               		CPX #ROWS-1				;   Last Line?
    22  e3dd b01d               		BCS WSU_SKIP2				;   Yes, so skip ahead to exit loop
    23  e3df b4e1               		LDY LineLinkTable+1,X			;   No, so get NEXT Line's Line Link entry
    24  e3e1 3002               		BMI WSU_SKIP1				;   is HI BIT set? Yes, leave it as is and skip ahead
    25  e3e3 297f               		AND #$7F				;   No, then CLEAR HI BIT
    26                          
    27  e3e5 95e0               WSU_SKIP1	STA LineLinkTable,X			;   Store it in the CURRENT Line Link entry (IE scroll the high bits UP)
    28  e3e7 98                 		TYA
    29  e3e8 0980               		ORA #$80				;   Set HI BIT
    30  e3ea 85c8               		STA SAL+1				;   $C8
    31  e3ec bda7e7             		LDA Line_Addr_Lo+1,X			;   Screen line address table
    32  e3ef 85c7               		STA SAL    				;   Pointer: Tape Buffer/ Screen Scrolling
    33                          
    34                          ;[E3F9]		--------------------------------------- Now we scroll the video screen lines
    35                          
    36  e3f1 a027               !IF SS40=0 {	LDY #COLUMNS-1				;   Hard-coded Screen Width
    37                           } ELSE {	LDY SCNWIDTH }				;   Soft Screen Width
    38                          
    39  e3f3 b1c7               WSU_LOOP3	LDA (SAL),Y 				;   LOOP[[  Read character from screen
    40  e3f5 91c4               		STA (ScrPtr),Y 				;     Write it back
    41  e3f7 88                 		DEY					;     Next character
    42  e3f8 10f9               		BPL WSU_LOOP3				;   ]] Loop back for more
    43  e3fa 30d3               		BMI WSU_LOOP2				; ] Loop back for more
    44                          
    45  e3fc 95e0               WSU_SKIP2	STA LineLinkTable,X			; Store to Screen Line Link Table
    46                          
    47                          ;[E406]		--------------------------------------- Clear the last screen line
    48                          
    49  e3fe a027               !IF SS40=0 {	LDY #COLUMNS-1				;   Hard-coded Screen Width
    50                          } ELSE {	LDY SCNWIDTH				;   Soft Screen Width
    51                          		DEY }					;   -1
    52                          
    53  e400 a920               		LDA #$20				; <SPACE>
    54                          
    55  e402 91c4               WSU_LOOP4	STA (ScrPtr),Y 				; LOOP[  Write <SPACE> to the screen
    56  e404 88                 		DEY					;   Next character
    57  e405 10fb               		BPL WSU_LOOP4				; ] Loop back for more
    58                          
    59  e407 c6d8               		DEC CursorRow   			; Current Cursor Physical Line Number
    60  e409 a5e0               		LDA LineLinkTable			; Screen Line Link Table / Editor Temps (40 col)
    61  e40b 10c0               		BPL WSU_LOOP1				; ] Loop back for more

; ******** Source: editrom40.asm
   873                          }
   874                          
   875                          ;*********************************************************************************************************
   876                          ;** Check Keyboard Scroll Control  [E415]
   877                          ;*********************************************************************************************************
   878                          
   879                          CHECK_SCROLL_CONTROL
   880  e40d ad12e8             		LDA PIA1_Port_B				; Keyboard COL read
   881  e410 c9fe               		CMP #$FE				; Is KEY held down?
   882  e412 d00b               		BNE CSC_SKIP				; No, skip over delay
   883                          
   884                          ;[E41C]		--------------------------------------- Scroll delay
   885                          
   886  e414 a000               		LDY #$00
   887                          
   888  e416 ea                 SCROLL_DELAY	NOP					; LOOP[
   889  e417 ca                 		DEX
   890  e418 d0fc               		BNE SCROLL_DELAY 			; ] Loop back for more
   891  e41a 88                 		DEY
   892  e41b d0f9               		BNE SCROLL_DELAY 			; ] Loop back for more
   893                          
   894  e41d 849e               		STY CharsInBuffer    			; No. of Chars. in Keyboard Buffer (Queue)
   895                          
   896                          ;[E427]		--------------------------------------- Scroll complete
   897                          
   898  e41f a6d8               CSC_SKIP	LDX CursorRow   			; Current Cursor Physical Line Number
   899  e421 60                 		RTS
   900                          
   901                          !IF CRUNCH = 0 {
   902                          		TAX					; Filler
   903                          		TAX					; Filler
   904                          		TAX					; Filler
   905                          		TAX					; Filler
   906                          }
   907                          
   908                          ;*********************************************************************************************************
   909                          ;** Jiffy Clock Timer Correction Patch  [E42E]
   910                          ;*********************************************************************************************************
   911                          
   912  e422 20eaff             ADVANCE_TIMER	JSR UDTIME				; Update System Jiffy Clock. KERNAL routine $FFEA 
   913  e425 eeed03             		INC JIFFY6DIV5				; Counter to speed TI by 6/5 (40col)
   914  e428 aded03             		LDA JIFFY6DIV5				; Counter to speed TI by 6/5 (40col)
   915  e42b c906               		CMP #$06				; 6 IRQ's?
   916  e42d d029               		BNE IRQ_NORMAL2				; No, do normal IRQ
   917  e42f a900               		LDA #0					; Reset IRQ adjustment counter
   918  e431 8ded03             		STA JIFFY6DIV5 				; Counter to speed TI by 6/5 (40col)
   919  e434 f0ec               		BEQ ADVANCE_TIMER			; was IRQ_MAIN		; Do normal IRQ
   920                          
   921                          ;*********************************************************************************************************
   922                          ;** MAIN IRQ ENTRY [E442][E455] (Called from Jump Table) - FIXED ENTRY POINT!
   923                          ;** This entry point must not move! It is called directly from KERNAL
   924                          ;** The CRTC chip's V-Sync line is fed to a VIA to generate IRQ's. When an IRQ is triggered, the
   925                          ;** Clock is updated, the keyboard scanned, ieee polled and tape monitored.
   926                          ;*********************************************************************************************************
   927                          
   928  e436 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e442-*,$aa }	; FIXED ENTRY POINT! This routine must not move!
   929                          
   930                          ;#########################################################################################################
   931                          

; ******** Source: irq.asm
     1                          ; PET/CBM EDIT ROM - IRQ Handler Routines
     2                          ; ================
     3                          ; The IRQ does the work of updating the clock/timer, checking interrupts and calling the keyboard scanner.
     4                          
     5                          
     6                          IRQ_MAIN
     7  e442 48                 		PHA
     8  e443 8a                 		TXA
     9  e444 48                 		PHA
    10  e445 98                 		TYA
    11  e446 48                 		PHA
    12  e447 ba                 		TSX
    13  e448 bd0401             		LDA STACK+4,X
    14  e44b 2910               		AND #16
    15  e44d f003               		BEQ Be452
    16  e44f 6c9200             		JMP (CBINV)	; Vector: BRK Instr. Interrupt [D478]
    17  e452 6c9000             Be452		JMP (CINV)	; Vector: Hardware Interrupt   [E455] Points to 'IRQ_NORMAL'
    18                          
    19                          ;*********************************************************************************************************
    20                          ;** IRQ_NORMAL [$E455]
    21                          ;*********************************************************************************************************
    22                          
    23                          ;************** IRQ (Called from Jump Table)
    24                          ; The IRQ is fired when the CRTC chip does a VSYNC, so the timing is
    25                          ; dependent on the CRTC configuration.
    26                          ; Normally: $E455
    27                          
    28                          IRQ_NORMAL
    29                          		!IF IRQFIX=1 {
    30                          			!IF CODEBASE=0 { JMP ADVANCE_TIMER }
    31                          			!IF CODEBASE=1 { JMP ADVANCE_TIMER }
    32                          			!IF CODEBASE=2 { JSR ADVANCE_TIMER }
    33                          		} ELSE {
    34  e455 20eaff             			JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA 			
    35                          		}
    36                          
    37                          ;		--------------------------------------- Blink the cursor
    38                          
    39                          IRQ_NORMAL2						; ie458
    40  e458 a5a7               		LDA Blink				; Cursor Blink enable: 0 = Flash Cursor
    41  e45a d018               		BNE Be474				; skip it
    42  e45c c6a8               		DEC BLNCT				; Timer: Countdown to Toggle Cursor
    43  e45e d014               		BNE Be474				; skip it
    44                          
    45  e460 a914               		LDA #$14				; default cursor blink rate (20)
    46                          !if REPEATOPT = 1 {
    47                          		BIT RPTFLG				; check repeat flag
    48                          		BPL ie468				; skip if not enabled
    49                          		LDA #2					; make cursor blink immediately
    50                          }
    51  e462 85a8               ie468		STA BLNCT				; store to blink countdown counter
    52  e464 a4c6               		LDY CursorCol				; Column where cursor lives
    53  e466 46aa               		LSR BlinkPhase				; Is it blinking?
    54  e468 b1c4               		LDA (ScrPtr),Y				; Get character from the screen
    55  e46a b004               		BCS Be470				; Yes, skip
    56  e46c e6aa               		INC BlinkPhase				; count
    57  e46e 85a9               		STA CursorChar				; Remember the character at cursor (to be restored when cursor moves)
    58  e470 4980               Be470		EOR #$80				; Flip the reverse bit
    59  e472 91c4               		STA (ScrPtr),Y				; Put it back on the screen
    60                          
    61                          ;		--------------------------------------- Prep for keyboard scanning [$E47B]
    62                          
    63  e474 a000               Be474		LDY #0
    64  e476 ad10e8             		LDA PIA1_Port_A 			; Keyboard ROW select - PIA#1, Register 0
    65                          							; Upper bits: IEEE and Cassette
    66                          							; Lower bits: Keyboard ROW select
    67                          !if CODEBASE<2 {
    68  e479 29f0               		AND #$F0				; Mask off lower 4 bits (reset keyboard scan row)
    69  e47b 8d10e8             		STA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    70  e47e ad10e8             		LDA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    71                          } 
    72                          
    73                          ;		--------------------------------------- Check IEEE and Cassette status
    74                          
    75  e481 0a                 		ASL					; Shift upper bits to lower 
    76  e482 0a                 		ASL 
    77  e483 0a                 		ASL 
    78  e484 1009               		BPL Be487				; Is CASSETTE#1 Sense? No, skip
    79                          
    80  e486 84f9               		STY CAS1				; Yes, Tape Motor Interlock #1
    81  e488 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt
    82  e48b 0908               		ORA #8					; Is CASSETTE#2 Sense?
    83  e48d d009               		BNE Be490				; No, skip
    84                          
    85  e48f a5f9               Be487		LDA CAS1				; Yes, Tape Motor Interlock #1
    86  e491 d008               		BNE Be493				; No, skip
    87                          
    88  e493 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    89  e496 29f7               		AND #$f7				; Mask off bit 4
    90  e498 8d13e8             Be490		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    91  e49b 9009               Be493		BCC Be49e
    92                          
    93  e49d 84fa               		STY CAS2				; Tape Motor Interlock #2
    94  e49f ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
    95  e4a2 0910               		ORA #16
    96  e4a4 d009               		BNE Be4a7
    97  e4a6 a5fa               Be49e		LDA CAS2				; Tape Motor Interlock #2
    98  e4a8 d008               		BNE Be4aa
    99  e4aa ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
   100  e4ad 29ef               		AND #$ef
   101  e4af 8d40e8             Be4a7		STA VIA_Port_B				; VIA Register 0 (flags)
   102  e4b2 20bbe4             Be4aa		JSR SCAN_KEYBOARD			; Scan the keyboard
   103                          
   104  e4b5 2024ef             !IF KEYRESET=1 {  JSR CheckReboot }			; Check for soft reset ******* should this go above Be474 ?????????????????
   105                          
   106  e4b8 4c00e6             		JMP IRQ_END				; Return from Interrupt
   107                          

; ******** Source: editrom40.asm
   932                          
   933                          
   934                          ;*********************************************************************************************************
   935                          ;** KEYBOARD SCANNER  [E4BE]
   936                          ;** The Keyboard is scanned during the IRQ and one keystroke is stored to KEYD. Other routines transfer
   937                          ;** this keystroke to or from a small 10-byte buffer. The keyboard scanner does the actual interfacing to
   938                          ;** the hardware to read the rows and columns of the keyboard matrix. When a key is pressed it gets the
   939                          ;** keycode from the keyboard matrix table. If no key is pressed, then $FF is returned.
   940                          ;*********************************************************************************************************
   941                          
   942                          !IF KEYSCAN=0 { !SOURCE "keyscan-g.asm" }		; Graphic Keyboard

; ******** Source: keyscan-b.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Scan - Business Keyboards
     2                          ; ================
     3                          ; Standard Business Keyboard scanner. Requires one keyboard table.
     4                          ;
     5                          ; OPTIONS: KEYBOARD=7 modifies scanner for CBM-II keyboard (16x6 matrix)
     6                          
     7                          ;--------------- Scan Keyboard (scnkey)
     8                          ; NOTE: The keyboard ROW select is reset to zero in IRQ routine
     9                          
    10                          SCAN_KEYBOARD
    11                          ;!if DEBUG = 1 { INC DBLINE+5 }		; DEBUG - 6th character on top line
    12                          
    13  e4bb a0ff               		LDY #$FF		; No Key
    14  e4bd 84a6               		STY Key_Image		; Key Image
    15  e4bf c8                 		INY
    16  e4c0 8498               		STY KEYFLAGS		; Flag: Print Shifted Chars.
    17  e4c2 adee03             		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    18  e4c5 297f               		AND #$7F
    19  e4c7 8dee03             		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    20                          		!IF KEYBOARD=7 {
    21                          			LDX #$60	; 96 bytes in table. X is used as offset into the table (CBM-II keyboard)
    22                          		} ELSE {
    23  e4ca a250               			LDX #$50	; 80 bytes in table. X is used as offset into the table (normal keyboards)
    24                          		}
    25                          
    26                          SCAN_ROW
    27                          		!IF KEYBOARD=7 {
    28                          			 LDY #$06	; Number of Columns to check = 6 (CBM-II keyboard only)
    29                          		} ELSE {
    30  e4cc a008               			 LDY #$08	; Number of Columns to check = 8 (normal keyboards)
    31                          		}
    32                          
    33  e4ce ad12e8             		LDA PIA1_Port_B 	; Keyboard COL result
    34  e4d1 cd12e8             		CMP PIA1_Port_B 	; Keyboard COL result
    35  e4d4 d0f6               		BNE SCAN_ROW		; Debounce
    36                          
    37  e4d6 4a                 SCAN_COL	LSR			; Shift the value right
    38  e4d7 b021               		BCS SCAN_NEXT2		; If the bit was "1" then key is NOT down. Skip
    39                          
    40                          ;-------------- We have a key press. Look it up in the keyboard matrix
    41                          
    42  e4d9 48                 		PHA			; Save for later
    43  e4da bd4ce7             		LDA KEYBOARD_NORMAL-1,X	; Read Keyboard Matrix (X is offset)
    44  e4dd d006               		BNE SCAN_NOSH		; Is it SHIFT key? No, skip
    45                          
    46                          ;-------------- SHIFT key Detected
    47                          
    48  e4df a901               		LDA #$01		; Set the SHIFT flag
    49  e4e1 8598               		STA KEYFLAGS		; Flag: Print Shifted Chars.
    50  e4e3 d014               		BNE SCAN_NEXT		; No, skip
    51                          
    52                          ;-------------- Non-SHIFT key
    53                          
    54  e4e5 c910               SCAN_NOSH	CMP #$10		; Is it REPEAT?
    55  e4e7 d00a               		BNE SCAN_NORPT		; No, skip
    56                          
    57                          ;-------------- REPEAT key
    58                          
    59  e4e9 adee03             		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    60  e4ec 0980               		ORA #$80
    61  e4ee 8dee03             		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    62  e4f1 3006               		BMI SCAN_NEXT
    63                          
    64  e4f3 c9ff               SCAN_NORPT	CMP #$FF		; Is it "no key"?
    65  e4f5 f002               		BEQ SCAN_NEXT		; Yes, skip
    66                          
    67                          ;-------------- Normal key
    68                          
    69  e4f7 85a6               		STA Key_Image		; Store the key
    70                          
    71  e4f9 68                 SCAN_NEXT	PLA			; Restore value from keyboard scan for next loop
    72  e4fa ca                 SCAN_NEXT2	DEX			; Decrement keyboard table offset
    73  e4fb f008               		BEQ SCAN_GOT		; If 0 we have completed the entire matrix...Process Key Image
    74                          
    75  e4fd 88                 		DEY			; Next COLUMN
    76  e4fe d0d6               		BNE SCAN_COL		; Go back up for next column bit
    77                          
    78                          ;-------------- Completed all bits in ROW, Increment ROW
    79                          
    80  e500 ee10e8             		INC PIA1_Port_A		; Next Keyboard ROW
    81  e503 d0c7               		BNE SCAN_ROW		; More? Yes, loop back
    82                          
    83                          ;-------------- Process Key Image
    84                          
    85  e505 a5a6               SCAN_GOT	LDA Key_Image		; Key Image
    86  e507 c597               		CMP KEYPRESSED		; Current Key Pressed: 255 = No Key
    87  e509 f007               		BEQ SCAN_PRESS		; If key is the same then it's being held down
    88                          
    89  e50b a210               		LDX #$10
    90  e50d 8ee903             		STX DELAY		; Repeat Delay Counter
    91  e510 d034               		BNE SCAN_REC
    92                          
    93  e512 2cee03             SCAN_PRESS	BIT RPTFLG		; Check Repeat Flag: $80 = Repeat, $40 = disable
    94  e515 3020               		BMI SCAN_DELAY2
    95  e517 7061               		BVS SCAN_OUT		; Exit
    96  e519 c9ff               		CMP #$FF		; No key?
    97  e51b f05d               		BEQ SCAN_OUT		; Exit
    98  e51d c914               		CMP #$14
    99  e51f f00c               		BEQ SCAN_DELAY
   100  e521 c920               		CMP #$20
   101  e523 f008               		BEQ SCAN_DELAY
   102  e525 c91d               		CMP #$1D
   103  e527 f004               		BEQ SCAN_DELAY
   104  e529 c911               		CMP #$11
   105  e52b d04d               		BNE SCAN_OUT		; Exit
   106                          
   107  e52d aee903             SCAN_DELAY	LDX DELAY		; Repeat Delay Counter
   108  e530 f005               		BEQ SCAN_DELAY2
   109  e532 cee903             		DEC DELAY		; Repeat Delay Counter
   110  e535 d043               		BNE SCAN_OUT		; Exit
   111                          
   112  e537 ceea03             SCAN_DELAY2	DEC KOUNT		; Repeat Speed Counter
   113  e53a d03e               		BNE SCAN_OUT		; Exit
   114  e53c a204               		LDX #$04
   115  e53e 8eea03             		STX KOUNT		; Repeat Speed Counter
   116  e541 a69e               		LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   117  e543 ca                 		DEX			; One less
   118  e544 1034               		BPL SCAN_OUT		; Exit
   119                          
   120  e546 8597               SCAN_REC	STA KEYPRESSED		; Current Key Pressed: 255 = No Key
   121  e548 c9ff               		CMP #$FF		; No Key?
   122  e54a f02e                		BEQ SCAN_OUT		; Yes, exit
   123                          
   124  e54c aa                 		TAX
   125  e54d 08                 		PHP
   126  e54e 297f               		AND #$7F		; Mask off upper bit (non-shiftable flag in key matrix byte)
   127  e550 28                 		PLP
   128  e551 3017               		BMI SCAN_NORM
   129                          
   130                          ;-------------- Process SHIFT key flag with Numeric Keys or Graphic keys
   131                          
   132  e553 4698               		LSR KEYFLAGS		; Check for SHIFT
   133  e555 9013               		BCC SCAN_NORM		; No, store as-is
   134  e557 c92c               		CMP #$2C		; Is it less than 2C? 
   135  e559 900d               		BCC SCAN_SHIFT		; Yes, skip
   136  e55b c93c               		CMP #$3C		; Is it greater than 3C?
   137  e55d b009               		BCS SCAN_SHIFT		; Yes, skip
   138  e55f e90f               		SBC #$0F		; No, it must me Numeric so subtract 15
   139  e561 c920               		CMP #$20		; Is it above <SPACE>
   140  e563 b005               		BCS SCAN_NORM		; Yes
   141                          
   142  e565 6920               		ADC #$20		; Add 32 to convert to shifted symbol on number key
   143  e567 2c                 		!byte $2C		; Hide the next instruction trick
   144                          
   145  e568 0980               SCAN_SHIFT	ORA #$80		; Set upper bit for Graphics Symbol
   146                          
   147                          ;-------------- Put the KEY into the Buffer (Key in accumulator)
   148                          
   149                          SCAN_NORM
   150                          
   151  e56a 4c76ed             !IF ESCCODES=1 { JMP EUROSWAP }		; Check if Eurokeys need swapping
   152                          
   153  e56d a69e               SCAN_NORM2	LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   154  e56f eceb03             		CPX XMAX		; Size of Keyboard Buffer
   155  e572 b006               		BCS SCAN_OUT		; Exit if buffer full
   156  e574 9d6f02             		STA KEYD,X		; Put the key into the buffer
   157                          !IF BACKARROW=0 {
   158                          		INX			; Increment character count
   159                          		STX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   160                          } ELSE {
   161  e577 2042ef             		JSR TestBackArrow	; Patch/Hack to use SHIFT-BACKARROW as screen mode toggle (text/graphic)
   162                          }
   163                          
   164                          !if KEYBOARD != 1 {
   165                          ;		Compensate for STOP key not in standard position
   166                          		CMP #3			; Is keycode "3" (STOP key)?
   167                          		BNE SCAN_OUT
   168                          		LDA #$EF		; fool kernal into thinking STOP is pressed
   169                          		STA STKEY		; store it
   170                          }

; ******** Source: editrom40.asm
   943  e57a 60                 }		; Business Keyboard
   944                          !IF KEYSCAN=2 { !SOURCE "keyscan-din.asm" }		; German DIN Keyboard
   945                          !IF KEYSCAN=3 { !SOURCE "keyscan-c64.asm" }		; C64 Keyboard
   946                          !IF KEYSCAN=4 { !SOURCE "keyscan-cbm2.asm" }		; CBM2 Keyboard (future implementation)
   947                          
   948                          ;*********************************************************************************************************
   949                          ;** JUMP_TO_TAB [E588]
   950                          ;** Tab positions are stored in a table of 80 bits (10 bytes). 
   951                          ;*********************************************************************************************************
   952                          
   953  e57b 98                 CHECK_TAB	TYA
   954  e57c 2907               		AND #$07				; Only look at lower 3 bits (values 0 to 7)
   955  e57e aa                 		TAX
   956  e57f bdeae7             		LDA POWERSOF2,X				; GetTable of BIT position values
   957  e582 8def03             		STA TABS   				; Table of 80 bits to set TABs
   958  e585 98                 		TYA	
   959  e586 4a                 		LSR
   960  e587 4a                 		LSR
   961  e588 4a                 		LSR
   962  e589 aa                 		TAX
   963  e58a bdf003             		LDA TABS+1,X				; Get the BITS for that group of tabs (Table of 80 bits to set TABs)
   964  e58d 2cef03             		BIT TABS   				; Set FLAG for testing???? (Table of 80 bits to set TABs)
   965  e590 60                 		RTS
   966                          
   967                          ;################################################################################
   968                          ;## WIN_CLEAR  [$RELOCATED]  (Called from Jump Table) 
   969                          ;################################################################################
   970                          ; When the Soft40 option is enabled we must relocate this routine here since it will not fit in it's normal
   971                          ; location. When finished we must jump back to the end of it's normal position
   972                          
   973                          !IF SS40=1 {
   974                          		!SOURCE "editrom40cls.asm" 
   975                          		JMP CURSOR_HOME				;The WIN_CLR routine flows into the HOME routine
   976                          }
   977                          
   978                          ;################################################################################
   979                          
   980  e591 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !fill $e600-*,$aa }	;########################
   981                          
   982                          ;################################################################################
   983                          
   984                          ;*********************************************************************************************************
   985                          ;** IRQ_END  [E600] (Called from Jump Table) - FIXED ENTRY POINT!
   986                          ;** The IRQ routine jumps here when completed. Do not modify this routine!
   987                          ;*********************************************************************************************************
   988                          
   989                          		!IF NOFILL=0 { !FILL $e600-*,$aa }	;FIXED ENTRY POINT! This routine must not move! It is called directly from KERNAL
   990                          
   991                          ;#########################################################################################################
   992                          
   993  e600 68                 IRQ_END		PLA
   994  e601 a8                 		TAY
   995  e602 68                 		PLA
   996  e603 aa                 		TAX
   997  e604 68                 		PLA
   998  e605 40                 		RTI
   999                          
  1000                          ;*********************************************************************************************************
  1001                          ;** RESTORE_CHR_AT_CRSR  [E606]
  1002                          ;** This routine is called to put the character back at the cursor position.
  1003                          ;** It is called to put the initial character on the screen and as part of the cursor blinking routine.
  1004                          ;** NOTE: ColourPET: DOES NOT set/change COLOUR ATTRIBUTE!
  1005                          ;*********************************************************************************************************
  1006                          
  1007                          RESTORE_CHR_AT_CRSR
  1008  e606 a4c6               		LDY CursorCol  				; Cursor Column on Current Line
  1009  e608 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
  1010  e60a a902               		LDA #$02
  1011  e60c 85a8               		STA BLNCT  				; Timer: Countdown to Toggle Cursor
  1012  e60e 60                 		RTS
  1013                          
  1014                          ;*********************************************************************************************************
  1015                          ;** CRT_SET_TEXT  [$E60F]  (Called from Jump Table) 
  1016                          ;** TEXT MODE lower case, upper case and limited graphics.
  1017                          ;** Characters take 10 scanlines (normally)
  1018                          ;*********************************************************************************************************
  1019                          
  1020  e60f a9bf               CRT_SET_TEXT	LDA #<CRT_CONFIG_TEXT			; Point to CRTC Table
  1021  e611 a2e7               		LDX #>CRT_CONFIG_TEXT			; Point to CRTC Table
  1022  e613 a00e               		LDY #$0E				; Character Set = TEXT
  1023  e615 d006               		BNE CRT_PROGRAM
  1024                          
  1025                          ;*********************************************************************************************************
  1026                          ;** CRT_SET_GRAPHICS  [$E617]  (Called from Jump Table) 
  1027                          ;** GRAPHICS mode has uppercase and full graphics.
  1028                          ;** Characters take 8 scanlines
  1029                          ;*********************************************************************************************************
  1030                          
  1031                          CRT_SET_GRAPHICS
  1032  e617 a9d1               		LDA #<CRT_CONFIG_GRAPHICS      		; Point to CRTC Table
  1033  e619 a2e7               		LDX #>CRT_CONFIG_GRAPHICS      		; Point to CRTC Table
  1034  e61b a00c               		LDY #$0C				; Character Set = GRAPHICS
  1035                          
  1036                          ;*********************************************************************************************************
  1037                          ;** CRT_PROGRAM  [$E61D] (Called from Jump Table)
  1038                          ;** The CRTC controller controls the parameters for generating the display on the monitor. The CRTC chip
  1039                          ;** has several registers that must be set properly according to the type of connected display. These set
  1040                          ;** characters on the line, left and right margins, lines on the screen, height of each line and
  1041                          ;** positioning of the top of the screen. The parameters are read from a table and written to the CRTC
  1042                          ;** controller chip. The VIA chip is used to select which of the two fonts from the CHARACTER ROM is used.
  1043                          ;**
  1044                          ;** Parameters: Table pointer in A/X, CHRSET in Y
  1045                          ;** OPTIONS: 'SS40' uses new routine in upper rom
  1046                          ;*********************************************************************************************************
  1047                          
  1048                          CRT_PROGRAM
  1049                          ;		--------------------- Set 'Character Set' [$E61D]
  1050                          
  1051  e61d 85c7               		STA SAL					; Pointer LO: Tape Buffer/ Screen Scrolling
  1052  e61f 86c8               		STX SAL+1				; Pointer HI
  1053  e621 ad4ce8             		LDA VIA_PCR				; Get current register byte VIA Register C - CA2	CHIP 
  1054  e624 29f0               		AND #$f0				; mask out lower nibble
  1055  e626 85d1               		STA FNLEN				; save it to Temp Variable
  1056  e628 98                 		TYA					; Move 'Character Set' byte to A
  1057  e629 05d1               		ORA FNLEN				; update lower nibble in Temp Variable
  1058  e62b 8d4ce8             		STA VIA_PCR				; write it back to VIA Register C - CA2			CHIP
  1059                          
  1060                          ;		--------------------- Write to the CRTC controller [$E62E]
  1061                          
  1062  e62e a011               		LDY #$11				; Number of bytes to copy = 17
  1063                          
  1064  e630 b1c7               CRT_LOOP	LDA (SAL),Y				; LOOP[   Pointer: Tape Buffer/ Screen Scrolling
  1065  e632 8c80e8             		STY CRT_Address				;   Select the register to update 6545/6845 CRT		CHIP
  1066  e635 8d81e8             		STA CRT_Status				;   Write to the register
  1067  e638 88                 		DEY					;   Next character
  1068  e639 10f5               		BPL CRT_LOOP				; ] Loop for more
  1069  e63b 60                 		RTS
  1070                          
  1071                          ;*********************************************************************************************************
  1072                          ;** ChrOutMarginBeep  [E68C]
  1073                          ;** Checks the cursor position and rings the BELL if near the end of the line
  1074                          ;*********************************************************************************************************
  1075                          
  1076                          ChrOutMarginBeep
  1077  e63c 2002e2             		JSR CHROUT_SCREEN			; Output character to screen (chr code in A)
  1078  e63f aa                 		TAX					; Save the character to X
  1079  e640 a5d5               		LDA RightMargin   			; Physical Screen Line Length
  1080  e642 38                 		SEC
  1081  e643 e5c6               		SBC CursorCol   			; Cursor Column on Current Line
  1082  e645 c905               		CMP #5					; Are we at the 5th last character on the line?
  1083  e647 d03f               		BNE BELLDONE				; No, exit out
  1084  e649 8a                 		TXA					; Yes, reload the character to print
  1085  e64a c91d               		CMP #$1D				; Is it <CRSR-RIGHT>?
  1086  e64c f006               		BEQ BEEP_BEEP				; Yes, do Double BELL
  1087  e64e 297f               		AND #$7F				; Mask off HI BIT
  1088  e650 c920               		CMP #$20				; Is it a control code?
  1089  e652 9034               		BCC BELLDONE				; Yes, exit out
  1090                          
  1091                          ;*********************************************************************************************************
  1092                          ;** BEEP / BEEP_BEEP [E654]/[E657]
  1093                          ;** Rings the BELL
  1094                          ;*********************************************************************************************************
  1095                          
  1096  e654 2057e6             BEEP_BEEP	JSR BEEP				; Double BELL
  1097                          BEEP							; Single BELL
  1098                          
  1099                          !if SILENT=0 {
  1100  e657 acec03             		LDY CHIME				; Chime Time FLAG
  1101                          } ELSE {
  1102                          		!IF CRUNCH=0 { NOP }			; To keep code aligned
  1103                          		RTS
  1104                          }
  1105                          
  1106                          !IF ESCCODES=1 {
  1107  e65a ad8303             		LDA BELLMODE				; Flag to Enable BELL
  1108  e65d 1001               		BPL BELLENABLED				; Enabled, so do it
  1109  e65f 60                 		RTS
  1110                          }
  1111  e660 f026               BELLENABLED	BEQ BELLDONE
  1112  e662 a910               		LDA #16
  1113  e664 8d4be8             		STA VIA_ACR
  1114  e667 a90f               		LDA #15
  1115  e669 8d4ae8             		STA VIA_Shift
  1116  e66c a207               		LDX #7					; Size of BELL table
  1117  e66e bde2e7             BELLOOP1	LDA SOUND_TAB-1,X			; LOOP[
  1118  e671 8d48e8             		STA VIA_Timer_2_Lo
  1119  e674 adec03             		LDA CHIME				; Chime Time
  1120                          
  1121  e677 88                 BELLOOP2	DEY					; LOOP[[
  1122  e678 d0fd               		BNE BELLOOP2				; ]] Delay loop
  1123  e67a 38                 		SEC
  1124  e67b e901               		SBC #1
  1125  e67d d0f8               		BNE BELLOOP2				; ]] Delay loop
  1126  e67f ca                 		DEX
  1127  e680 d0ec               		BNE BELLOOP1				; ] Delay loop
  1128  e682 8e4ae8             		STX VIA_Shift
  1129  e685 8e4be8             		STX VIA_ACR
  1130  e688 60                 BELLDONE	RTS
  1131                          
  1132                          ;*********************************************************************************************************
  1133                          ;** INIT_EDITOR  [E683]
  1134                          ;** Initializes the Editor. Clears Clock. Sets IRQ Vector. Sets Keyboard buffer size. Clears TABs.
  1135                          ;** Sets zero-page locations. And finally, chimes the BELL.
  1136                          ;*********************************************************************************************************
  1137                          
  1138  e689 a97f               INIT_EDITOR	LDA #$7f
  1139  e68b 8d4ee8             		STA VIA_IER				; VIA, Register E - I/O Timers
  1140  e68e a26d               		LDX #$6d
  1141  e690 a900               		LDA #0
  1142  e692 958d               INITED1		STA JIFFY_CLOCK,X			; Clear Real-Time Jiffy Clock (approx) 1/60 Sec
  1143  e694 ca                 		DEX
  1144  e695 10fb               		BPL INITED1
  1145  e697 a20a               		LDX #$0A				; 10 bytes to set
  1146  e699 9df003             INITED2		STA TABS+1,X				; LOOP[   TAB table $03F0
  1147  e69c ca                 		DEX					;   Next position
  1148  e69d 10fa               		BPL INITED2				; ] Loop back for more
  1149  e69f 8dee03             		STA RPTFLG				; Repeat Flag
  1150                          
  1151                          ;		--------------------------------------- Set IRQ Vector - Normally $E455 or $E900 for Execudesk
  1152                          
  1153                          !IF EXECUDESK=1 {
  1154                          		LDA #<IRQ_EDESK				; Execudesk IRQ Vector LO
  1155                          		STA CINV
  1156                          		LDA #>IRQ_EDESK				; Execudesk IRQ Vector HI
  1157                          		STA CINV+1
  1158                          } ELSE {
  1159  e6a2 a955               		LDA #<IRQ_NORMAL			; Normal IRQ Vector LO
  1160  e6a4 8590               		STA CINV
  1161  e6a6 a9e4               		LDA #>IRQ_NORMAL			; Normal IRQ Vector HI
  1162  e6a8 8591               		STA CINV+1
  1163                          }
  1164                          
  1165                          ;		--------------------------------------- Init SS40
  1166                          
  1167                          !IF SS40=1 {
  1168                          	!IF HARD4080=1 {
  1169                          		LDA #1					; 40/80 Switcher board INSTALLED
  1170                          		STA SCN4080BOARD
  1171                          	} ELSE {
  1172                          		LDA #0					; 40/80 Switcher board NOT installed
  1173                          		STA SCN4080BOARD	
  1174                          	}
  1175                          
  1176                          	!IF SS40MODE=80 {
  1177                          		JSR SS40_INIT80				; Initialize Switchable Soft-40 to 80 columns
  1178                          	} ELSE {
  1179                          		JSR SS40_INIT40				; Initialize Switchable Soft-40 to 40 columns
  1180                          	}
  1181                          }
  1182                          ;		--------------------------------------- Continue
  1183                          
  1184  e6aa a903               		LDA #$03				; 3=Screen
  1185  e6ac 85b0               		STA DFLTO  				; Set Default Output (CMD) to Screen
  1186  e6ae a90f               		LDA #$0F
  1187  e6b0 8d10e8             		STA PIA1_Port_A 			; Keyboard ROW select [$E810]
  1188  e6b3 0a                 		ASL
  1189  e6b4 8d40e8             		STA VIA_Port_B				; VIA Register 0 (flags) [$E840]
  1190  e6b7 8d42e8             		STA VIA_DDR_B				;
  1191  e6ba 8e22e8             		STX PIA2_Port_B				;
  1192  e6bd 8e45e8             		STX VIA_Timer_1_Hi			;
  1193                          
  1194  e6c0 a93d               		LDA #$3D
  1195  e6c2 8d13e8             		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt) [$E813]
  1196  e6c5 2c12e8             		BIT PIA1_Port_B 			; Keyboard COL read
  1197                          
  1198  e6c8 a93c               		LDA #$3C
  1199  e6ca 8d21e8             		STA PIA2_Cont_A
  1200  e6cd 8d23e8             		STA PIA2_Cont_B
  1201  e6d0 8d11e8             		STA PIA1_Cont_A
  1202  e6d3 8e22e8             		STX PIA2_Port_B
  1203                          
  1204  e6d6 a90c               		LDA #$0C
  1205  e6d8 8d4ce8             		STA VIA_PCR 				; VIA Register C (cb2) [$E84C]
  1206  e6db 85a8               		STA BLNCT  				; Timer: Countdown to Toggle Cursor
  1207  e6dd 85a7               		STA Blink  				; Cursor Blink enable: 0 = Flash Cursor
  1208                          
  1209  e6df a909               		LDA #$09
  1210  e6e1 8deb03             		STA XMAX  				; Max keyboard buffer size (40 col)
  1211                          
  1212  e6e4 a910               		LDA #$10
  1213  e6e6 8dec03             		STA CHIME 				; Chime Time 0=off (40col)
  1214  e6e9 8de903             		STA DELAY				; Repeat key countdown (40col)
  1215  e6ec 8dea03             		STA KOUNT 				; Delay between repeats (40col)
  1216                          
  1217                          ;		--------------------------------------- Patches for new features here
  1218                          
  1219                          !IF ESCCODES=1 {
  1220  e6ef a901               		LDA #1					; 1=Enabled
  1221  e6f1 8d8303             		STA BELLMODE				; Flag to Enable BELL
  1222                          }
  1223                          
  1224  e6f4 2015e9             !IF AUTORUN=1 {	JSR AUTOSTART }				; Do Autostart Prep
  1225                          
  1226  e6f7 60                 		RTS
  1227                          
  1228                          ;************** Check for screen scrolling [$E6EA]
  1229                          
  1230                          ESCAPE_W						; Esc-w Scroll Down
  1231                          WIN_SCROLL_DN
  1232  e6f8 a6d8               		LDX CursorRow  				; Get Current Cursor Physical Line Number
  1233  e6fa e8                 		INX					; Next line
  1234  e6fb e018               		CPX #ROWS-1				; Will it be the last line on the screen (24)?
  1235  e6fd f033               		BEQ CLEAR_SCREEN_LINE 			; Yes, Clear a screen line and move cursor to start of line
  1236  e6ff 9003               		BCC SCROLL_DOWN				; No it's less, Scroll screen lines DOWN
  1237  e701 4cc4e1             		JMP SCROLL_UP				; No it's more, Scroll screen up
  1238                          
  1239                          ;*********************************************************************************************************
  1240                          ;** SCROLL_DOWN  [$E6F6]
  1241                          ;** Scrolls the current screen DOWN. 
  1242                          ;** Used to INSERT a blank line. Scrolls all lines from bottom of screen up to current line
  1243                          ;** stored in 'CursorRow'.  Adjusts ALL Line Links.
  1244                          ;*********************************************************************************************************
  1245                          
  1246  e704 a217               SCROLL_DOWN	LDX #ROWS-2				; Start at bottom of the screen (ROW 24 minus 1)
  1247  e706 b5e1               SD_LOOP1 	LDA LineLinkTable+1,X			; LOOP[  Get NEXT line's HI byte from Line Link table
  1248  e708 0980               		ORA #$80				;   Make sure HI bit is set
  1249  e70a 85c8               		STA SAL+1				;   Store it to destination screen pointer
  1250  e70c b4e0               		LDY LineLinkTable,X			;   Get CURRENT line's HI byte from Line Link Table
  1251  e70e 3002               		BMI SD_SKIP				;   Is HI bit SET? Yes, skip ahead
  1252  e710 297f               		AND #$7F				;   No, CLEAR HI bit
  1253  e712 95e1               SD_SKIP		STA LineLinkTable+1,X			;   Store it back to Line link table
  1254  e714 98                 		TYA
  1255  e715 0980               		ORA #$80				;   SET HI bit
  1256  e717 85c5               		STA ScrPtr+1				;   Store to screen line SOURCE pointer
  1257                          
  1258  e719 a027               !IF SS40=0 {	LDY #COLUMNS-1				;   Hard-coded Screen Width-1 (ie: 39)
  1259                            } ELSE   {    LDY SCNWIDTH				;   Soft Screen Width
  1260                          		DEY }					;   -1
  1261                          
  1262  e71b bda7e7             		LDA Line_Addr_Lo+1,X			;   Get screen's LO byte from Screen line address table
  1263  e71e 85c7               		STA SAL    				;   Store it to DESTINATION screen pointer
  1264  e720 bda6e7             		LDA Line_Addr_Lo,X			;   Get Previous lines LO byte from Screen line address table
  1265  e723 85c4               		STA ScrPtr    				;   Store it to the SOURCE pointer
  1266                          
  1267                          ;		--------------------------------------- Copy the line
  1268                          
  1269  e725 b1c4               SD_LOOP2	LDA (ScrPtr),Y 				;   LOOP[[  Read character from screen
  1270  e727 91c7               		STA (SAL),Y				;     Write to new destination
  1271  e729 88                 		DEY					;     Next character
  1272  e72a 10f9               		BPL SD_LOOP2				;   ]] Loop back for more
  1273  e72c ca                 		DEX					;   Next line (above)
  1274  e72d e4d8               		CPX CursorRow   			;   Current Cursor Physical Line Number
  1275  e72f d0d5               		BNE SD_LOOP1				; ] Loop back for more
  1276  e731 e8                 		INX
  1277                          
  1278                          ;*********************************************************************************************************
  1279                          ;** CLEAR_SCREEN_LINE  [$E724]
  1280                          ;** Clears one line of the screen. X holds line#. Adjusts Line Link entry for specified line.
  1281                          ;*********************************************************************************************************
  1282                          
  1283                          CLEAR_SCREEN_LINE
  1284  e732 b5e0               		LDA LineLinkTable,X			; Get current line's Line Link entry
  1285  e734 0980               		ORA #$80				; Make sure HI BIT is set
  1286  e736 85c5               		STA ScrPtr+1				; Store it to the screen pointer
  1287  e738 297f               		AND #$7F				; Clear the HI BIT again
  1288  e73a 95e0               		STA LineLinkTable,X			; Store it to the Line Link Table
  1289  e73c bda6e7             		LDA Line_Addr_Lo,X			; Get screen line's address LO byte from ROM table
  1290  e73f 85c4               		STA ScrPtr    				; Store it to screen pointer LO
  1291                          
  1292  e741 a027               !IF SS40=0 {	LDY #COLUMNS-1				; Hard-coded Screen Width-1
  1293                             } ELSE {	LDY SCNWIDTH				; Soft Screen Width
  1294                          		DEY }					; -1
  1295                          
  1296  e743 a920               		LDA #$20				; <SPACE>
  1297                          
  1298  e745 91c4               CSL_LOOP	STA (ScrPtr),Y				; LOOP[    Write SPACE to screen
  1299  e747 88                 		DEY					;   Next position
  1300  e748 10fb               		BPL CSL_LOOP				; ] Loop back for more
  1301  e74a 4c74e0             		JMP CURSOR_LM				; Cursor to start of line
  1302                          
  1303                          ;*********************************************************************************************************
  1304                          ;** Keyboard Decoding Table  [E???]
  1305                          ;*********************************************************************************************************
  1306                          

; ******** Source: keyboard.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Selection
     2                          ; ================
     3                          ; This adds the appropriate keyboard matrix or matrices depending on options:
     4                          ; KEYSCAN=n  -- which keyboard scanning routine is used
     5                          ; KEYBOARD=n -- to select the matrix layout
     6                          ;
     7                          ; Note: Not all keyboards are defined for all options! Please check source
     8                          ;------------------------------------------------------------------------------
     9                          
    10                          !if KEYSCAN=0 { !source "keyboard-tables1.asm" }	; Graphic (Normal) Keyboard Scanner - Simple

; ******** Source: keyboard-tables1.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Tables for KEYSCAN-N, KEYSCAN-B scanner code
     2                          ; ================
     3                          ; 
     4                          ; Notes:
     5                          ;	Modifier Keys: 00 = Shift, 10 = Repeat, 80 = CTRL
     6                          ;	Special Codes: Bit 7 set (+$80) = Unshiftable, FF = No Key
     7                          ;       Labelling:
     8                          ;	   KP = Keypad, S- = Shift , GR- = Graphic Code, NONE = No Key
     9                          ;          CTRL- = CTRL+key , SHC- = Shift-CTRL+key, A- = Accent
    10                          
    11                          KEYBOARD_NORMAL
    12                          
    13                          ;---------- Normal/Graphic Keyboard - QWERTY Layout (chicklet or standard type)
    14                          ;
    15                          !IF KEYBOARD=0 {
    16                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    17                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    18                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A
    19                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
    20                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
    21                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
    22                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
    23                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
    24                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
    25                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
    26                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
    27                          !byte $1d,$13,$5f,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J
    28                          }
    29                          
    30                          ;---------- Business Keyboard - QWERTY Layout
    31                          ;
    32                          !IF KEYBOARD=1 {
    33                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    34                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    35  e74d 16043a03393633df   !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A
    36  e755 b12f15134d205812   !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
    37  e75d b2100fb02c4e565a   !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
    38  e765 b30019ae2e424300   !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
    39  e76d b4db4f1155544551   !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
    40  e775 145049dc59525709   !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
    41  e77d b6c04c0d4a474441   !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
    42  e785 b53b4bdd4846539b   !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
    43  e78d b906deb7b0373431   !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
    44  e795 050e1db82d383532   !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
    45                          }
    46                          
    47                          ;---------- Business Keyboard - German DIN, QWERTZ (Version 1) Layout
    48                          ;
    49                          !IF KEYBOARD=2 {
    50                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES
    51                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    52                          !byte $16,$04,$40,$03,$39,$36,$33,$5F ; CTRL-V CTRL-D @      STOP   9      6      3      BK-ARR ROW0/A  ..x....x
    53                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   M      SPACE  x      RVS    ROW1/B  ........
    54                          !byte $B2,$80,$0F,$01,$2C,$4E,$56,$59 ; KP 2   CTRL   CTRL-O KP 0   ,      n      v      y      ROW2/C  .x.x...x <- $80=CTRL (was $10=REPEAT)
    55                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D  ........ <- $00=SHIFT
    56                          !byte $B4,$5B,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E  .x......
    57                          !byte $14,$50,$49,$3A,$5A,$52,$57,$09 ; DEL    p      i      :      z      r      w      TAB    ROW5/F  ...xx...
    58                          !byte $B6,$5D,$4C,$0D,$4A,$47,$44,$41 ; KP 6   ]      l      RETURN j      g      d      a      ROW6/G  .x......
    59                          !byte $B5,$5C,$4B,$3B,$48,$46,$53,$1B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H  .......x
    60                          !byte $B9,$06,$5E,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I  ..x.....
    61                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J  ........
    62                          }
    63                          
    64                          ;---------- C64/VIC-20 Keyboard
    65                          ;
    66                          ; Keyboard will plug directly into the PET keyboard connector.
    67                          ; It is electrically compatible, but only uses an 8x8 matrix of keys.
    68                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
    69                          ;
    70                          ; * Code Change: SHIFT=01 with 00
    71                          ; * Reassign   : POUND as \=5C, CTRL as RVS=12, C= as ESC=9B
    72                          ; * Reassign   : F1 as TEXT=0E, F3 as DELETE LINE=15, F5 as ERASE TO START=16, F7 as SCROLL DOWN=19
    73                          
    74                          !IF KEYBOARD=3 {
    75                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    76                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    77                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A
    78                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B
    79                          !byte $19,$13,$2D,$30,$38,$36,$34,$32 ; F7     HOME   -      0      8      6      4      2      ROW2/C
    80                          !byte $16,$5E,$40,$4F,$55,$54,$45,$51 ; F5     UP-ARR @      O      U      T      E      Q      ROW3/D
    81                          !byte $15,$3D,$3A,$4B,$48,$46,$53,$9B ; F3     =      :      K      H      F      S      C=     ROW4/E
    82                          !byte $0E,$00,$2E,$4D,$42,$43,$5A,$20 ; F1     SHIFT  .      M      B      C      Z      SPACE  ROW5/F
    83                          !byte $11,$2F,$2C,$4E,$56,$58,$00,$03 ; DOWN   /      ,      N      V      X      SHIFT  STOP   ROW6/G
    84                          !byte $1D,$3B,$4C,$4A,$47,$44,$41,$12 ; RIGHT  ;      L      J      G      D      A      CTRL   ROW7/H
    85                          !byte $0D,$2A,$50,$49,$59,$52,$57,$DF ; RETURN *      P      I      Y      R      W      BK-ARR ROW8/I
    86                          !byte $14,$5C,$2B,$39,$37,$35,$33,$31 ; DEL    POUND  +      9      7      5      3      1      ROW9/J
    87                          }
    88                          
    89                          ;---------- Business Keyboard - Modified QWERTY Layout - BSJG
    90                          ;
    91                          ; This is a B keyboard with re-arranged layout to make it closer to C64 keyboard
    92                          ; ESC moved to top left. Cursor keys to bottom CLR/HOME and INS/DEL moved to top row
    93                          ; REPEAT moved to bottom left.
    94                          ;
    95                          !IF KEYBOARD=4 {
    96                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    97                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== ======
    98                          !byte $16,$04,$3A,$14,$39,$36,$33,$9B ; CTRL-V CTRL-D :      DEL    9      6      3      ESC    ROW0/A 
    99                          !byte $B1,$2F,$15,$1D,$4D,$20,$58,$10 ; KP 1   /      CTRL-U RIGHT  m      SPACE  x      REPT   ROW1/B 
   100                          !byte $B2,$11,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   DOWN   CTRL-O KP 0   ,      n      v      z      ROW2/C
   101                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      n      c      SHIFT  ROW3/D
   102                          !byte $B4,$DB,$4F,$DF,$55,$54,$45,$51 ; KP 4   [      o      BK-ARR u      t      e      q      ROW4/E
   103                          !byte $DE,$50,$49,$DD,$59,$52,$57,$09 ; UP-ARR p      i      ]      y      r      w      TAB    ROW5/F
   104                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   105                          !byte $B5,$3B,$4B,$DC,$48,$46,$53,$03 ; KP 5   ;      k      \      h      f      s      STOP   ROW7/H
   106                          !byte $B9,$06,$12,$B7,$B0,$37,$34,$31 ; KP     CTRL-F RVS    KP 7   0      7      4      1      ROW8/I
   107                          !byte $05,$0E,$13,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N HOME   KP 8   -      8      5      2      ROW9/J
   108                          }
   109                          
   110                          ;---------- Graphic Keyboard - Modified QWERTY Layout - NSJG
   111                          ;
   112                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none,
   113                          ; so the "@" key is used instead as it occupies the position an ESC key would normally be. The BACKARROW
   114                          ; key will become the "@" symbol so that the DOS wedge is usable (BACKARROW is rarely used).
   115                          ;
   116                          !IF KEYBOARD=5 {
   117                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   118                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   119                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    
   120                          !byte $2d,$30,$00,$3e,$ff,$5d,$9b,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      ESC    SHIFT  @ replaced with ESC
   121                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x
   122                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z
   123                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s
   124                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a
   125                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w
   126                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q
   127                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "
   128                          !byte $1d,$13,$40,$28,$26,$25,$23,$21 ; RIGHT  HOME   @      (      &      %      #      !      BACKARROW replaced by @
   129                          }
   130                          
   131                          ;---------- Business Keyboard - QWERTZ Layout
   132                          ;
   133                          !IF KEYBOARD=6 {
   134                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   135                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   136                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0 
   137                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1 
   138                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$59 ; KP 2   RPT    CTRL-O KP 0   ,      n      v      y      ROW2 
   139                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3
   140                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   ]      o      DOWN   u      t      e      q      ROW4 
   141                          !byte $14,$50,$49,$DC,$5A,$52,$57,$09 ; DEL    p      i      @      z      r      w      TAB    ROW5 
   142                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   [      l      RETURN j      g      d      a      ROW6
   143                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   \      k      ;      h      f      s      ESC    ROW7
   144                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8
   145                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9
   146                          }
   147                          
   148                          ;----------- Business Keyboard - French AZERTY Layout
   149                          ;
   150                          !IF KEYBOARD=7 {
   151                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   152                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   153                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A
   154                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
   155                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
   156                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   157                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
   158                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
   159                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   160                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
   161                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   162                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   163                          }
   164                          
   165                          ;----------- CBM-II (B-Series, P-Series) - QWERTY Layout
   166                          ;
   167                          ; The CBM-II keyboard has a 16*6 matrix, so it requires a hardware modification to work on the PET,
   168                          ; and a small modification to the keyboard scanning routine.
   169                          ; It also has many extra keys with no equivilent function, and so will have some non-functioning keys.
   170                          ;
   171                          ; *** WORK IN PROGRESS!!!!!!!
   172                          ;
   173                          !IF KEYBOARD=8 {
   174                          ;     C0  C1  C2  C3  C4  C5    COL0   COL1   COL2   COL3   COL4   COL5   NOTES 
   175                          ;     === === === === === ===   ====== ====== ====== ====== ====== ====== =====
   176                          !BYTE $E0,$1B,$09,$FF,$00,$01 ; F1     ESCAPE TAB    NONE   SHIFT  CTRL   ROW0/A
   177                          !BYTE $E1,$31,$51,$41,$5A,$FF ; F2     1      Q      A      Z      NONE   ROW1/B
   178                          !BYTE $E2,$32,$57,$53,$58,$43 ; F3     2      W      S      X      C      ROW2/C
   179                          !BYTE $E3,$33,$45,$44,$46,$56 ; F4     3      E      D      F      V      ROW3/D
   180                          !BYTE $E4,$34,$52,$54,$47,$42 ; F5     4      R      T      G      B      ROW4/E
   181                          !BYTE $E5,$35,$36,$59,$48,$4E ; F6     5      6      Y      H      N      ROW5/F
   182                          !BYTE $E6,$37,$55,$4A,$4D,$20 ; F7     7      U      J      M      SPACE  ROW6/G
   183                          !BYTE $E7,$38,$49,$4B,$2C,$2E ; F8     8      I      K      ,      .      ROW7/H
   184                          !BYTE $E8,$39,$4F,$4C,$3B,$2F ; F9     9      O      L      ;      /      ROW8/I
   185                          !BYTE $E9,$30,$2D,$50,$5B,$27 ; F10    0      -      P      [      '      ROW9/J
   186                          !BYTE $11,$3D,$5F,$5D,$0D,$DE ; DOWN   =      _      ]      RETURN PI     ROW10/K
   187                          !BYTE $91,$9D,$1D,$14,$02,$FF ; UP     LEFT   RIGHT  DEL    CMDR   NONE   ROW11/L
   188                          !BYTE $13,$3F,$37,$34,$31,$30 ; HOME   ?      7      4      1      0      ROW12/M
   189                          !BYTE $12,$04,$38,$35,$32,$2E ; RVS    CE     8      5      2      .      ROW13/N
   190                          !BYTE $8E,$2A,$39,$36,$33,$30 ; GRAPH  *      9      6      3      00     ROW14/O
   191                          !BYTE $03,$2F,$2D,$2B,$0D,$FF ; STOP   /      -      +      ENTER  NONE   ROW15/P
   192                          }
   193                          
   194                          ;----------- Normal/Graphic Keyboard - Modified QWERTY Layout with [ESC] modification
   195                          ;
   196                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none.
   197                          ; This layout changes the BACKARROW to ESC.
   198                          ;
   199                          !IF KEYBOARD=9 {
   200                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   201                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   202                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A
   203                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
   204                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   205                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   206                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   207                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   208                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   209                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   210                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   211                          !byte $1d,$13,$1b,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J   BACKARROW replaced by @
   212                          }
   213                          
   214                          ;----------- TED Series (C116/C16/Plus4) QWERTY Layout
   215                          ;
   216                          ; The TED keyboards have different connectors depending on model. Also, the pinouts
   217                          ; do not group the ROWs and COLs so you will need to make an adapter cable.
   218                          ; TED keyboards have 4 separate cursor keys meaning no SHIFT is needed. This will likely
   219                          ; conflict with the keyboard scanner which uses the TOP BIT of the character to indicate
   220                          ; it cannot be shifted. Cursor UP and LEFT are normally shifted.
   221                          ;
   222                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
   223                          ;
   224                          ; * Code Change: SHIFT=01 with 00, CTRL with 80
   225                          ; * Reassign   : POUND as \=5C, C= as TEXT/GRAPHICS mode
   226                          ; * Reassign   : F1 as TEXT=0E, F2 as DELETE LINE=15, F3 as ERASE TO START=16, HELP as SCROLL DOWN=19
   227                          ;
   228                          ; NOTE: Pin 3=LED, Pin 4=GND
   229                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   230                          ;
   231                          !IF KEYBOARD=11 {
   232                          ;PIN: 17  14  13  2   6   8   9   16
   233                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   234                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   235                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A -
   236                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B -
   237                          !byte $31,$13,$00,$03,$20,$0E,$51,$32 ;	1      CLR    CTRL   STOP   SPACE  C=     Q      2      ROW2/C 5
   238                          !byte $33,$57,$41,$00,$5A,$53,$45,$34 ; 3      W      A      SHIFT  Z      S      E      4      ROW3/D 7
   239                          !byte $35,$52,$44,$58,$43,$46,$54,$36 ; 5      R      D      X      C      F      T      6      ROW4/E 11
   240                          !byte $37,$59,$47,$56,$42,$48,$55,$38 ; 7      Y      G      V      B      H      U      8      ROW5/F 10
   241                          !byte $39,$49,$4A,$4E,$4D,$4B,$4F,$30 ; 9      I      J      N      M      K      O      0      ROW6/G 12
   242                          !byte $11,$50,$4C,$2C,$2E,$3B,$2D,$91 ; DOWN   P      L      ,      .      :      -      UP     ROW7/H 1
   243                          !byte $9D,$2A,$3B,$2F,$1B,$3D,$2B,$1D ; LEFT   *      ;      /      ESC    =      +      RIGHT  ROW8/I 15
   244                          !byte $14,$0D,$5C,$40,$0E,$15,$16,$19 ; DEL    RETURN POUND  @      F1     F2     F3     HELP   ROW9/J 18
   245                          }
   246                          
   247                          ;----------- C128 Keyboard - Requires hardware mod for larger matrix
   248                          ;
   249                          ; This table is taken from a C128 ROM disassembly and re-formatted
   250                          ; This has not been tested! It looks like the ROWS and COLUMNS are
   251                          ; reversed compared to the PET/CBM keyboard scanner. This will either
   252                          ; require re-ordering the matrix, or re-wiring/adapting the connector.
   253                          ;
   254                          ; CHANGES:
   255                          ;           SHIFT ($01) to SHIFT ($00)
   256                          ;           CTRL  ($04) to CTRL  ($80)
   257                          ;           ALT   ($08) to SHIFT ($00)
   258                          ;           NOSCRL($FF) to SHIFT ($00)
   259                          ; PIN
   260                          ; 1   GROUND
   261                          ; 2   NO PIN (keyed)
   262                          ; 4   +5V
   263                          ; 
   264                          ; Keys not in matrix:
   265                          ;    RESTORE  = pin 1 and pin 3
   266                          ;    40/80    = pin 1 and pin 24
   267                          ;    CAPS LOCK= pin 1 and pin 25
   268                          ;
   269                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   270                          ;
   271                          !IF KEYBOARD=12 {
   272                          
   273                          ;PIN: 12  11  10  5   8   7   6   9
   274                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   275                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   276                          !byte $14,$0D,$1D,$88,$85,$86,$87,$11 ; DEL    RETURN RIGHT  .      .      .      .      DOWN   ROW0   13
   277                          !byte $33,$57,$41,$34,$5A,$53,$45,$00 ; 3      w      a      4      z      s      e      SHIFT  ROW1   19
   278                          !byte $35,$52,$44,$36,$43,$46,$54,$58 ; 5      r      d      6      c      f      t      x      ROW2   18
   279                          !byte $37,$59,$47,$38,$42,$48,$55,$56 ; 7      y      g      8      b      h      u      v      ROW3   17
   280                          !byte $39,$49,$4A,$30,$4D,$4B,$4F,$4E ; 9      i      j      0      m      k      o      n      ROW4   16
   281                          !byte $2B,$50,$4C,$2D,$2E,$3A,$40,$2C ; +      p      l      -      .      :      @      ,      ROW5   15
   282                          !byte $5C,$2A,$3B,$13,$00,$3D,$5E,$2F ; \      *      ;      HOME   SHIFT  =      ^      /      ROW6   14
   283                          !byte $31,$5F,$80,$32,$20,$02,$51,$03 ; 1      BARROW CTRL   2      SPACE  CBM    q      STOP   ROW7   20
   284                          !byte $84,$38,$35,$09,$32,$34,$37,$31 ; HELP   8      5      TAB    2      4      7      1      ROW8   21
   285                          !byte $1B,$2B,$2D,$0A,$0D,$36,$39,$33 ; ESC    +      -      LF     ENTER  6      9      3      ROW9   22
   286                          !byte $08,$30,$2E,$91,$11,$9D,$1D,$00 ; ALT    0      .      UP     DOWN   LEFT   RIGHT  NOSCRL ROW10  23

; ******** Source: keyboard.asm
    11                          }	; Business Keyboard Scanner - Simple with code for specific shifted keys
    12                          !if KEYSCAN=2 { !source "keyboard-tables2.asm" }	; Extended Keyboard Scanner - Two Tables (Normal and Shifted)
    13                          !if ((CODEBASE>0) & (KEYSCAN=3)) { 
    14                          		!source "keyboard-tables3.asm" }	; C64 keyboard tables (only on newer codebases; put in ext space on codebase 0)

; ******** Source: editrom40.asm
  1307                          
  1308                          
  1309                          ;*********************************************************************************************************
  1310                          ;** SHIFT RUN/STOP string  [E721]
  1311                          ;*********************************************************************************************************
  1312                          
  1313  e79d 44cc222a0d         RUN_STRING	!byte $44,$cc,$22,$2a,$0d		; dL"*<RETURN>
  1314  e7a2 52554e0d           		!byte $52,$55,$4e,$0d			; run<RETURN>
  1315                          
  1316                          ;*********************************************************************************************************
  1317                          ;** Screen Line Address Table [$E798]
  1318                          ;** This codebase has line linking so there is only one screen line table for the LO bytes.
  1319                          ;** High bytes are calculated and put in the Link-link table
  1320                          ;*********************************************************************************************************
  1321                          

; ******** Source: screen0v.asm
     1                          ; PET/CBM EDIT ROM - Screen line LO address table - Screen 1 @ $8000 Video (characters)
     2                          ; ================   For CODEBASE 0
     3                          ; Variables: ROWS,COLUMNS
     4                          ; These tables are used to calculate the starting address of each line on the screen.
     5                          ; The standard screens are 40x25 and 80x25. Experimental screens can be up to 90x35.
     6                          ; 32 and 64 are included for future support of non-cbm type screens.
     7                          ; When ROWS>25 it assumes maximum 35 rows although less are supported as well.
     8                          
     9                          ;---------- 32 characters wide (32x32 = 1K RAM)
    10                          !IF COLUMNS=32 {
    11                          Line_Addr_Lo	!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    12                          		!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    13                          }
    14                          
    15                          ;---------- 40 characters wide 
    16                          !IF COLUMNS=40 {
    17  e7a6 00285078a0c8f018...Line_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    18  e7b6 80a8d0f820487098...		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    19                          }
    20                          
    21                          ;---------- 64 characters wide (64x32 = 2K RAM)
    22                          !IF COLUMNS=64 {
    23                          Line_Addr_Lo	!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    24                          		!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    25                          }
    26                          
    27                          ;---------- 80 characters wide 
    28                          !IF COLUMNS=80 {
    29                          Line_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0
    30                          		!byte $20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0
    31                          		!byte $40,$90,$e0,$30,$80
    32                          }
    33                          
    34                          ;---------- 90 characters wide
    35                          !IF COLUMNS=90 {
    36                          Line_Addr_Lo	!byte $00,$5a,$b4,$0e,$68,$c2,$1c,$76,$d0,$2a,$84,$de,$38,$92,$ec,$46
    37                          		!byte $a0,$fa,$54,$ea,$08,$62,$bc,$16,$70,$ca,$24,$7e,$d8,$32,$8c,$e6
    38                          		!byte $40,$9a,$f4
    39                          }

; ******** Source: editrom40.asm
  1322                          
  1323                          
  1324                          ;*********************************************************************************************************
  1325                          ;** CRTC Chip Register Setup Tables (2K ROMs) [E7B1]
  1326                          ;*********************************************************************************************************
  1327                          

; ******** Source: crtc-tables.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Table Selection
     2                          ; ================
     3                          ; Sets the CRTC Table depending on options
     4                          ; COLUMNS ---- 40 or 80 column hardware (with special cases 90 and 32)
     5                          ; SOFT40 ----- Software Defined 40-column modes
     6                          
     7                          
     8                          !IF COLUMNS=40 {

; ******** Source: crtc-reg-normal.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Tables
     2                          ; ================
     3                          ; For "normal" configurations (ie: for single main screen)
     4                          ; Sets the CRTC Table depending on options:
     5                          ; COLUMNS = 32,40,64,80,90
     6                          ;
     7                          ;======================================
     8                          ; NORMAL 4000/8000/8296/SuperPET MODELS
     9                          ;======================================
    10                          ; Common settings for "normal" machines (4000,8000,8296,SuperPET) with 12" monitor
    11                          ; NOTE: The 8296D uses a different monitor than the 8296 and requires a different register table (see below)
    12                          
    13                          ; REGISTER#->>>      DECIMAL: 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17
    14                          ;                        HEX: 00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  
    15                          ;                             ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==
    16                          ;
    17                          ;---------------------- 40/80x25, 50 Hz, 20 kHz for 12" Internal Monitor (inverted video R12=$10)
    18                          !IF REFRESH=0 {
    19                          CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$27,$00,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    20                          CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$31,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    21                          }
    22                          
    23                          ;---------------------- 40/80x25, 60 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    24                          !IF REFRESH=1 {
    25  e7bf 3128290f2003191d...CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$20,$03,$19,$1d,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    26  e7d1 3128290f28051921...CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    27                          }
    28                          
    29                          ;---------------------- 40/80x25, 50 Hz, 15.625 kHz (PAL)  for External Monitor (inverted video)
    30                          !IF REFRESH=2 {
    31                          CRT_CONFIG_TEXT:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    32                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    33                          }
    34                          
    35                          ;---------------------- 40/80x25, 60 Hz, 15.748 kHz (NTSC) for External Monitor (inverted video)
    36                          !IF REFRESH=3 {
    37                          CRT_CONFIG_TEXT:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    38                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    39                          }
    40                          
    41                          ;---------------------- 40/80x25, 50 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    42                          !IF REFRESH=4 {
    43                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    44                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    45                          }
    46                          
    47                          ;---------------------- 40/80x25, 60 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    48                          !IF REFRESH=5 {
    49                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    50                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    51                          }
    52                          
    53                          ;===============
    54                          ; 8296D MACHINES
    55                          ;===============
    56                          ; The 8296D has a different monitor than standard machines and requires slightly modified timing
    57                          
    58                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V1)
    59                          !IF REFRESH=82 {
    60                          CRT_CONFIG_TEXT:	!byte $3A,$28,$2C,$08,$20,$09,$19,$1D,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    61                          CRT_CONFIG_GRAPHICS:	!byte $3A,$28,$2C,$08,$29,$03,$19,$22,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    62                          }
    63                          
    64                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V2)
    65                          !IF REFRESH=83 {
    66                          CRT_CONFIG_TEXT:	!byte $32,$28,$28,$08,$26,$02,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    67                          CRT_CONFIG_GRAPHICS:	!byte $32,$28,$28,$08,$30,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    68                          }
    69                          
    70                          
    71                          ;======================
    72                          ; Extended/Experimental
    73                          ;======================
    74                          ; NOTE: Screens larger than 25 lines are for 8296 ONLY!!! The 8296 has additional screen RAM.
    75                          ;       These settings push the monitor to it's maximum possible resolution. Because of this you loose
    76                          ;       the ability to expand the line height in 'text' mode.
    77                          
    78                          ;---------------------- 40/80x32, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    79                          !IF REFRESH=90 {
    80                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    81                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    82                          }
    83                          
    84                          ;---------------------- 40/80x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    85                          !IF REFRESH=91 {
    86                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    87                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    88                          }
    89                          
    90                          ;---------------------- 45/90x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    91                          !IF REFRESH=92 {
    92                          CRT_CONFIG_TEXT:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    93                          CRT_CONFIG_GRAPHICS:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    94                          }
    95                          
    96                          ;=======================
    97                          ; CUSTOM - You Define It
    98                          ;=======================
    99                          
   100                          ;---------------------- CUSTOM - Your parameters here!
   101                          !IF REFRESH=99 {
   102                          CRT_CONFIG_TEXT:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
   103                          CRT_CONFIG_GRAPHICS:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
   104                          }
   105                          

; ******** Source: crtc-tables.asm
     9                          }
    10                          	!IF SOFT40=1 { !SOURCE "crtc-reg-soft40.asm" }
    11                          } ELSE {
    12                          	!SOURCE "crtc-reg-normal.asm"

; ******** Source: editrom40.asm
  1328                          
  1329                          
  1330                          ;*********************************************************************************************************
  1331                          ;** BELL Sound Table  [E7D5]
  1332                          ;*********************************************************************************************************
  1333                          
  1334  e7e3 0e1e3e7e3e1e0e     SOUND_TAB	!byte $0e,$1e,$3e,$7e,$3e,$1e,$0e	; BELL chime values
  1335                          
  1336                          ;*********************************************************************************************************
  1337                          ;*** POWERS OF 2 TABLE  [$E7DC]
  1338                          ; This table is used by the TAB routine.
  1339                          ;*********************************************************************************************************
  1340                          
  1341  e7ea 8040201008040201   POWERSOF2       !byte $80,$40,$20,$10,$08,$04,$02,$01	; BIT table
  1342                          
  1343                          ;*********************************************************************************************************
  1344                          ;** VERSION BYTE?
  1345                          ;*********************************************************************************************************
  1346                          
  1347  e7f2 29                 !IF HERTZ=50 {	!byte $29 }				; 901498-01 [edit-4-40-n-50]
  1348                          !IF HERTZ=60 {	!byte $BB }				; 901499-01 [edit-4-40-n-60]
  1349                          
  1350                          ;*********************************************************************************************************
  1351                          ;** SMALL PATCHES HERE
  1352                          ;*********************************************************************************************************
  1353                          ; note - these had to be moved to code0overflow.asm to make place for 
  1354                          ; colourpet and other code
  1355                          
  1356                          !IF BACKARROW =1 { !SOURCE "editbarrow.asm" }		; Patch for Back Arrow
  1357                          
  1358                          ;*********************************************************************************************************
  1359                          ;** FILLER
  1360                          ;*********************************************************************************************************
  1361                          
  1362  e7f3 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e800-*,$aa }	; Fill to end of 2K
  1363                          
  1364                          ;#########################################################################################################
  1365                          ;END! DO NOT ADD ANYTHING BELOW THIS LINE!!!!!!!!

; ******** Source: editrom.asm
    38                          			; 40-column CODEBASE
    39                          	!IF CODEBASE=1 {!SOURCE "editrom80.asm"}			; 80-column CODEBASE
    40                          	!IF CODEBASE=2 {!SOURCE "editrom82.asm"}			; 80-column EXTENDED CODEBASE
    41                          
    42                          ;=======================================================================
    43                          ; Determine if we need to assemble a 4K ROM
    44                          ;=======================================================================
    45                          ; We must include this area if:
    46                          ;   1) We are using CODEBASE 2
    47                          ;   2) Certain EXTended features are enabled
    48                          ;   3) BACKARROW feature needs relocating.
    49                          
    50                          	!IF ((CODEBASE=2) | ((COLOURPET + ESCCODES + WEDGE + EXECUDESK + SS40 + AUTORUN + KEYRESET) > 0) | (BACKARROW=2) | (CODEBASE=0 & KEYSCAN=3)) {

; ******** Source: editrom_hi.asm
     1                          ; PET/CBM EDIT ROM - Extended ROM Code (only if needed)
     2                          ; ================
     3                          ; $E800-EFFF for Extended ROM start address. Includes two sections:
     4                          ;   1) $E800-E8FF - IO Area
     5                          ;   3) $E900-EFFF - Extended area (Codebase 2 if required, New code)
     6                           
     7                          ;*=e800
     8                          
     9                          ;=======================================================================
    10                          ; IO Area
    11                          ;=======================================================================
    12                          ; $E800-E8FF is not visible to the PET cpu as I/O is in this space.
    13                          ; When not tring to duplicate existing code binaries, the IO.ASM file can
    14                          ; be used to place comments here that will be readable in the ROM via
    15                          ; binary viewers.
    16                          
    17                          	!IF OPTROM=0 {
    18                          		!IF CODEBASE=2 {
    19                          			!SOURCE "io_euro-4v4e.asm"			; Use Commodore's info block	
    20                          			!IF NOFILL=0 { !FILL $e900-*,$ff }		; pad with $FF as per Commodore ROMS
    21                          		} ELSE {

; ******** Source: io.asm
     1                          ; IO - This part of the ROM is not visible since IO is mapped here, so we will fill it
     2                          ; ==   with a decription of the editrom features and options.
     3                          
     4  e800 2a2a43424d204544...!text "**CBM EDIT ROM**"
     5  e810 5b                 !text "["
     6  e811 323032322d30342d...+DATE
     7                          
     8  e81b 5d20434f44454241...!text "] CODEBASE="
     9  e826 30                 !IF CODEBASE=0 { !text "0" }
    10                          !IF CODEBASE=1 { !text "1" }
    11                          !IF CODEBASE=2 { !text "2" }
    12                          
    13                          !IF COLOURPET = 1 {
    14  e827 20434f4c4f555250...	!text " COLOURPET-"
    15                          	!if COLOURVER=0 { !text "beta" }
    16  e832 72656c65617365     	!if COLOURVER=1 { !text "release" }
    17                          }
    18                          
    19  e839 204b4559424f4152...!text " KEYBOARD="
    20                          	!if KEYBOARD= 0 { !text "n-qwerty" }
    21  e843 622d717765727479   	!if KEYBOARD= 1 { !text "b-qwerty" }	; QWERTY layout
    22                          	!if KEYBOARD= 2 { !text "din" }
    23                          	!if KEYBOARD= 3 { !text "c64/vic" }
    24                          	!if KEYBOARD= 4 { !text "b-sjg" }	; Modified layout - cursor keys, esc etc
    25                          	!if KEYBOARD= 5 { !text "n-sjg" }	; Modified layout - @ replaced with ESC, backarrow becomes @
    26                          	!if KEYBOARD= 6 { !text "b-qwertz" }	; QWERTZ layout
    27                          	!if KEYBOARD= 7 { !text "b-azerty" }	; AZERTY layout
    28                          	!if KEYBOARD= 8 { !text "cbm-ii" }	; CBM-II keyboard (requires hardware mod)
    29                          	!if KEYBOARD= 9 { !text "n-sjg2" }	; Modified layout - backarrow replaced with ESC
    30                          	!if KEYBOARD=11 { !text "ted" }		; TED series (C16,C116,Plus/4 etc)
    31                          
    32  e84b 2053435245454e3d   !text " SCREEN="
    33                          	!if COLUMNS=32  { !text "32" }
    34  e853 3430               	!if COLUMNS=40  { !text "40" }
    35                          	!if COLUMNS=80  { !text "80" }
    36                          	!if COLUMNS=90  { !text "90" }
    37                          	!if ROWS=16     { !text "x16" }
    38  e855 783235             	!if ROWS=25     { !text "x25" }
    39                          	!if ROWS=32     { !text "x32" }
    40                          	!if ROWS=35     { !text "x35" }
    41                          	!if SOFT40=1    { !text " (soft40)" }
    42                          	!if SS40=1      {
    43                          		!pet " ("
    44                          		!if HARD4080=1  { !text "hs" } else { !text "ss" }
    45                          		!if SS40MODE=40 { !text "40)" }
    46                          		!if SS40MODE=80 { !text "80)" }
    47                          	}
    48                          
    49  e858 20484552545a3d     !text " HERTZ="
    50  e85f 3530               	!if HERTZ=50 { !text "50" }
    51                          	!if HERTZ=60 { !text "60" }
    52                          
    53  e861 2052454652455348...!text " REFRESH="
    54                          	!if REFRESH= 0 { !text "euro" }
    55  e86a 6e2e616d65726963...	!if REFRESH= 1 { !text "n.america" }
    56                          	!if REFRESH= 2 { !text "pal" }
    57                          	!if REFRESH= 3 { !text "ntsc" }
    58                          	!if REFRESH= 4 { !text "9inch" }
    59                          	!if REFRESH=82 { !text "8296d-v1" }
    60                          	!if REFRESH=83 { !text "8296d-v2" }
    61                          	!if REFRESH=90 { !text "8296(d)-n.a." }
    62                          	!if REFRESH=91 { !text "8296(d)-n.a." }
    63                          	!if REFRESH=92 { !text "8296(d)-n.a." }
    64                          	!if REFRESH=98 { !text "special" }
    65                          	!if REFRESH=99 { !text "custom" }
    66                          
    67  e873 2046454154555245...!text " FEATURES="
    68  e87d 6573632d636f6465...!if ESCCODES=1  { !text "esc-codes" }
    69  e886 2c6175746f72756e   !if AUTORUN=1   { !text ",autorun" }
    70                          !if BYPASS=1    { !text "+bypass" }
    71  e88e 2c62616e6e6572     !if BANNER>0    { !text ",banner" }
    72  e895 2c7765646765       !if WEDGE=1     { !text ",wedge" }
    73  e89b 2c6b657972657365...!if KEYRESET=1  { !text ",keyreset" }
    74  e8a4 2c6469736b20626f...!if DISKBOOT=1  { !text ",disk boot" }
    75                          !if EXECUDESK=1 { !text ",execudesk" }
    76  e8ae 2c6261636b617272...!if BACKARROW>0 { !text ",backarrow" }
    77                          !if SILENT=1    { !text ",silent" }
    78  e8b8 2c6372756e6368     !if CRUNCH=1    { !text ",crunch" }
    79                          !if MOT6845=1   { !text ",mot6845" }
    80                          !if DEBUG=1     { !text ",debug" }
    81  e8bf 2e20434f4d4d454e...!text ". COMMENT="
    82  e8c9 534a472d45444954...+COMMENT
    83                          

; ******** Source: editrom_hi.asm
    22                          			; Filler not visible due to I/O space!
    23  e8d4 2020202020202020...			!IF NOFILL=0 { !FILL $E900-*,$20 }		; pad with SPACES for non-cbm
    24                          		}
    25                          	}
    26                          
    27                          ;=======================================================================
    28                          ; EXTENDED Area
    29                          ;=======================================================================
    30                          ;*=e900
    31                          
    32                          ;=======================================================================
    33                          ; CODEBASE 2 Code
    34                          ;=======================================================================
    35                          ; This code is included only for Codebase 2
    36                          
    37                          	!IF CODEBASE = 2 {!SOURCE "editrom82ext.asm" }
    38                          
    39                          ;=======================================================================
    40                          ; NEW Code
    41                          ;=======================================================================
    42                          ; The EXTended features will go here. This is NEW code that has been added,
    43                          ; or code that must be RELOCATED due to lack of space in the 2K area 
    44                          ; due to restrictions of HARDCODED entrypoints.
    45                          ;
    46                          ; It is very likely that CODEBASE 2 will not have enough space for many of
    47                          ; these additions.
    48                          ;
    49                          ; If OPTROM is greater than 0 then this code will be put in the OPTION ROM space.
    50                          
    51                          	;----- If OPTION ROM then adjust Code assembly address
    52                          	
    53                          	!IF OPTROM=1 { *=$9000 }  				; Assemble to option ROM at $9000
    54                          	!IF OPTROM=2 { *=$A000 }  				; Assemble to option ROM at $A000
    55                          	!IF OPTROM=99 {!SOURCE "io.asm"}			; Special case for development purposes
    56                          
    57                          	;----- These features require AUTORUN
    58                          
    59                          	!IF AUTORUN = 1 {

; ******** Source: editautorun.asm
     1                          ; PET/CBM EDIT ROM - Auto Run
     2                          ; ================
     3                          ;
     4                          ; This module controls auto running tasks after PET has booted. It does this by
     5                          ; stuffing the keyboard buffer with a SYS command. We need to do this because
     6                          ; the editrom code runs before basic and zero-page are initialized.
     7                          ;
     8                          ; The SYS command will automatically be erased.
     9                          ;
    10                          ;-------------- Autostart Dispatch
    11                          ; This should assemble to the $E900,$9000, or $A000 depending on OPTROM setting.
    12                          ; The SYS points to here.
    13                          ; We check options to see what needs to Auto Run.
    14                          
    15                          AUTODISPATCH
    16  e900 200de9             		JSR ERASE_SYS
    17  e903 2059e9             		!IF BANNER > 0   { JSR SHOW_BANNER   }		; Display Custom Banner Message
    18  e906 20ffe9             		!IF WEDGE  > 0   { JSR INSTALL_WEDGE }		; Install DOS Wedge
    19                          		!IF EXECUDESK =2 { JSR EDESKMENU }		; Run Execudesk Menu
    20  e909 204fe9             		!IF DISKBOOT > 0 { JSR DOBOOT }			; Do Disk Boot
    21  e90c 60                 		RTS
    22                          
    23                          ERASE_SYS
    24  e90d a92f               		LDA #<ERASE_TXT			; pointer to erase text string
    25  e90f a0e9               		LDY #>ERASE_TXT
    26  e911 201dbb             		JSR STROUTZ			; print it
    27  e914 60                 		RTS
    28                          
    29                          ;-------------- Wedge Prep (1st Step)
    30                          ; We jump to here in the Editor ROM Init code, near the end.
    31                          ; If BYPASS=1 then we check for a key on ROW0 (which is ROW9 in the keyboard table)
    32                          
    33                          AUTOSTART
    34                          
    35                          !IF BYPASS=1 {
    36                          		LDA PIA1_Port_A 		; Keyboard ROW select - PIA#1, Register 0
    37                          						; Upper bits: IEEE and Cassette
    38                          						; Lower bits: Keyboard ROW select
    39                          		AND #$F0			; Mask off lower 4 bits (reset keyboard scan row)
    40                          		STA PIA1_Port_A			; Keyboard ROW select - PIA#1, Register 0				CHIP
    41                          		LDA PIA1_Port_B			; Keyboard COL result							CHIP
    42                          		CMP #$FF			; Are any keys pressed?  (FF=No keys down)
    43                          		BEQ AUTO_GO			; No, so do Auto Run
    44                          
    45                          !IF COLOURPET > 0 {
    46                          						; For ColourPET we can change the colours to indicate no wedge installed
    47                          		LDA #BYPASSFG			; ColourPET Foreground for Wedge Bypass
    48                          		STA COLOURFG
    49                          		LDA #BYPASSBG 			; ColourPET Background for Wedge Bypass
    50                          		STA COLOURBG
    51                          		}
    52                          
    53                          		RTS				; Exit without activating wedge sys
    54                          }
    55                          
    56                          ;-------------- Stuff Keyboard
    57                          AUTO_GO
    58  e915 a209               		LDX #9				; Length of string
    59                          
    60  e917 bd25e9             AUTO_LOOP	LDA AUTO_SYS,X			; Get a key from table
    61  e91a 9d6f02             		STA KEYD,X 			; put it in the Keyboard Buffer
    62  e91d ca                 		DEX
    63  e91e 10f7               		BPL AUTO_LOOP			; loop until done
    64                          
    65  e920 a909               		LDA #9				; Length of string
    66  e922 859e               		STA CharsInBuffer		; Set characters in keyboard buffer 
    67  e924 60                 AUTO_DONE	RTS
    68                          
    69                          ;-------------- TEXT to stuff into keyboard buffer
    70                          
    71                          AUTO_SYS
    72  e925 5359533539363438   		!IF OPTROM=0 {!text "SYS59648"}		; Autostart is located at $E900!
    73                          		!IF OPTROM=1 {!text "SYS36864"}		; Autostart is located at $9000!
    74                          		!IF OPTROM=2 {!text "SYS40960"}		; Autostart is located at $A000!
    75  e92d 0d00               		!byte $0D,0				; <CR> and zero pad byte
    76                          
    77                          ;-------------- TEXT to erase SYS and READY from screen
    78                          
    79                          ERASE_TXT
    80  e92f 91                 		!byte $91			; <UP>
    81  e930 2020202020202020...		!text "            "		; erase "SYS" message
    82  e93c 0d                 		!byte $0D			; <CR>
    83  e93d 2020202020202020...		!text "            "		; erase "READY" message
    84  e949 0d                 		!byte $0D			; <CR>
    85  e94a 91919191           		!byte $91,$91,$91,$91		; <UP><UP><UP><UP>
    86  e94e 00                 		!byte 0
    87                          
    88                          ;============================================================================================
    89                          ; DISK AUTOBOOT
    90                          ;============================================================================================
    91                          ; This puts the SHIFT RUN/STOP code into the keyboard buffer and the system
    92                          ; will take care of the rest!
    93                          
    94                          !IF DISKBOOT >0 {
    95                          DOBOOT
    96  e94f a983               		LDA #$83			; SHIFT RUN/STOP
    97  e951 8d6f02             		STA KEYD			; First position of Keyboard Input Buffer
    98  e954 a901               		LDA #1				; One character
    99  e956 859e               		STA $9E				; Set number of characters in keyboard buffer
   100  e958 60                 		RTS
   101                          }

; ******** Source: editrom_hi.asm
    60                          

; ******** Source: editbanner.asm
     1                          ; PET/CBM EDIT ROM - Custom Banner
     2                          ; ================
     3                          ;
     4                          ; You can display a custom banner message when the machine is turned on. This could be a simple
     5                          ; welcome message, or a completely new message. By including CLS, HOME or CURSOR characters you
     6                          ; can overwrite the PET's normal power-up banner with anything you like.
     7                          ;
     8                          ; NOTES:
     9                          ; - The default banner "*** COMMODORE BASIC 4.0 ***"  (27 characters wide) is located in the
    10                          ;   BASIC ROM so we cannot change it, but we can clear or overwrite it.
    11                          ; - Be sure to use proper cursoring so that the "READY" prompt is positioned correctly!
    12                          ; - If you clear the screen you will lose the "xxxxx BYTES FREE" message.
    13                          ; - For ColourPET, if you set the initial FG and BG colours to be the same then the PET banner
    14                          ;   will be invisible. Be sure to set the colour before printing your custom message.
    15                          
    16                          ;-------------- Display the Banner
    17                          
    18                          SHOW_BANNER
    19  e959 a961               		lda #<BANNER_TXT		; pointer to BANNER text string
    20  e95b a0e9               		ldy #>BANNER_TXT
    21  e95d 201dbb             		jsr STROUTZ			; print it
    22  e960 60                 		rts
    23                          
    24                          ;-------------- Include the Banner text
    25                          
    26                          BANNER_TXT

; ******** Source: banner.asm
     1                          ; PET/CBM EDIT ROM - Custom Banner (Power-on) Messages
     2                          ; ================
     3                          
     4                          ; You can display a custom banner message when the machine is turned on. This could be a simple
     5                          ; welcome message, or a completely new message. By including CLS, HOME or CURSOR characters you
     6                          ; can overwrite the PET's normal power-up banner with anything you like.
     7                          ;
     8                          ; NOTES:
     9                          ; - The default banner "*** COMMODORE BASIC 4.0 ***"  (27 characters wide) is located in the
    10                          ;   BASIC ROM so we cannot change it, but we can clear or overwrite it.
    11                          ; - Be sure to use proper cursoring so that the "READY" prompt is positioned correctly!
    12                          ; - If you clear the screen you will lose the "xxxxx BYTES FREE" message.
    13                          ; - For ColourPET, if you set the initial FG and BG colours to be the same then the PET banner
    14                          ;   will be invisible. Be sure to set the colour before printing your custom message.
    15                          ;
    16                          ; Currently the following are available:
    17                          ;
    18                          ; ##  MODEL  MODE   TYPE MESSAGE / DESCRIPTION                   40                                      80
    19                          ; --  -----  ----   ---- "---------!---------!---------!---------!---------!---------!---------!---------!"
    20                          ;  1  CPET   GRAPH  OVER "COMMODORE COLOURPET"
    21                          ;  2  CPET   TEXT   OVER "ColourPET BASIC4 + Wedge"
    22                          ;  3  80COL  TEXT   OVER "Commodore EDITROM Project - Wedge/ESC/SS40"
    23                          ;  4  ANY    GRAPH  OVER "CBM BASIC 4 WITH WEDGE"
    24                          ;  5  CPET   GRAPH  FULL C65-like screen with colour bars
    25                          ;  6  80COL  ANY    OVER "*** commodore basic 4.0 with wedge/esc/ss40"
    26                          ;  7  80COL  ANY    OVER "*** commodore basic 4.0 with wedge,esc,reboot,40/80 switcher"
    27                          ;  8  8296   ANY    OVER "*** commodore 8296 basic 4.0 with wedge,esc,reboot,80x35 screen"
    28                          ;  9  8296   ANY    OVER "*** commodore 8296 basic 4.0 with wedge,esc,reboot,extended screen"
    29                          ; 10  80COL  ANY    OVER "*** commodore basic 4.0 with wedge,esc,reboot,ss40, execudesk"
    30                          ; 11  80COL  ANY    OVER "*** commodore basic 4.0 with enhanced editor and wedge"
    31                          ; 12  40COL  ANY    OVER "*** cbm basic 4 plus editor+wedge ***"
    32                          ; 13  8296D  ANY    OVER "*** commodore 8296 basic 4.0 with wedge,reboot, backarrow ***"
    33                          ; 14  8296D  ANY    OVER "*** commodore 8296 basic 4.0 with custom editor rom ***"
    34                          ; 15  8296D  ANY    OVER "*** commodore 8296d basic 4.0 with custom editor rom ***"
    35                          ; 16  80COL  ANY    OVER "*** commodore basic 4.0 with custom editor rom ***"
    36                          ; 17  40COL  ANY    OVER "*** cbm basic 4 custom editrom ***"
    37                          ; 18  40COL  ANY    OVER "*** commodore basic 4.0 *** hard40/80,n"
    38                          ; 19  40COL  ANY    OVER "*** commodore basic 4.0 *** disk boot"
    39                          ; 98  ANY    ANY    ADD  Show DATE and COMMENT for debug purposes
    40                          ; 99  CUSTOM ...    ...  Your own banner text
    41                          ;
    42                          ; TYPE: FULL = Replaces all, OVER = Overwrites part, ADD = Adds additional text
    43                          ;
    44                          ;-----------------------------------------------
    45                          ; CUSTOM BANNER
    46                          ;-----------------------------------------------
    47                          !IF BANNER=99 {
    48                          		!byte $13
    49                          ;Screen columns:      44444444444444444444444444v44444444444448888888888888888888888888888888888888888
    50                          		!pet "*** commodore basic 4.0 *** hard40/80,n",$0D
    51                          		!pet "waltermixx edition!"
    52                          		!byte $0D      			; <CR><CR><CR>
    53                          }
    54                          
    55                          ;-----------------------------------------------
    56                          ; DEBUG BANNER
    57                          ;-----------------------------------------------
    58                          
    59                          !IF BANNER=98 {	!pet "date: "
    60                          		+DATE
    61                          		!byte $0D
    62                          		!pet "comment: "
    63                          		+COMMENT
    64                          		!byte $0D				
    65                          }
    66                          
    67                          !IF BANNER=19 {	!byte $13
    68                          		!pet "*** commodore basic 4.0 *** disk boot"
    69                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    70                          }
    71                          
    72                          !IF BANNER=18 {	!byte $13
    73                          		!pet "*** commodore basic 4.0 *** hard40/80,n"
    74                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    75                          }
    76                          
    77                          !if BANNER=17 { !byte $13            		; <HOME> 
    78                                   	!pet "*** cbm basic 4 with custom editrom ***"
    79                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    80                          }
    81                          
    82                          !if BANNER=16 { !byte $13            		; <HOME> 
    83                                   	!pet "*** commodore basic 4.0 with custom editor rom ***"
    84                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    85                          }
    86                          
    87                          !if BANNER=15 { !byte $13            		; <HOME> 
    88                                   	!pet "*** commodore 8296d basic 4.0 with custom editor rom ***"
    89                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    90                          }
    91                          
    92                          !if BANNER=14 { !byte $13            		; <HOME> 
    93                                   	!pet "*** commodore 8296 basic 4.0 with custom editor rom ***"
    94                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    95                          }
    96                          
    97                          !if BANNER=13 { !byte $13            		; <HOME> 
    98                                   	!pet "*** commodore 8296d basic 4.0 with wedge,reboot,din ***"
    99                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   100                          }
   101                          
   102                          !if BANNER=12 {	!byte $13            		; <HOME> 
   103                                   	!pet "*** cbm basic 4 plus editor+wedge ***"
   104                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   105                          }
   106                          
   107                          !if BANNER=11 {	!byte $13            		; <HOME> 
   108                                   	!pet "*** commodore basic 4.0 with enhanced editor and wedge ***"
   109                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   110                          }
   111                          
   112                          !if BANNER=10 {	!byte $13            		; <HOME> 
   113                                   	!pet "*** commodore basic 4.0 with wedge,esc,reboot,ss40, execudesk ***"
   114                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   115                          }
   116                          
   117                          !if BANNER=9 {	!byte $13            		; <HOME> 
   118                                   	!pet "*** commodore 8296 basic 4.0 with wedge,esc,reboot,extended screen ***"
   119                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   120                          }
   121                          
   122                          !if BANNER=8 {	!byte $13            		; <HOME> 
   123                                   	!pet "*** commodore 8296 basic 4.0 with wedge,esc,reboot,80x35 screen ***"
   124                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   125                          }
   126                          
   127                          !if BANNER=7 {	!byte $13            		; <HOME> 
   128                                   	!pet "*** commodore basic 4.0 with wedge,esc,reboot,40/80 switcher ***"
   129                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   130                          }
   131                          
   132                          !if BANNER=6 {	!byte $13            		; <HOME> 
   133                                   	!pet "*** commodore basic 4.0 with wedge/esc/ss40 ***"
   134                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   135                          }
   136                          
   137                          ;-----------------------------------------------
   138                          ; Custom ColourPET-40 C65-like startup screen with colour bars
   139                          ; TIP: Set foreground and background colour to <BLUE> to hide initial banner message
   140                          ;-----------------------------------------------
   141                          !IF BANNER=5 {
   142  e961 051f938e           		!byte $5,$1F,$93,142		; <WHT><BLUE><CLS><GRAPHICS>
   143                          		
   144                          		;-- line 1		
   145  e965 1c12               		!byte $1C,$12			;<RED><RVS>
   146  e967 2020202020202020...		!pet "         "		; bar
   147  e970 92e905             		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   148                          
   149                          !IF UPET=1 {
   150  e973 202054484520554c...		!pet "  the ultra-pet prototype"
   151                          } ELSE {
   152                          		!pet "  the commodore colourpet"
   153                          }
   154                          
   155  e98c 0d                 		!byte $0D			; <CR>
   156                          
   157                          		;-- line 2
   158  e98d 9612               		!byte $96,$12			; <LT RED><RVS>
   159  e98f 20202020202020     		!pet "       "			; bar
   160  e996 92e90d             		!byte $92,$E9,$0D		; <OFF><diag block><CR>
   161                          
   162                          		;-- line 3
   163  e999 9e12               		!byte $9E,$12			; <YEL><RVS>
   164  e99b 2020202020         		!pet "     "                    ; bar
   165  e9a0 92e905             		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   166                          
   167                          !IF UPET=1 {
   168  e9a3 2020202020204259...		!pet "      by andre fachat"
   169                          } ELSE {
   170                          		!pet "      (c) steve j. gray"
   171                          }
   172                          
   173  e9b8 0d                 		!byte $0D			; <CR>
   174                          
   175                          		;-- line 4
   176  e9b9 9912               		!byte $99,$12			; <LT GRN><RVS>
   177  e9bb 202020             		!pet "   "			; bar
   178  e9be 92e905             		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   179  e9c1 2020202020202020...		!pet "        basic 4.0  31743 bytes free"
   180  e9e4 0d                 		!byte $0D
   181                          
   182                          		;-- line 5,6
   183  e9e5 0d                 		!byte $0D
   184  e9e6 4d4f44204b455942...		!pet "mod keyboard and wedge"
   185  e9fc 0d                 		!byte $0D				
   186                          }
   187                          
   188                          ;-----------------------------------------------
   189                          ; Custom 4032 - For GRAPHICS MODE startup screen
   190                          ;-----------------------------------------------
   191                          
   192                          !if BANNER=4 {	!byte $13            		; <HOME> 
   193                                   	!pet "*** CBM BASIC 4 WITH WEDGE ***"
   194                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   195                          }
   196                          
   197                          ;-----------------------------------------------
   198                          ; Custom 8032 - For TEXT MODE startup screen
   199                          ;-----------------------------------------------
   200                          
   201                          !if BANNER=3 {	!byte $13            		; <HOME> 
   202                                   	!pet "*** Commodore EDITROM Project - Wedge/ESC/SS40 ***"
   203                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   204                          }
   205                          
   206                          ;-----------------------------------------------
   207                          ; Custom ColourPET message courtesy Christian Dirks - For GRAPHICS MODE startup screen
   208                          ;-----------------------------------------------
   209                          
   210                          !if BANNER=2 {	!byte $13,$99          		; <HOME><GRN>
   211                                   	!pet "*** "
   212                                   	!byte $1c            		; <RED>
   213                                   	!pet "co"
   214                                   	!byte $99            		; <GRN>
   215                                   	!pet "lo"
   216                                   	!byte $9a            		; <BLU>
   217                                   	!pet "ur"
   218                                   	!byte $9e            		; <YEL>
   219                                   	!pet "pet"
   220                                   	!byte $99            		; <GRN>
   221                                   	!pet " basic 4.0 + wedge ***"   ; message
   222                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   223                          }
   224                          
   225                          ;-----------------------------------------------
   226                          ; Custom ColourPET message for TEXT MODE startup screen
   227                          ;-----------------------------------------------
   228                          
   229                          !if BANNER=1 {	!byte $93,$5			; <CLS><WHT>
   230                          		!pet "*** "
   231                          		!byte $9f			; <LTCYN>
   232                          		!pet "Commodore "
   233                          		!byte $1c			; <RED>
   234                          		!pet "Co"
   235                          		!byte $99			; <GRN>
   236                          		!pet "lo"
   237                          		!byte $9a			; <BLU>
   238                          		!pet "ur"
   239                          		!byte $9e			; <YEL>
   240                          		!pet "PET"
   241                          		!byte $05			; <WHT>
   242                          		!pet " ***"
   243                          		!byte 11,11
   244                          		!byte $0D			; <cr>
   245                          }
   246                          
   247                          ;-----------------------------------------------
   248                          ; Unspecified values
   249                          ;-----------------------------------------------
   250                          
   251  e9fd 0000               		!byte 0,0			; Zeros must end string.

; ******** Source: editbanner.asm
    27                          
    28                          
    29                          

; ******** Source: editrom_hi.asm
    61                          }

; ******** Source: editwedge.asm
     1                          ; PET/CBM EDIT ROM - Wedge
     2                          ; ================
     3                          ;
     4                          ; Based on Commodore's universal wedge taken from 8050's test/demo disk
     5                          ; but rewritten and enhanced by Nils Eilers
     6                          ;
     7                          ; Adapted for EDIT-ROM and ACME assembler by Steve Gray.
     8                          ;
     9                          ; NOTE: The reason we have to stuff the keyboard buffer to activate the wedge is because
    10                          ;       the editrom code runs before basic and zero-page are initialized.
    11                          ;
    12                          ;----------------------------------------------------------------------------------------
    13                          ; Wedge commands are only available in direct mode. 
    14                          ;
    15                          ; #<unit number> 	- sets the default drive. Without unit number shows the current default drive.
    16                          ; @$[[drive]:filename] 	- displays the disk's directory. SPACE=Pause, any other key to continue. STOP=Abort.
    17                          ;				@$ displays the entire directory.
    18                          ;				@$1: displays the directory of default's device drive 1 only. Do not confuse drive and device.
    19                          ;				@$:N* displays all files having a "N" as the first letter in their filename.
    20                          ; /filename		- Loads a program.
    21                          ; ^filename		- Loads and runs a file ("^" is up arrow, NOT "carat")
    22                          ; @			- Read disk status. Without any parameters reads and displays the disk drive error message channel.
    23                          ; @<string>		- Sends <string> to the device's command channel. 
    24                          ;				@C:newfile=existingfile	- Copy a file on the same diskette
    25                          ;				@I 			- Initialize the disk drive.
    26                          ;				@N:diskname		- New a disk that was already formatted
    27                          ;				@N:diskname,id		- Format a diskette, giving it an index at your choice
    28                          ;				@R:newname=oldname	- Rename a file
    29                          ;				@S:file1[,file2 ...]	- Scratch file(s). Wild cards allowed. Status channel returns # of files scratched.
    30                          ;				@UJ			- Reset drive. Status channel will return the DOS version string.
    31                          ;				@V			- Validate disk
    32                          ;				@D1=0			- Duplicate disk (dual drive units only). Target drive first, then source.
    33                          ;------------------------------------------------------------------------------------------------------------------------------------------
    34                          
    35                          
    36                          ;-------------- INSTALL WEDGE
    37                          ; This patches the CHRGET routine in Zero Page to point to the WEDGE interpreter
    38                          
    39                          INSTALL_WEDGE
    40  e9ff a910               		lda #<resident_wedge		; patch CHRGET JMP address
    41  ea01 8571               		sta CHRGET+1 			; to jump into wedge
    42  ea03 a9ea               		lda #>resident_wedge
    43  ea05 8572               		sta CHRGET+2
    44  ea07 a94c               		lda #$4c			; insert JMP command in CHRGET routine
    45  ea09 8570               		sta CHRGET
    46                          
    47  ea0b a908               		lda #8				; init default device
    48  ea0d 8573               		sta CHRGETX			; $73=unused byte in CHRGET
    49                          
    50                          !if WEDGEMSG=1 {
    51                          		lda #<WEDGESTRING		; write "wedge installed"
    52                          		ldy #>WEDGESTRING
    53                          		jsr STROUTZ
    54                          }	
    55  ea0f 60                 		rts				; exit to BASIC
    56                          
    57                          ;-------------- MESSAGE
    58                          WEDGESTRING
    59                          !if WEDGEMSG=1 {
    60                          		!pet "wedge installed"		; message
    61                          		!byte 0				; extra 0 padding
    62                          }
    63                          
    64                          ;-------------- Resident part of the universal DOS wedge
    65                          ; When installed, the CHRGET routine points here.
    66                          
    67                          resident_wedge
    68                          		wedge_unit = CHRGETX		; default device, unused byte in CHRGET
    69                          		wedge_char = SAVELA		; $B3 -0 if @># else load/run char / ^
    70                          
    71  ea10 e677               		inc TXTPTR			; increment text pointer 
    72  ea12 d002               		bne MAIN2
    73  ea14 e678               		inc TXTPTR + 1
    74                          MAIN2 
    75                          
    76                          ; if MAINS is stacked, CHRGET is called from direct mode. abort if not called from there
    77                          
    78  ea16 86b3               		stx wedge_char			; save X
    79  ea18 ba                 		tsx 
    80  ea19 bd0101             		lda STACK+1,x
    81  ea1c c90f               		cmp #<MAINS
    82  ea1e d037               		bne restabort
    83  ea20 bd0201             		lda STACK+2,x
    84  ea23 c9b4               		cmp #>MAINS
    85  ea25 d030               		bne restabort			; abort if textpointer doesn't point to $0200
    86                          
    87  ea27 a577               		lda TXTPTR
    88  ea29 d02e               		bne abort
    89  ea2b a578               		lda TXTPTR + 1
    90  ea2d c902               		cmp #2
    91  ea2f d028               		bne abort
    92                          
    93  ea31 a000               		ldy #0				; NUL when @>#
    94  ea33 84b3               		sty wedge_char			; else load/run character /^
    95                          
    96  ea35 b177               testchar	lda (TXTPTR),y
    97  ea37 c920               		cmp #32				; skip leading spaces
    98  ea39 d004               		bne nospace
    99  ea3b e677               		inc TXTPTR
   100  ea3d d0f6               		bne testchar
   101                          
   102  ea3f c93e               nospace		cmp #$3e			; '>'
   103  ea41 f019               		beq command_or_status
   104  ea43 c940               		cmp #$40			; '@'
   105  ea45 f015               		beq command_or_status
   106  ea47 c923               		cmp #$23			; '#'
   107  ea49 f01c               		beq default_device
   108  ea4b 85b3               		sta wedge_char			; save load/run character
   109  ea4d c92f               		cmp #$2f			; '/'
   110  ea4f f057               		beq to_prepare_fn
   111  ea51 c95e               		cmp #$5e			; '^'
   112  ea53 f053               		beq to_prepare_fn
   113  ea55 d002               		bne abort
   114                          
   115  ea57 a6b3               restabort	ldx wedge_char			; restore X
   116  ea59 4c7600             abort		jmp CHRGOT
   117                          
   118                          ;-------------- COMMAND OR STATUS
   119                          
   120                          command_or_status
   121  ea5c c8                 		iny 
   122  ea5d b177               		lda (TXTPTR),y
   123  ea5f f049               		beq get_status
   124  ea61 c924               		cmp #'$'			; '$'
   125  ea63 f06b               		beq prepare_fn
   126  ea65 d01d               		bne send_cmd
   127                          
   128                          ;-------------- SET DEVICE
   129                          
   130                          default_device
   131  ea67 e677               		inc TXTPTR
   132  ea69 b177               		lda (TXTPTR),y			; Y is still 0
   133  ea6b d00c               		bne set_device			; parameter given -> set device number
   134                          
   135  ea6d a673               		ldx wedge_unit			; show current device number
   136  ea6f 98                 		tya
   137  ea70 2083cf             		jsr INTOUT
   138  ea73 2034d5             		jsr CRLF
   139  ea76 4cffb3             		jmp READY
   140                          
   141                          set_device
   142                          		; prerequsites for RDINT: 
   143                          		; - TXTPTR $77/$78 point to first char
   144                          		; - A contains that first char
   145                          		; - Carry is cleared
   146                          
   147  ea79 18                 		clc
   148  ea7a 20f6b8             		jsr RDINT			; convert string to unsigned int
   149  ea7d a511               		lda LINNUM			; LSB of converted number
   150  ea7f 8573               		sta wedge_unit
   151  ea81 4cffb3             		jmp READY
   152                          	
   153                          ;-------------- SEND COMMAND
   154                          
   155  ea84 a573               send_cmd	lda wedge_unit
   156  ea86 85d4               		sta FA
   157  ea88 a96f               		lda #$6f			; DATA SA 15
   158  ea8a 85d3               		sta SA
   159  ea8c 20d5f0             		jsr LISTN			; LISTEN 
   160  ea8f a5d3               		lda SA
   161  ea91 2043f1             		jsr SECND			; send secondary address
   162                          
   163  ea94 e677               SENDCMD2	inc TXTPTR
   164  ea96 a000               		ldy #0			
   165  ea98 b177               		lda (TXTPTR),y
   166  ea9a f006               		beq SENDCMDDONE	
   167  ea9c 209ef1             		jsr CIOUT			; send char to IEEE
   168  ea9f b8                 		clv 
   169  eaa0 50f2               		bvc SENDCMD2			; branch always
   170                          
   171  eaa2 20b9f1             SENDCMDDONE	jsr UNLSN
   172  eaa5 18                 		clc
   173  eaa6 9002               		bcc get_status
   174                          
   175                          ;-------------- Relative Branch forwarder
   176                          
   177  eaa8 f026               to_prepare_fn:	beq prepare_fn		
   178                          
   179                          ;-------------- GET STATUS
   180                          
   181  eaaa 8477               get_status	sty TXTPTR
   182  eaac a573               		lda wedge_unit
   183  eaae 85d4               		sta FA
   184  eab0 20d2f0             		jsr TALK			; TALK
   185  eab3 a96f               		lda #$6f			; DATA SA 15
   186  eab5 85d3               		sta SA
   187  eab7 2043f1             		jsr SECND			; send secondary address
   188                          
   189  eaba 20c0f1             GS_NEXTCHAR	jsr ACPTR			; read byte from IEEE bus
   190  eabd c90d               		cmp #$0D			; last byte = CR?		
   191  eabf f006               		beq GS_DONE
   192  eac1 2002e2             		jsr SCROUT			; write char to screen
   193  eac4 b8                 		clv 
   194  eac5 50f3               		bvc GS_NEXTCHAR			; branch always
   195                          
   196  eac7 2002e2             GS_DONE		jsr SCROUT			; write char to screen
   197  eaca 20aef1             		jsr UNTLK			; UNTALK
   198  eacd 4cffb3             		jmp READY
   199                          
   200                          ;------------------------------------------------------------------------------
   201                          ; identify filename to load/run, includes quote handling
   202                          
   203                          prepare_fn
   204  ead0 c8                 		iny				; count filename length
   205  ead1 b177               		lda (TXTPTR),y
   206  ead3 f01a               		beq end_name
   207  ead5 c922               		cmp #'"'			; quote character
   208  ead7 d0f7               		bne prepare_fn
   209                          
   210  ead9 a5b3               handle_quote	lda wedge_char
   211  eadb 3012               		bmi end_name
   212  eadd 0980               		ora #$80
   213  eadf 85b3               		sta wedge_char 
   214  eae1 98                 		tya
   215  eae2 a000               		ldy #0
   216  eae4 18                 		clc
   217  eae5 6577               		adc TXTPTR
   218  eae7 8577               		sta TXTPTR
   219  eae9 90e5               		bcc prepare_fn
   220  eaeb e678               		inc TXTPTR+1
   221  eaed d0e1               		bne prepare_fn
   222                          
   223  eaef 88                 end_name	dey 
   224  eaf0 84d1               		sty FNLEN			; store length
   225  eaf2 a677               		ldx TXTPTR
   226  eaf4 e8                 		inx
   227  eaf5 86da               		stx FNADR
   228  eaf7 a578               		lda TXTPTR + 1
   229  eaf9 85db               		sta FNADR + 1
   230  eafb a573               		lda wedge_unit
   231  eafd 85d4               		sta FA
   232  eaff a5b3               		lda wedge_char			; load/run?
   233  eb01 297f               		and #$7f
   234  eb03 85b3               		sta wedge_char
   235  eb05 d039               		bne to_loadrun			; yes
   236                          
   237                          ;-------------- DIRECTORY
   238                          
   239  eb07 a900               		lda #0				; Clear the status flag
   240  eb09 8596               		sta STATUS
   241  eb0b a960               		lda #$60			; DATA SA 0
   242  eb0d 85d3               		sta SA
   243  eb0f 20a5f4             		jsr OPENI			; open file
   244  eb12 20d2f0             		jsr TALK
   245  eb15 a5d3               		lda SA
   246  eb17 2043f1             		jsr SECND
   247                          
   248  eb1a a003               		ldy #3
   249                          list_blocks
   250  eb1c 84d1               		sty FNLEN
   251  eb1e 20c0f1             		jsr ACPTR			; read byte from IEEE
   252  eb21 85fd               		sta MEMUSS			; store blocks LSB
   253  eb23 a496               		ldy STATUS			; check the status. is it non-zero?
   254  eb25 d01b               		bne to_stoplisting		; yes
   255  eb27 20c0f1             		jsr ACPTR
   256  eb2a 85fe               		sta MEMUSS + 1			; store blocks MSB
   257  eb2c a496               		ldy STATUS
   258  eb2e d012               		bne to_stoplisting
   259  eb30 a4d1               		ldy FNLEN
   260  eb32 88                 		dey 
   261  eb33 d0e7               		bne list_blocks
   262  eb35 a6fd               		ldx MEMUSS
   263  eb37 a5fe               		lda MEMUSS + 1
   264  eb39 2083cf             		jsr INTOUT			; write #blocks to screen
   265  eb3c a920               		lda #' '
   266  eb3e d006               		bne listing			; branch always
   267                          
   268                          ;-------------- Relative Branch forwarder
   269                          
   270  eb40 d03b               to_loadrun:	bne loadrun
   271  eb42 d031               to_stoplisting:	bne stoplisting
   272  eb44 d0d6               to_list_blocks:	bne list_blocks
   273                          
   274                          
   275                          ;-------------- Continuation of DIRECTORY
   276                          
   277                          listing
   278  eb46 2002e2             		jsr SCROUT
   279  eb49 20c0f1             LISTLOOP	jsr ACPTR			; read byte from IEEE
   280  eb4c a696               		ldx STATUS			; was it successful?
   281  eb4e d025               		bne stoplisting			; no, so exit
   282  eb50 c900               		cmp #0				; Is it end of line
   283  eb52 f018               		beq newline			; yes, jump ahead
   284  eb54 2002e2             		jsr SCROUT			; write filename and type
   285  eb57 2035f3             		jsr STOPEQ			; Was STOP key pressed?
   286  eb5a f019               		beq stoplisting			; Yes, we're done. Jump out
   287  eb5c 20e4ff             		jsr GETIN			; pause listing with SPACE key
   288  eb5f f0e8               		beq LISTLOOP			; no key pressed -> continue
   289  eb61 c920               		cmp #32				; <space>?
   290  eb63 d0e4               		bne LISTLOOP			; No, go back for more
   291                          
   292  eb65 20e4ff             listwait	jsr GETIN			; get a key
   293  eb68 f0fb               		beq listwait			; 0=no key, so keep waiting
   294                          
   295  eb6a d0dd               		bne LISTLOOP			; then continue
   296                          
   297                          ;-------------- end of directory entry
   298                          
   299  eb6c a90d               newline		lda #$0D			; <CR>
   300  eb6e 2002e2             		jsr SCROUT			; print it
   301  eb71 a002               		ldy #2
   302  eb73 d0cf               		bne to_list_blocks
   303                          
   304                          ;-------------- listing is done - end or stop key pressed
   305                          
   306  eb75 202ff7             stoplisting	jsr CLSEI			; close file with $E0, unlisten
   307                          
   308  eb78 68                 		pla 
   309  eb79 68                 		pla 
   310  eb7a 4cffb3             		jmp READY			; BASIC warm start
   311                          
   312                          ;-------------- LOAD / RUN
   313                          
   314                          loadrun
   315  eb7d a900               		lda #0				; Clear status byte
   316  eb7f 8596               		sta STATUS
   317  eb81 859d               		sta VERCK			; LOAD=0, VERIFY=1
   318  eb83 2056f3             		jsr LOADOP			; LOAD without pointer change
   319                          
   320  eb86 a596               		lda STATUS			; Did it load?
   321  eb88 2910               		and #$10
   322  eb8a d020               		bne loaderr			; No, exit out
   323                          
   324  eb8c a5ca               		lda EAL+1			; end of program MSB
   325  eb8e 852b               		sta VARTAB+1			; start of basic variables MSB
   326  eb90 a5c9               		lda EAL				; end of program LSB
   327  eb92 852a               		sta VARTAB			; start of basic variables LSB
   328                          
   329  eb94 2034d5             		jsr CRLF
   330  eb97 20e9b5             		jsr RSTXCLR			; reset TXTPTR and perform CLR
   331  eb9a 20b6b4             		jsr LINKPRG			; rebuild chaining of BASIC lines
   332                          
   333  eb9d a5b3               		lda wedge_char
   334  eb9f c92f               		cmp #$2f			; if '/' then load only, omit RUN
   335  eba1 d003               		bne startprg			; '^' --> RUN
   336  eba3 4cffb3             		jmp READY			; load only, exit with BASIC warm start
   337                          
   338  eba6 2022b6             startprg	jsr STXTPT			; reset TXTPTR
   339  eba9 4c4ab7             		jmp NEWSTT			; RUN
   340                          
   341  ebac 4c25f4             loaderr		jmp FILENOTFOUND		; FILE NOT FOUND, return to basic
   342                          

; ******** Source: editrom_hi.asm
    62                          }		
    63                          	}
    64                          
    65                          	;----- These features require ESC codes
    66                          
    67                          	!IF ESCCODES = 1 {

; ******** Source: editescape.asm
     1                          ; PET/CBM EDIT ROM - Code to check for ESC Sequence
     2                          ; ================
     3                          ; Goal is to support as many C128/CBM-II ESC codes as possible
     4                          ;
     5                          
     6                          ;-------------- Check for ESC as LAST character
     7                          ;
     8                          ; NOTE: We JMP here from EDITROMxx.ASM. Accumulator holds code of CURRENT character
     9                          ;       If we want to continue processing as normal we need to JMP ESC_DONE.
    10                          ;       If we need to modify the action we set DATAX with the new character.
    11                          ;       If we want to skip the rest of the character processing we should JMP IRQ_EPILOG .
    12                          
    13  ebaf ae8203             CheckESC	LDX LASTCHAR 		; Previous character printed
    14  ebb2 e01b               		CPX #$1B		; <ESC>?
    15  ebb4 f00d               		BEQ ESC_YES		; Yes, process it
    16  ebb6 c91b               		CMP #$1B		; Is current Chr ESC?
    17  ebb8 f003               		BEQ ESC_NOW		; Yes, 
    18  ebba 4c16e2             		JMP ESC_DONE		; No, back to normal checking
    19                          
    20                          ;-------------- ESC is current Chr
    21                          
    22  ebbd 8d8203             ESC_NOW		STA LASTCHAR		; Remember it
    23  ebc0 4ca6e1             		JMP IRQ_EPILOG		; don't process anything
    24                          
    25                          ;-------------- Process ESC sequence
    26                          
    27  ebc3 c91b               ESC_YES		CMP #$1b		; Is current char <ESC>?
    28  ebc5 f002               		BEQ DoESCESC		; Yes, Do <ESC><ESC>
    29  ebc7 d005               		BNE DoEscapeCode	; No,  Do <ESC>+KEY
    30                          
    31                          ;-------------- Do <ESC><ESC>
    32                          
    33  ebc9 a900               DoESCESC	LDA #0			; Clear character
    34  ebcb 4cbbe3             		JMP ESCAPE_O		; <ESC>+O (escape)
    35                          
    36                          ;-------------- Do <ESC>+KEY Sequence
    37                          
    38  ebce 297f               DoEscapeCode	AND #$7F		; Strip top bit
    39  ebd0 38                 		SEC
    40                          !IF (COLOURPET=1) OR (VIDSWITCH=1) {
    41  ebd1 e930               		SBC #$30		; Subtract 30 (Start at "0")
    42  ebd3 c92f               		CMP #$2F		; Make sure it is in range!
    43                          } ELSE {
    44                          		SBC #$40		; Subtract 40 (Start at "@")
    45                          		CMP #$20		; Make sure it is in range!
    46                          }
    47  ebd5 b010               		BCS DoESCDONE		; Yes, skip
    48                          
    49  ebd7 a200               		LDX #0
    50  ebd9 8e8203             		STX LASTCHAR		; Clear Last Char
    51                          
    52  ebdc 0a                 		ASL
    53  ebdd aa                 		TAX
    54  ebde bdebeb             		LDA ESCVECTORS+1,X	; ESC Sequence Vectors
    55  ebe1 48                 		PHA
    56  ebe2 bdeaeb             		LDA ESCVECTORS,X	; ESC Sequence Vectors
    57  ebe5 48                 		PHA			; Push address to stack so RTS will jump to selected routine
    58                          ;		LDA #0			; Clear Character
    59  ebe6 60                 		RTS
    60                          
    61  ebe7 4c16e2             DoESCDONE	JMP ESC_DONE
    62                          
    63                          ;-------------- Esc Sequence Vectors    (*=changed from C128)
    64                          
    65                          ESCVECTORS
    66                          
    67                          ;--------------- COLOURPET ESC Codes: ESC 0 to 9 plus :;<=>?
    68                          ;                Set Colour to specified value (0 to 15).
    69                          ;
    70                          !IF (COLOURPET=1) OR (VIDSWITCH=1) {
    71                            !IF (COLOURPET=1) {
    72  ebea 4cec               		!WORD ESCAPE_NUM-1	; Esc-0 Set Colour to Black
    73  ebec 4cec               		!WORD ESCAPE_NUM-1	; Esc-1 Set Colour to Medium Grey
    74  ebee 4cec               		!WORD ESCAPE_NUM-1	; Esc-2 Set Colour to Blue
    75  ebf0 4cec               		!WORD ESCAPE_NUM-1	; Esc-3 Set Colour to Light Blue
    76  ebf2 4cec               		!WORD ESCAPE_NUM-1	; Esc-4 Set Colour to Green
    77  ebf4 4cec               		!WORD ESCAPE_NUM-1	; Esc-5 Set Colour to Light Green
    78  ebf6 4cec               		!WORD ESCAPE_NUM-1	; Esc-6 Set Colour to Dark Cyan
    79  ebf8 4cec               		!WORD ESCAPE_NUM-1	; Esc-7 Set Colour to Light Cyan
    80  ebfa 4cec               		!WORD ESCAPE_NUM-1	; Esc-8 Set Colour to Red
    81  ebfc 4cec               		!WORD ESCAPE_NUM-1	; Esc-9 Set Colour to Light Red
    82  ebfe 4cec               		!WORD ESCAPE_NUM-1	; Esc-: Set Colour to Dark Purple
    83  ec00 4cec               		!WORD ESCAPE_NUM-1	; Esc-; Set Colour to Purple
    84  ec02 4cec               		!WORD ESCAPE_NUM-1	; Esc-< Set Colour to Dark Yellow
    85  ec04 4cec               		!WORD ESCAPE_NUM-1	; Esc-= Set Colour to Yellow
    86  ec06 4cec               		!WORD ESCAPE_NUM-1	; Esc-> Set Colour to Light Grey
    87  ec08 4cec               		!WORD ESCAPE_NUM-1	; Esc-? Set Colour to White
    88                          } ELSE {
    89                          
    90                          ;--------------- VIDSWITCH ESC Codes: ESC 0 to 9
    91                          ;                Sets a specific video mode immediately (and temporarily)
    92                          ;                For manually setting the video mode, when testing different
    93                          ;                monitors and/or NTSC/PAL composite adapters.
    94                          ;                COLOURPET and VIDSWITCH cannot be combined!
    95                          ;
    96                          		!WORD ESCAPE_SETVID-1	; Esc-0 Set to Video MODE 0
    97                          		!WORD ESCAPE_VID-1	; Esc-1 Set to Video MODE 1
    98                          		!WORD ESCAPE_VID-1	; Esc-2 Set to Video MODE 2
    99                          		!WORD ESCAPE_VID-1	; Esc-3 Set to Video MODE 3
   100                          		!WORD ESCAPE_VID-1	; Esc-4 Set to Video MODE 4
   101                          		!WORD ESCAPE_VID-1	; Esc-5 Set to Video MODE 5
   102                          		!WORD ESCAPE_VID-1	; Esc-6 Set to Video MODE 6
   103                          		!WORD ESCAPE_VID-1	; Esc-7 Set to Video MODE 7
   104                          		!WORD ESCAPE_VID-1	; Esc-8 Set to Video MODE 8
   105                          		!WORD ESCAPE_VID-1	; Esc-9 Set to Video MODE 9
   106                          		!WORD NOESCAPE-1	; NONE
   107                          		!WORD NOESCAPE-1	; NONE
   108                          		!WORD NOESCAPE-1	; NONE
   109                          		!WORD NOESCAPE-1	; NONE
   110                          		!WORD NOESCAPE-1	; NONE
   111                          		!WORD NOESCAPE-1	; NONE
   112                            }
   113                          }
   114                          
   115                          ;-------------- Normal ESC Codes
   116                          
   117  ec0a 49ec               		!WORD ESCAPE_AT-1	; Esc-@ Clear Remainder of Screen
   118  ec0c 49ec               		!WORD ESCAPE_A-1	; Esc-a Auto Insert
   119  ec0e 49ec               		!WORD ESCAPE_B-1	; Esc-b Bottom
   120  ec10 49ec               		!WORD ESCAPE_C-1	; Esc-c Cancel Auto Insert
   121  ec12 49ec               		!WORD ESCAPE_D-1	; Esc-d Delete Line
   122  ec14 5cec               		!WORD ESCAPE_E-1	; Esc-e ?     / Fill BG    (was: Cursor Non Flash)
   123  ec16 95ec               		!WORD ESCAPE_F-1	; Esc-f Flash / Fill FG+BG (was: Cursor Flash)
   124  ec18 acec               		!WORD ESCAPE_G-1	; Esc-g Bell Enable
   125  ec1a b4ec               		!WORD ESCAPE_H-1	; Esc-h Bell Disable
   126  ec1c 49ec               		!WORD ESCAPE_I-1	; Esc-i Insert Line
   127  ec1e 49ec               		!WORD ESCAPE_J-1	; Esc-j Start-of-Line
   128  ec20 49ec               		!WORD ESCAPE_K-1	; Esc-k End-of-Line
   129  ec22 49ec               		!WORD ESCAPE_L-1	; Esc-l Scroll On
   130  ec24 49ec               		!WORD ESCAPE_M-1	; Esc-m Scroll Off
   131  ec26 8bed               		!WORD ESCAPE_N-1	; Esc-n Screen Normal
   132  ec28 bae3               		!WORD ESCAPE_O-1	; Esc-o Escape all modes (Also: <ESC><ESC>)
   133  ec2a 69e3               		!WORD ESCAPE_P-1	; Esc-p Erase Begin
   134  ec2c bcec               		!WORD ESCAPE_Q-1	; Esc-q Erase End
   135  ec2e 93ed               		!WORD ESCAPE_R-1	; Esc-r Screen Reverse
   136  ec30 c2ec               		!WORD ESCAPE_S-1	; Esc-s Text/Lowercase Mode * (was: Block Cursor)
   137  ec32 49ec               		!WORD ESCAPE_T-1	; Esc-t Top
   138  ec34 c8ec               		!WORD ESCAPE_U-1	; Esc-u Graphics/Uppercase Mode * (was: Underline Cursor)
   139  ec36 c8e3               		!WORD ESCAPE_V-1	; Esc-v Scroll Up
   140  ec38 f7e6               		!WORD ESCAPE_W-1	; Esc-w Scroll Down
   141  ec3a 49ec               		!WORD ESCAPE_X-1	; Esc-x Switch 40/80 Col
   142  ec3c 9bed               		!WORD ESCAPE_Y-1	; Esc-y Normal Chr Set * (was: Set Default Tabs)
   143  ec3e a3ed               		!WORD ESCAPE_Z-1	; Esc-z Alternate Chr Set * (was: Clear All Tabs)
   144  ec40 ceec               		!WORD ESCAPE_LB-1	; Esc-[ Mark Start
   145  ec42 67ed               		!WORD ESCAPE_BS-1	; Esc-\ Toggle ASCII / DIN
   146  ec44 f4ec               		!WORD ESCAPE_RB-1	; Esc-] Mark End (Copy)
   147  ec46 41ed               		!WORD ESCAPE_UA-1	; Esc-UPARROW Paste
   148  ec48 49ec               		!WORD ESCAPE_BA-1	; Esc-BACKARROW Display Project Info
   149                          
   150                          ;=============== ESCAPE CODES not in normal PET code
   151                          ;
   152                          ; The following ESCAPE CODE entry points need to be assigned
   153                          ; and/or additional code must be written to support them.
   154                          
   155                          ESCAPE_AT	; Esc-@ Clear Remainder of Screen
   156                          ESCAPE_A	; Esc-a Auto Insert
   157                          ESCAPE_C	; Esc-c Cancel Auto Insert
   158                          ESCAPE_K	; Esc-k End-of-Line
   159                          ESCAPE_L	; Esc-l Scroll On
   160                          ESCAPE_M	; Esc-m Scroll Off
   161                          
   162                          !IF SS40=0 {
   163                          ESCAPE_X	; Esc-x Switch 40/80 Col
   164                          }
   165                          		
   166                          !IF INFO=0 {
   167                          ESCAPE_BA	; Esc-Backarrow Display Project info
   168                          }
   169                          
   170                          ;-------------- These are codes that are not in 40-COL Codebase C0
   171                          
   172                          !IF CODEBASE=0 {
   173                          ESCAPE_B	; ESC-B Set Window Bottom
   174                          ESCAPE_T	; ESC-T Set Window Top
   175                          ESCAPE_D	; ESC-D Delete Line
   176                          ESCAPE_I	; ESC-I Insert Line
   177                          ESCAPE_J	; ESC-J Start of Line
   178                          }
   179                          
   180  ec4a 4ca6e1             NOESCAPE	JMP IRQ_EPILOG				; Ignore sequence for now
   181                          
   182                          
   183                          ;====================================================================================
   184                          ; New ESC sequences
   185                          ;====================================================================================
   186                          
   187                          ;-------------- ColourPET Colours
   188                          
   189                          !IF COLOURPET=1 {
   190  ec4d a5d9               ESCAPE_NUM	LDA DATAX				; Character
   191  ec4f 38                 		SEC
   192  ec50 e930               		SBC #$30				; Subtract 30 (Start at "0")
   193                          
   194  ec52 aa                 ESC_NUM2	TAX					; The Colour number becomes the index
   195  ec53 bde1ee             		LDA COLOURS,X				; Lookup the correct PETSCII code
   196  ec56 85d9               		STA DATAX				; replace ESC code with colour code
   197  ec58 a900               		LDA #0					;
   198  ec5a 4c19e2             		JMP ESC_DONE2				; return and process
   199                          }
   200                          
   201                          ;-------------- Video Configuration Switching
   202                          
   203                          !IF VIDSWITCH=1 {
   204                          ESCAPE_VID	LDA DATAX				; Character
   205                          		SEC
   206                          		SBC #$30				; Subtract 30 (Start at "0")
   207                          		ASL
   208                          		ASL
   209                          		ASL
   210                          		ASL					; multiply by 16 (# of bytes per each set)
   211                          		TAY					; Y is offset into table
   212                          		LDX #0					; byte counter
   213                          
   214                          ESCVLOOP	LDA VIDMODE0,Y				; Get byte from table at offset Y
   215                          		STX CRT_Address				; Select the CRTC register 			CHIP
   216                          		STA CRT_Status				; Write to the register				CHIP
   217                          		INY					; Next table byte
   218                          		INX					; count
   219                          		CPX #14					; We copy R0 to R13. 14/15 are always zero.
   220                          		BMI ESCVLOOP				; loop for more
   221                          		LDA #0					;
   222                          		JMP IRQ_EPILOG				; Ignore sequence for now
   223                          
   224                          ;-------------- VIDEO MODES TABLE
   225                          ;
   226                          ; These are CRTC register sets. There are 16 bytes per set to make calculations simpler.
   227                          ; Use ESC+0 to ESC+9 to select a set to configure the CRTC controller.
   228                          ; NOTE: The CRTC registers can be updated using CHR codes 14 and 142 causing the video
   229                          ;       to revert to the default CRTC settings as set from the main code. This feature
   230                          ;       is handy for hardware testing or using an external composite adapter.
   231                          ;
   232                          ;         REGISTER -> R0 R1 R2 R3 R4  R5 R6 R7 R8 R9 R10 R11 R12 R13 Rxx Rxx   DESCRIPTION
   233                          ;                     -- -- -- -- -- --- -- -- -- -- --- --- --- --- --- ---   -----------
   234                          VIDMODE0 	!byte 49,40,41,15,40,  3,25,29, 0, 9,  0,  0, 16,  0,  0,  0 ; 40/80 TEXT     NA
   235                          VIDMODE1        !byte 49,40,41,15,32,  5,25,33, 0, 7,  0,  0, 16,  0,  0,  0 ; 40/80 GRAPHIC  NA
   236                          VIDMODE2	!byte 49,40,41,15,39,  0,25,32, 0, 9,  0,  0, 16,  0,  0,  0 ; 40/80 TEXT     EURO
   237                          VIDMODE3	!byte 49,40,41,15,49,  0,25,37, 0, 7,  0,  0, 16,  0,  0,  0 ; 40/80 GRAPHIC  EURO
   238                          VIDMODE4	!byte 58,40,44, 8,32,  9,25,29, 0, 9,  0,  0, 16,  0,  0,  0 ; 8296D TEXT     EURO
   239                          VIDMODE5	!byte 58,40,44, 8,41,  3,25,34, 0, 7,  0,  0, 16,  0,  0,  0 ; 8296D GRAPHIC  EURO
   240                          VIDMODE6        !byte 63,40,50,18,30,  6,25,28, 0, 7,  0,  0, 16,  0,  0,  0 ; NTSC
   241                          VIDMODE7	!byte 63,40,50,18,30,  6,25,28, 0, 7,  0,  0,  0,  0,  0,  0 ; NTSC / INVERT VIDEO
   242                          VIDMODE8	!byte 63,40,47,20,36,123,25,32, 0, 7,  0,  0, 16,  0,  0,  0 ; PAL
   243                          VIDMODE9        !byte 63,40,47,20,36,123,25,32, 0, 7,  0,  0,  0,  0,  0,  0 ; PAL  / INVERT VIDEO
   244                          ;
   245                          ; Extra Modes. You can substitute this mode for any above if you want
   246                          ;VIDMODEXXXX	!byte 49,20,31,15,40,  5,25,33, 0, 9,  0,  0, 16,  0,  0,  0 ; 20/40 TEXT     NA
   247                          
   248                          }
   249                          
   250                          ;------------------------------------------------------------------------------------------------
   251                          ; ESC-BACKARROW Display Project Info
   252                          
   253                          !IF INFO>0 {
   254                          ESCAPE_BA
   255                          
   256                          ;-------------- DISPLAY FONT ON SCREEN
   257                          !IF INFO = 2 {
   258                          		LDY #0				; Y=0
   259                          INFLOOP		TYA				; LOOP[  A=Y
   260                          		STA SCREEN_RAM,Y		; Put it on the screen
   261                          		INY				; Next position and character
   262                          		BNE INFLOOP			; ] Loop for more
   263                          }
   264                          
   265                          ;-------------- DISPLAY PROJECT INFO		
   266                          !IF INFO > 0 {
   267                          		LDA #<INFOSTRING		; point to INFO string
   268                          		LDY #>INFOSTRING
   269                          		JSR STROUTZ
   270                          		JMP IRQ_EPILOG
   271                          }
   272                          }
   273                          
   274                          ;------------------------------------------------------------------------------------------------
   275                          ; ESC-E = Fill BG Colour
   276                          ; For NormalPET ?
   277                          ; For ColourPET will fill the screen with the current BG colour (ignores window)
   278                          ;               The FG of each character is not changed.
   279                          ; Note: This might be changed in the future to work with windows!
   280                          
   281                          ESCAPE_E
   282                          
   283                          !if COLOURPET=1 {
   284  ec5d adf28b             		LDA COLOURV
   285  ec60 29f0               		AND #$F0
   286  ec62 85b7               		STA TMPZB7
   287  ec64 a200               		LDX #0
   288                          ESCELOOP
   289  ec66 bd0088             		LDA COLOUR_RAM,X
   290  ec69 290f               		AND #$0F
   291  ec6b 05b7               		ORA TMPZB7
   292  ec6d 9d0088             		STA COLOUR_RAM,X
   293                          
   294  ec70 bdfa88             		LDA COLOUR_RAM+250,X
   295  ec73 290f               		AND #$0F
   296  ec75 05b7               		ORA TMPZB7
   297  ec77 9dfa88             		STA COLOUR_RAM+250,X
   298                          
   299  ec7a bdf489             		LDA COLOUR_RAM+500,X
   300  ec7d 290f               		AND #$0F
   301  ec7f 05b7               		ORA TMPZB7
   302  ec81 9df489             		STA COLOUR_RAM+500,X
   303                          
   304  ec84 bdee8a             		LDA COLOUR_RAM+750,X
   305  ec87 290f               		AND #$0F
   306  ec89 05b7               		ORA TMPZB7
   307  ec8b 9dee8a             		STA COLOUR_RAM+750,X	; don't overwrite non-visible locations (used for storage)
   308                          
   309                          !IF COLUMNS=80 {
   310                          		LDA COLOUR_RAM+1000,X
   311                          		AND #$0F
   312                          		ORA TMPZB7
   313                          		STA COLOUR_RAM+1000,X
   314                          
   315                          		LDA COLOUR_RAM+1250,X
   316                          		AND #$0F
   317                          		ORA TMPZB7
   318                          		STA COLOUR_RAM+1250,X
   319                          
   320                          		LDA COLOUR_RAM+1500,X
   321                          		AND #$0F
   322                          		ORA TMPZB7
   323                          		STA COLOUR_RAM+1500,X
   324                          
   325                          		LDA COLOUR_RAM+1750,X
   326                          		AND #$0F
   327                          		ORA TMPZB7
   328                          		STA COLOUR_RAM+1750,X	; don't overwrite non-visible locations (used for storage)
   329                          }
   330  ec8e e8                 		INX
   331  ec8f e0fa               		CPX #250
   332  ec91 d0d3               		BNE ESCELOOP
   333                          }
   334  ec93 4ca6e1             		JMP IRQ_EPILOG
   335                          
   336                          
   337                          ;------------------------------------------------------------------------------------------------
   338                          ; ESC-F = Flash Screen / Fill FG+BG Colour (was: Cursor Flash)
   339                          ; For NormalPET this will toggle the REVERSE bit (bit 7) of each character on the screen (ignores window)
   340                          ; For ColourPET this will fill the screen with the current colour FG+BG (ignores window)
   341                          ; Note: This might be changed in the future to work with windows!
   342                          
   343                          ESCAPE_F
   344                          
   345                          !if COLOURPET=1 {
   346  ec96 a200               		LDX #0
   347  ec98 adf28b             		LDA COLOURV
   348                          
   349  ec9b 9d0088             ESCFLOOP	STA COLOUR_RAM,X
   350  ec9e 9d0089             		STA COLOUR_RAM+$100,X
   351  eca1 9d008a             		STA COLOUR_RAM+$200,X
   352  eca4 9de88a             		STA COLOUR_RAM+$300-24,X	; don't overwrite non-visible locations (used for storage)
   353                          !IF COLUMNS = 80 {
   354                          		STA COLOUR_RAM+$400-24,X
   355                          		STA COLOUR_RAM+$500-24,X
   356                          		STA COLOUR_RAM+$600-24,X
   357                          		STA COLOUR_RAM+$700-48,X	; don't overwrite non-visible locations (used for storage)
   358                          }
   359  eca7 e8                 		INX
   360  eca8 d0f1               		BNE ESCFLOOP
   361                          }
   362                          
   363                          !if COLOURPET=0 {
   364                          		LDX #0
   365                          ESCFLOOP2
   366                          		LDA SCREEN_RAM,X
   367                          		EOR #$80
   368                          		STA SCREEN_RAM,X
   369                          
   370                          		LDA SCREEN_RAM+250,X
   371                          		EOR #$80
   372                          		STA SCREEN_RAM+250,X
   373                          
   374                          		LDA SCREEN_RAM+500,X
   375                          		EOR #$80
   376                          		STA SCREEN_RAM+500,X
   377                          
   378                          		LDA SCREEN_RAM+750,X
   379                          		EOR #$80
   380                          		STA SCREEN_RAM+750,X	; don't overwrite non-visible locations (used for storage)
   381                          
   382                          !IF COLUMNS = 80 {
   383                          		LDA SCREEN_RAM+1000,X
   384                          		EOR #$80
   385                          		STA SCREEN_RAM+1000,X
   386                          
   387                          		LDA SCREEN_RAM+1250,X
   388                          		EOR #$80
   389                          		STA SCREEN_RAM+1250,X
   390                          
   391                          		LDA SCREEN_RAM+1500,X
   392                          		EOR #$80
   393                          		STA SCREEN_RAM+1500,X
   394                          
   395                          		LDA SCREEN_RAM+1750,X
   396                          		EOR #$80
   397                          		STA SCREEN_RAM+1750,X	; don't overwrite non-visible locations (used for storage)
   398                          }
   399                          		INX
   400                          		CPX #250
   401                          		BNE ESCFLOOP2
   402                          
   403                          }
   404  ecaa 4ca6e1             		JMP IRQ_EPILOG
   405                          
   406                          ;------------------------------------------------------------------------------------------------
   407                          ESCAPE_G						; Esc-g Bell Enable
   408  ecad a901               		LDA #1
   409  ecaf 8d8303             		STA BELLMODE
   410  ecb2 4ca6e1             		JMP IRQ_EPILOG
   411                          
   412                          ;------------------------------------------------------------------------------------------------
   413                          ESCAPE_H						; Esc-h Bell Disable
   414  ecb5 a900               		LDA #0
   415  ecb7 8d8303             		STA BELLMODE
   416  ecba 4ca6e1             		JMP IRQ_EPILOG
   417                          
   418                          ;------------------------------------------------------------------------------------------------
   419                          ESCAPE_Q						; Esc-q Erase End
   420  ecbd 20a6ee             		JSR ERASE_TO_EOL
   421  ecc0 4ca6e1             		JMP IRQ_EPILOG
   422                          ;------------------------------------------------------------------------------------------------
   423                          ESCAPE_S						; Esc-s Standard Lowercase (was: Block Cursor)
   424  ecc3 200fe6             		JSR CRT_SET_TEXT			; Set Lowercase/Text Mode
   425  ecc6 4ca6e1             		JMP IRQ_EPILOG
   426                          ;------------------------------------------------------------------------------------------------
   427                          ESCAPE_U						; Esc-u Uppercase (was: Underline Cursor - not supported on PET)
   428  ecc9 2017e6             		JSR CRT_SET_GRAPHICS			; Set Uppercase/Graphics Mode
   429  eccc 4ca6e1             		JMP IRQ_EPILOG
   430                          
   431                          ;-------------- Copy/Paste functions
   432                          ;
   433                          ; These functions use Tape Buffer#1 to store copied byte(s)
   434                          ; TAPEB1   - Set to "ESC" character to indicate valid Start Marker
   435                          ; TAPEB+1  - Length of string (Max 160 characters)
   436                          ; TAPEB+2/3- Pointer to screen marked starting position 
   437                          ; TAPEB+4..- Buffer
   438                          ;
   439                          ; TODO: Add check for buffer start > buffer end !!!!
   440                          
   441                          ;-------------- ESC-[ Mark Start
   442                          
   443                          ESCAPE_LB
   444  eccf ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   445  ecd2 c91b               		CMP #27					; is it ESC?
   446  ecd4 f00a               		BEQ ESCLB_SET				; Yes, Start Mark, so skip initialize
   447                          
   448  ecd6 a900               		LDA #0					; Initialize buffer -
   449  ecd8 8d7b02             		STA TAPEB1+1				; Set Buffer Length to zero
   450  ecdb a91b               		LDA #27					; Buffer identifier = ESC
   451  ecdd 8d7a02             		STA TAPEB1				; Set Buffer identifier
   452                          ESCLB_SET	
   453  ece0 a5c5               		LDA ScrPtr+1				; Copy HI byte of line pointer
   454  ece2 8d7d02             		STA TAPEB1+3				; to buffer
   455  ece5 a5c4               		LDA ScrPtr				; Get LO byte of line pointer
   456  ece7 18                 		CLC
   457  ece8 65c6               		ADC CursorCol				; Add cursor offset
   458  ecea 8d7c02             		STA TAPEB1+2				;   to buffer
   459  eced 9003               		BCC ESCLB_SKIP				; do we need to update HI byte?
   460  ecef ee7d02             		INC TAPEB1+3				; yes, increment it
   461  ecf2 4ca6e1             ESCLB_SKIP	JMP IRQ_EPILOG				; Return
   462                          
   463                          ;--------------- ESC-] Mark End (Copy to buffer)
   464                          
   465                          ESCAPE_RB	
   466  ecf5 ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   467  ecf8 c91b               		CMP #27					; is it ESC?
   468  ecfa d043               		BNE ESCRB_EXIT				; No Start Mark, so exit out
   469                          		
   470                          ESCRB_INIT
   471  ecfc ad7d02             		LDA TAPEB1+3				; Copy Hi byte of paste buffer pointer
   472  ecff 85c8               		STA SAL+1				;   to work pointer
   473  ed01 ad7c02             		LDA TAPEB1+2				; Copy Lo byte of paste buffer pointer
   474  ed04 85c7               		STA SAL					;   to work pointer
   475                          
   476  ed06 a5c5               		LDA ScrPtr+1				; Copy Hi byte of screen pointer
   477  ed08 85ca               		STA EAL+1				;   to work pointer 2
   478  ed0a a5c4               		LDA ScrPtr				; Copy Lo byte of screen pointer
   479  ed0c 18                 		CLC
   480  ed0d 65c6               		ADC CursorCol				; Add cursor position
   481  ed0f 85c9               		STA EAL					;   to work pointer 2
   482  ed11 9002               		BCC ESCRB_SKIP				; do we need to update Hi byte?
   483  ed13 e6ca               		INC EAL+1				; yes, increment it
   484                          
   485  ed15 a200               ESCRB_SKIP	LDX #0					; length counter
   486  ed17 a000               		LDY #0					; offet for pointer
   487                          ESCRB_LOOP
   488  ed19 b1c7               		LDA (SAL),Y				; read byte from screen (SAL is updated, y never changes)
   489  ed1b 9d7e02             		STA TAPEB1+4,X				; Store in buffer (x is index)
   490                          
   491  ed1e a5c8               		LDA SAL+1				; Get HI byte
   492  ed20 c5ca               		CMP EAL+1				; Does it match?
   493  ed22 d006               		BNE ESCRB_CHECK				; no, keep going
   494  ed24 a5c7               		LDA SAL					; get lo byte of pointer
   495  ed26 c5c9               		CMP EAL					; does it match?
   496                          
   497  ed28 b00d               		BCS ESCRB_DONE				; yes, finish up
   498                          
   499  ed2a e8                 ESCRB_CHECK	INX
   500  ed2b e6c7               		INC SAL					; Increment pointer LO byte
   501  ed2d a5c7               		LDA SAL					; read it
   502  ed2f d002               		BNE ESCRB2				; is byte 0? No, skip hi byte
   503  ed31 e6c8               		INC SAL+1				; yes, increment hi byte
   504                          
   505  ed33 e0a0               ESCRB2		CPX #160				; Are we at maximum buffer length?
   506  ed35 d0e2               		BNE ESCRB_LOOP				; No, loop back for more
   507                          
   508  ed37 8e7b02             ESCRB_DONE	STX TAPEB1+1				; Store string length
   509  ed3a a900               		LDA #0
   510  ed3c 9d7f02             		STA TAPEB1+5,X				; Store a ZERO at end for STROUT routine
   511  ed3f 4ca6e1             ESCRB_EXIT	JMP IRQ_EPILOG				; Return
   512                          
   513                          ;--------------- ESC-UPARROW - Copy from buffer to screen
   514                          ESCAPE_UA	
   515  ed42 ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   516  ed45 c91b               		CMP #27					; is it ESC?
   517  ed47 d01c               		BNE ESCUA_OUT				; No Start Mark, so exit out
   518                          
   519  ed49 2057e6             		JSR BEEP
   520  ed4c a97e               		lda #<TAPEB1+4				; setup string address
   521  ed4e 85c7               		STA SAL
   522  ed50 a002               		ldy #>TAPEB1+4
   523  ed52 85c8               		STA SAL+1
   524                          
   525  ed54 a000               ESCUA_LOOP	LDY #0					; counter
   526  ed56 b1c7               		LDA (SAL),Y				; get byte from buffer
   527  ed58 f00b               		BEQ ESCUA_OUT
   528  ed5a 20d2ff             		JSR BSOUT				; print it
   529  ed5d e6c7               		INC SAL
   530  ed5f d0f3               		BNE ESCUA_LOOP
   531  ed61 e6c8               		INC SAL+1
   532  ed63 d0ef               		BNE ESCUA_LOOP
   533                          
   534  ed65 4ca6e1             ESCUA_OUT	JMP IRQ_EPILOG				; Return		
   535                          
   536                          
   537                          ;-------------- Eurokey Functions
   538                          ;
   539                          ; These functions SET or CLEAR the EUROFLAG location.
   540                          ; A '0' means use ASCII layout. A '1' means use DIN layout (swap Y and Z)
   541                          
   542  ed68 ad8403             ESCAPE_BS	LDA EUROFLAG
   543  ed6b 4901               		EOR #1
   544                          
   545  ed6d 8d8403             EuroSet		STA EUROFLAG
   546  ed70 2057e6             		JSR BEEP
   547  ed73 4ca6e1             		JMP IRQ_EPILOG
   548                          
   549                          ;-------------- Check if Euro keys need swapping
   550                          ;
   551                          ; .A contains character to add to keyboard buffer. If EUROFLAG=1 then check if Y or Z need swapping.
   552                          
   553  ed76 ae8403             EUROSWAP	LDX EUROFLAG		; Flag to swap Z and Y keys; 1=Swap
   554  ed79 f00e               		BEQ EUROSWAP_OUT
   555                          
   556  ed7b c95a               		CMP #'Z'		; Is it "Z"?
   557  ed7d d004               		BNE EUROSWAP2
   558  ed7f a959               		LDA #'Y'		; Yes, swap with "Y"
   559  ed81 d006               		BNE EUROSWAP_OUT
   560  ed83 c959               EUROSWAP2	CMP #'Y'		; Is it "Y"?
   561  ed85 d002               		BNE EUROSWAP_OUT
   562  ed87 a95a               		LDA #'Z'		; Yes, swap with "Z"
   563  ed89 4c6de5             EUROSWAP_OUT	JMP SCAN_NORM2		; Return to keyboard routine
   564                          
   565                          
   566                          ;-------------- Switchable 40/80 column Functions
   567                          ;
   568                          ; When SS40=1, ESC-X switches between 40/80 column mode.
   569                          ; Currently this is done with SOFT40 method where the 80 column screen is
   570                          ; reprogrammed to 40 column by increasing the left and right margins.
   571                          ; With future hardware we may be able to switch between REAL 40/80 column mode.
   572                          
   573                          !IF SS40=1 {
   574                          ESCAPE_X	JSR SS40_SwapModes	; Swap 40/80 Modes
   575                          		JMP IRQ_EPILOG		
   576                          }
   577                          
   578                          ;-------------- CRTC Chip Functions
   579                          ;
   580                          ; CRTC controller REGISTER 12 is used for Screen RAM Address HI
   581                          ; BIT 4 controls the INVERT line     (normal=1,rvs=0)
   582                          ; BIT 5 controls the CHR OPTION line (normal=0,alternate=1)
   583                          ;
   584                          ; NOTE: Only the MOTOROLA 6845 CRTC chip can READ register 12!
   585                          ; If MOT6845=0 then Register 12 is simply set (default for compatibility with most PET machines!)
   586                          ; If MOT6845=1 then Register 12 is read and then manipulated.
   587                          
   588                          ESCAPE_N						; ESC-N = Screen Normal
   589  ed8c 20b0ed             		JSR CRTPREP
   590                          	!if MOT6845=1 {
   591                          		ORA #%00010000				; Set BIT 4
   592                          	} else {
   593  ed8f a910               		LDA #16					; Normal screen, Normal chr set
   594                          	}
   595  ed91 4ca9ed             		JMP CRTUPDATE
   596                          
   597                          ESCAPE_R						; ESC-R = Screen Reverse
   598  ed94 20b0ed             		JSR CRTPREP
   599                          	!if MOT6845=1 {
   600                          		AND #%11101111				; Clear BIT 4
   601                          	} else {
   602  ed97 a900               		LDA #0					; Reverse screen, Normal chr set
   603                          	}
   604  ed99 4ca9ed             		JMP CRTUPDATE
   605                          
   606                          ESCAPE_Y						; ESC-Y = Normal Chr Set    (B-series). Was: Set Default Tabs (C128)
   607  ed9c 20b0ed             		JSR CRTPREP
   608                          	!if MOT6845=1 {
   609                          		AND #%11011111				; Clear BIT 5
   610                          	} else {
   611  ed9f a910               		LDA #16					; Normal screen, Normal chr set
   612                          	}
   613  eda1 4ca9ed             		JMP CRTUPDATE
   614                          				
   615                          ESCAPE_Z						; ESC-Z = Alternate Chr Set (B-Series). Was: Clear All Tabs (C128)
   616  eda4 20b0ed             		JSR CRTPREP
   617                          	!if MOT6845=1 {
   618                          		ORA #%00100000				; Set BIT 5
   619                          	} else {
   620  eda7 a930               		LDA #48					; Normal screen, Alternate chr set
   621                          	}
   622                          CRTUPDATE
   623  eda9 8d81e8             		STA CRT_Status				; Write the Value to previously selected register
   624  edac 58                 		CLI					; Enable Interrupts
   625  edad 4ca6e1             		JMP IRQ_EPILOG				; Continue
   626                          
   627  edb0 78                 CRTPREP		SEI
   628  edb1 a90c               		LDA #12					; CRTC Register#12 - Display Address HI
   629  edb3 8d80e8             		STA CRT_Address				; Select the Register 
   630  edb6 ad81e8             		LDA CRT_Status				; Read the Value (if CRTC chip is NOT a Motorola6845 then this will not work)
   631  edb9 60                 		RTS

; ******** Source: editrom_hi.asm
    68                          
    69                          		!IF COLOURPET = 1 {

; ******** Source: cpetsubs.asm
     1                          ; PET/CBM EDIT ROM - ColourPET Routines; Init, Change colours, Set Registers, Sync Pointers
     2                          ; ================
     3                          ;
     4                          ; Standard C128 colour codes will be used.
     5                          ; ------------------------------------------------------------------
     6                          ; NOTE: Some code is included for possible future hardware options
     7                          ;       Colour key codes (C64 code at E8DA)
     8                          ; ------------------------------------------------------------------
     9                          
    10                          ;-------------- Check Colour Codes
    11                          ;
    12                          ; Checks if the character to print is a colour code.
    13                          ; If so it sets the proper foreground, background or border COLOUR.
    14                          ; To set colours you can use 1 to 3 contiguous color code characters.
    15                          ; The FIRST code will set the FG colour (normal behaviour)
    16                          ; The SECOND code will set the BG colour
    17                          ; The THIRD code will set the BORDER colour (future hardware)
    18                          ; Any NON-Colour Code will reset the count
    19                          
    20                          CheckColourCodes
    21                          
    22                          !if DEBUG = 1 { INC DBLINE+9 }			; DEBUG
    23                          
    24  edba 48                 		PHA				; Save the character
    25  edbb a20f                  		LDX #$0F			; Table has 15 entries
    26  edbd dde1ee             ccloop		CMP COLOURS,X			; Does it match code from table?
    27  edc0 f00a               		BEQ ccfound			; Yes, done
    28  edc2 ca                 		DEX				; 
    29  edc3 10f8               		BPL ccloop			; loop for more
    30                          
    31  edc5 a200               ccnotfound	LDX #0				; not found
    32  edc7 8ef68b             		STX COLOURCOUNT			; Clear the Count
    33  edca f027               		BEQ ccexit			; no match, exit 
    34                          
    35  edcc eef68b             ccfound		INC COLOURCOUNT			; Count code
    36  edcf 8a                 		TXA
    37  edd0 aef68b             		LDX COLOURCOUNT			; 
    38  edd3 e001               		CPX #1				; FIRST?
    39  edd5 d003               		BNE cc3		
    40  edd7 8df38b             		STA COLOURFG			; Set the FG colour		
    41                          
    42  edda e002               cc3		CPX #2				; SECOND?
    43  eddc d003               		BNE cc4
    44  edde 8df48b             		STA COLOURBG			; Set the BG colour
    45                          
    46  ede1 e003               cc4		CPX #3				; THIRD?
    47  ede3 d00b               		BNE cc5
    48  ede5 8df58b             		STA COLOURBORDER		; Set the BORDER colour
    49  ede8 8df88b             		STA COLOURREGBORDER		; Store it in the BORDER register
    50  edeb a900               		LDA #0
    51  eded 8df68b             		STA COLOURCOUNT			; Reset count
    52                          
    53  edf0 200fee             cc5		JSR SetColourValue   		; Set the FG/BG value
    54  edf3 68                 ccexit		PLA				; Restore the Character
    55  edf4 60                 		RTS
    56                          
    57                          ;-------------- Initialize ColourPET
    58                          ;
    59                          ; This is called from the RESET_EDITOR routine.
    60                          ; It sets the default foreground, background and border colours.
    61                          
    62                          ColourPET_Init
    63                          
    64                          		!IF COLOURPET = 2 { JSR ClearColourRAM }
    65                          
    66  edf5 2089e6             		JSR INIT_EDITOR			; Do Normal Initialization
    67                          
    68  edf8 a900               		LDA #0
    69  edfa 8df68b             		STA COLOURCOUNT			; Reset Colour Count
    70                          
    71  edfd a902               		LDA #DEFAULTFG			; Default Foreground Colour
    72  edff 8df38b             		STA COLOURFG
    73  ee02 a902               		LDA #DEFAULTBG			; Default Background Colour
    74  ee04 8df48b             		STA COLOURBG
    75  ee07 a902               		LDA #DEFAULTBO			; Default Border Colour
    76                          		
    77                          ;-------------- Set Border Colour and update Register
    78                          
    79                          SetColourAndBorder
    80  ee09 8df58b             		STA COLOURBORDER		; Set the BORDER colour
    81  ee0c 8df88b             		STA COLOURREGBORDER		; Store it in the BORDER register
    82                          
    83                          ;-------------- Set Colour
    84                          ;
    85                          ; COLOURMODE OPTION: 0=DIGITAL, 1=ANALOG
    86                          ;
    87                          ; DIGITAL: Takes the FG colour and BG colour and combines them into one value
    88                          ;          RGBIRGBI - Lower bits for FG, Upper bits for BG
    89                          ;
    90                          ; ANALOG : Takes the FG colour and uses it as an index to the RGB Conversion table.
    91                          ;          RRRGGGBB All bits for FG. Background colour set for entire screen
    92                          
    93                          SetColourValue
    94                          
    95                          !if COLOURMODE=0 {
    96  ee0f adf48b             		LDA COLOURBG			; Get the BG colour
    97  ee12 0a                 		ASL				; move BG colour to upper nibble
    98  ee13 0a                 		ASL
    99  ee14 0a                 		ASL
   100  ee15 0a                 		ASL
   101  ee16 18                 		CLC
   102  ee17 6df38b             		ADC COLOURFG			; Add the FG colour
   103                          } ELSE {
   104                          		LDX COLOURFG			; Get the FG index
   105                          		LDA RGBTABLE,X			; Convert it to Analog RRRGGGBB
   106                          }
   107  ee1a 8df28b             		STA COLOURV			; Store it
   108  ee1d 60                 		RTS
   109                          
   110                          ;-------------- Clear Colour Ram - Green on Black
   111                          ;
   112                          ; This was a temporary solution until colour routines were debugged.
   113                          ; Not needed now since Colour Erase_To_EOL completed. But might come in handly later.
   114                          ; NOTE: This routine clears ALL colour ram INCLUDING areas used for storage!!!!!!
   115                          
   116                          ClearColourRAM
   117  ee1e a905               		LDA #5
   118  ee20 a200               		LDX #0
   119                          CCRAM1		
   120  ee22 9d0088             		STA COLOUR_RAM,X
   121  ee25 9d0089             		STA COLOUR_RAM+$100,X
   122  ee28 9d008a             		STA COLOUR_RAM+$200,X
   123  ee2b 9d008b             		STA COLOUR_RAM+$300,X
   124                          !IF COLUMNS = 80 {
   125                          		STA COLOUR_RAM+$400,X
   126                          		STA COLOUR_RAM+$500,X
   127                          		STA COLOUR_RAM+$600,X
   128                          		STA COLOUR_RAM+$700,X
   129                          }
   130  ee2e e8                 		INX
   131  ee2f d0f1               		BNE CCRAM1
   132  ee31 60                 		RTS
   133                          
   134                          ;-------------- Sync Pointers - Current Line
   135                          ;
   136                          ; This takes the current line number in X and then uses the lookup tables
   137                          ; to find the screen and colour ram address of the start of the line and stores them
   138                          ; in the Character and Colour pointers.
   139                          
   140                          ColourPET_SyncPointersX
   141  ee32 85c4               		STA ScrPtr				; Pointer: Current Screen Line Address LO
   142                          !IF (CODEBASE=0) { 
   143  ee34 bd0bef             		LDA CLine_Addr_Hi,X			; Screen Line Addresses HI
   144  ee37 29f7               		AND #%11110111 
   145                          } ELSE {
   146                          		LDA Line_Addr_Hi,X			; Screen Line Addresses HI
   147                          }
   148                          
   149  ee39 85c5               		STA ScrPtr+1         			; Pointer: Current Screen Line Address HI
   150                          
   151  ee3b bdf2ee             		LDA CLine_Addr_Lo,X			; Colour Screen Line Addresses LO
   152  ee3e 85c0               		STA COLOURPTR				; Colour Pointer: Current Screen Line Address LO
   153  ee40 bd0bef             		LDA CLine_Addr_Hi,X			; Colour Screen Line Addresses HI
   154  ee43 85c1               		STA COLOURPTR + 1      			; Colour Pointer: Current Screen Line Address HI
   155                          
   156  ee45 60                 		RTS
   157                          
   158                          ;-------------- Sync Pointers - Next Line
   159                          ;
   160                          ; This takes the current line number in X and then uses the lookup tables
   161                          ; to find the screen and colour ram address of the start of the NEXT line and stores them
   162                          ; in the Character and Colour pointers.
   163                          
   164                          ColourPET_SyncPointers
   165  ee46 bda7e7             		LDA Line_Addr_Lo+1,X			; Screen line address table LO + 1
   166  ee49 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   167                          !IF (CODEBASE=0) { 
   168  ee4b bd0cef             		LDA CLine_Addr_Hi+1,X			; Screen Line Addresses HI
   169  ee4e 29f7               		AND #%11110111 
   170                          } ELSE {
   171                          		LDA Line_Addr_Hi+1,X			; Screen Line Addresses HI
   172                          }
   173  ee50 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   174                          
   175  ee52 bdf3ee             		LDA CLine_Addr_Lo+1,X     		; Screen Line address table LO + 1
   176  ee55 85c2               		STA COLOURPTR2				; Second Colour RAM Pointer
   177  ee57 bd0cef             		LDA CLine_Addr_Hi+1,X 			; Screen Line address table HI + 1
   178  ee5a 85c3               		STA COLOURPTR2+1			;
   179  ee5c 60                 		RTS
   180                          
   181                          ColourPET_SyncPointers2
   182  ee5d bda5e7             		LDA Line_Addr_Lo-1,X			; Screen line address table LO - 1
   183  ee60 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   184                          !IF (CODEBASE=0) { 
   185  ee62 bd0aef             		LDA CLine_Addr_Hi-1,X			; Screen Line Addresses HI
   186  ee65 29f7               		AND #%11110111 
   187                          } ELSE {
   188                          		LDA Line_Addr_Hi-1,X			; Screen Line Addresses HI
   189                          }
   190  ee67 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   191                          
   192  ee69 bdf1ee             		LDA CLine_Addr_Lo-1,X     		; Screen Line address table LO - 1
   193  ee6c 85c2               		STA COLOURPTR2				; Second Colour RAM Pointer
   194  ee6e bd0aef             		LDA CLine_Addr_Hi-1,X 			; Screen Line address table HI - 1
   195  ee71 85c3               		STA COLOURPTR2+1			;
   196  ee73 60                 		RTS
   197                          
   198                          
   199                          ;-------------- Scroll Left
   200                          
   201                          ColourPET_Scroll_Left
   202  ee74 c8                 CPSL1		INY
   203  ee75 b1c4               		LDA (ScrPtr),Y				; Read Character from Screen RAM
   204  ee77 88                 		DEY					; move to the left
   205  ee78 91c4               		STA (ScrPtr),Y				; Write Character to Screen RAM
   206  ee7a c8                 		INY
   207  ee7b b1c0               		LDA (COLOURPTR),Y			; Read Colour from Colour RAM	@@@@@@@@@@@@@@ ColourPET
   208  ee7d 88                 		DEY					; move to the left
   209  ee7e 91c0               		STA (COLOURPTR),Y			; Write Colour to Colour RAM	@@@@@@@@@@@@@@ ColourPET
   210  ee80 c8                 		INY
   211  ee81 c4d5               		CPY RightMargin
   212  ee83 d0ef               		BNE CPSL1
   213  ee85 60                 		RTS
   214                          
   215                          ;-------------- Insert
   216                          
   217                          ColourPET_Insert
   218  ee86 88                 CPI1		DEY
   219  ee87 b1c4               		LDA (ScrPtr),Y				; Read Character from Screen RAM
   220  ee89 c8                 		INY					; move to the left
   221  ee8a 91c4               		STA (ScrPtr),Y				; Write Character to Screen RAM
   222  ee8c 88                 		DEY
   223  ee8d b1c0               		LDA (COLOURPTR),Y			; Read Colour from Colour RAM	@@@@@@@@@@@@@@ ColourPET
   224  ee8f c8                 		INY					; move to the left
   225  ee90 91c0               		STA (COLOURPTR),Y			; Write Colour to Colour RAM	@@@@@@@@@@@@@@ ColourPET
   226  ee92 88                 		DEY
   227  ee93 c4c6               		CPY CursorCol
   228  ee95 d0ef               		BNE CPI1
   229                          
   230  ee97 adf28b             		LDA COLOURV				; Current Colour              	@@@@@@@@@@@@@@ COLOURPET
   231  ee9a 91c0               		STA (COLOURPTR),Y			; Write it to the Colour RAM	@@@@@@@@@@@@@@ COLOURPET
   232                          
   233  ee9c 60                 		RTS
   234                          
   235                          ;--------------- Copy Character and Colour from SOURCE to DEST
   236                          
   237                          ColourPET_Scroll_Dest
   238  ee9d b1c7               		LDA (SAL),Y				; Read Character from Screen SOURCE
   239  ee9f 91c4               		STA (ScrPtr),Y				; Write it to Screen DESTINATION
   240  eea1 b1c2               		LDA (COLOURPTR2),Y			; Read Colour from Colour RAM SOURCE	@@@@@@@@@@@@@@@ COLOURPET
   241  eea3 91c0               		STA (COLOURPTR),Y			; Write it to Screen DESTINATION	@@@@@@@@@@@@@@@ COLOURPET
   242  eea5 60                 		RTS
   243                          
   244                          ;-------------- Erase to End of Line
   245                          ;
   246                          ; Clears ONE line on the screen from current cursor to RIGHT margin
   247                          ; Called from WINDOW_CLEAR and WINDOW_SCROLL_UP.
   248                          ; Replaces equivilent non-colour routine.
   249                          ; Must not modify X since it is used as a line counter in WINDOW_CLEAR.
   250                          
   251                          ERASE_TO_EOL
   252  eea6 98                 		TYA					; Save the Current offset
   253  eea7 48                 		PHA					; to the stack
   254                          
   255  eea8 a920               		LDA #$20 				; <SPACE>
   256  eeaa c8                 CEOL		INY					; next character
   257  eeab 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address @@@@@@@@@@@@@@ ColourPET
   258  eead c4d5                		CPY RightMargin
   259  eeaf 90f9               		BCC CEOL				; loop up for more
   260                          
   261  eeb1 68                 		PLA					; Pull the offset from the stack
   262  eeb2 a8                 		TAY					; 
   263                          
   264  eeb3 adf28b             		LDA COLOURV				; The current colour
   265  eeb6 c8                 CEOL2		INY					; Next colour ram location
   266  eeb7 91c0               		STA (COLOURPTR),Y			; Clear Colour RAM
   267  eeb9 c4d5               		CPY RightMargin
   268  eebb 90f9               		BCC CEOL2				; loop up for more
   269  eebd 60                 		RTS
   270                          
   271                          ;-------------- Writes the NEW Character and Colour to the Screen
   272                          Put_ColourChar_at_Cursor
   273  eebe 48                 		PHA				; Save the character
   274  eebf a4c6               		LDY CursorCol			; Cursor Column on Current Line
   275  eec1 adf28b             		LDA COLOURV			; Current Colour Attribute
   276  eec4 91c0               		STA (COLOURPTR),Y		; Put the Colour to ColourRAM
   277  eec6 68                 		PLA				; Restore the character
   278  eec7 a4c6               		LDY CursorCol			; Cursor Column on Current Line		
   279  eec9 91c4               		STA (ScrPtr),Y			; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
   280  eecb a902               		LDA #2				; Set blink count so cursor appears immediately
   281  eecd 85a8               		STA BLNCT			; Timer: Countdown to Toggle Cursor
   282  eecf 60                 		RTS
   283                          
   284                          ;-------------- Writes the OLD Colour at Cursor Position to the screen
   285                          Restore_Colour_at_Cursor
   286  eed0 48                 		PHA				; Push Character
   287  eed1 a4c6               		LDY CursorCol			; Cursor Column on Current Line
   288  eed3 a5ed               		LDA CURSORCOLOUR		; Get current Colour
   289  eed5 91c0               		STA (COLOURPTR),Y		; Set the Colour
   290  eed7 68                 		PLA				; Pull Character
   291  eed8 a4c6               		LDY CursorCol			; Cursor Column on Current Line		
   292  eeda 91c4               		STA (ScrPtr),Y			; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
   293  eedc a902               		LDA #2				; Set blink count so cursor appears immediately
   294  eede 85a8               		STA BLNCT			; Timer: Countdown to Toggle Cursor
   295  eee0 60                 		RTS
   296                          
   297                          ;-------------- Colour Codes Table
   298                          ;
   299                          ; These are the Colour PETSCII codes. We use C128 ordering to be compatible with it.
   300                          ;
   301                          ;	PETSCII Code	C64 colour		C128 colour (*=changed)
   302                          ;       ------------   	----------		-----------
   303                          COLOURS
   304  eee1 90                 	!byte $90	; 0=black		0=black
   305  eee2 98                 	!byte $98	; 12=medium grey	1=medium grey
   306  eee3 1f                 	!byte $1F	; 6=blue		2=blue
   307  eee4 9a                 	!byte $9A	; 14=light blue		3=light blue
   308  eee5 1e                 	!byte $1E	; 5=green		4=green
   309  eee6 99                 	!byte $99	; 13=light green	5=light green	(CONFLICT! PET = SCROLL UP!)
   310  eee7 97                 	!byte $97	; 11=dark grey		6=dark cyan*
   311  eee8 9f                 	!byte $9F	; 3=cyan		7=light cyan*
   312  eee9 1c                 	!byte $1C	; 2=red			8=red
   313  eeea 96                 	!byte $96	; 10=light red		9=light red	(CONFLICT! PET = ERASE END!)
   314  eeeb 81                 	!byte $81	; 8=orange		10=dark purple*
   315  eeec 9c                 	!byte $9C	; 4=magenta		11=magenta/purple
   316  eeed 95                 	!byte $95	; 9=brown		12=dark yellow* (CONFLICT! PET = INS LINE!)
   317  eeee 9e                 	!byte $9E	; 7=yellow		13=yellow
   318  eeef 9b                 	!byte $9B	; 15=light grey		14=light grey
   319  eef0 05                 	!byte $05	; 1=white		15=white
   320                          
   321  eef1 00                 	!byte 0 	; separator
   322                          
   323                          
   324                          ;-------------- Analog Colour Conversion Table
   325                          ; 
   326                          ; Converts colour code index to RRRGGGBB value for Analog ColourPET board
   327                          ; R and G have a range of 0 to 7, B has 0 to 3
   328                          ; If "I" is off, R and G have values of 4, B is 2.
   329                          ; If "I" is on, R and G have values of 7, B is 3.
   330                          
   331                          !IF COLOURMODE=1 {
   332                          
   333                          RGBTABLE
   334                          ;              RRRGGGBB
   335                          	!byte %00000000	; 0=black
   336                          	!byte %01101101	; 1=medium grey
   337                          	!byte %00000010	; 2=blue
   338                          	!byte %00000011	; 3=light blue
   339                          	!byte %00010000	; 4=green
   340                          	!byte %00011100	; 5=light green
   341                          	!byte %10010000	; 6=dark cyan*
   342                          	!byte %11111100	; 7=light cyan*
   343                          	!byte %10000000	; 8=red
   344                          	!byte %11100000	; 9=light red
   345                          	!byte %10000010	; 10=dark purple*
   346                          	!byte %11100011	; 11=magenta/purple
   347                          	!byte %00010010	; 12=dark yellow*
   348                          	!byte %00011111	; 13=yellow
   349                          	!byte %11011010	; 14=light grey
   350                          	!byte %11111111	; 15=white
   351                          }

; ******** Source: editrom_hi.asm
    70                          

; ******** Source: screen1c.asm
     1                          ; PET/CBM EDIT ROM - Screen line address table - Screen 1 @ $8800 Attributes (colour)
     2                          ; ================
     3                          ;
     4                          ; These tables are used to calculate the starting address of each line on the screen
     5                          
     6                          ;---------- 32 characters wide 
     7                          !IF COLUMNS=32 {
     8                          CLine_Addr_Lo	!byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00,$20,$40,$60,$80,$a0,$c0,$e0
     9                          		!byte $00,$20,$40,$60,$80,$a0,$c0,$e0,$00
    10                          CLine_Addr_Hi	!byte $88,$88,$88,$88,$88,$88,$88,$88,$89,$89,$89,$89,$89,$89,$89,$89
    11                          		!byte $8a,$8a,$8a,$8a,$8a,$8a,$8a,$8a,$8b
    12                          }
    13                          
    14                          ;---------- 40 characters wide 
    15                          !IF COLUMNS=40 {
    16  eef2 00285078a0c8f018...CLine_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    17  ef02 80a8d0f820487098...		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    18  ef0b 8888888888888889...CLine_Addr_Hi	!byte $88,$88,$88,$88,$88,$88,$88,$89,$89,$89,$89,$89,$89,$8A,$8A,$8A
    19  ef1b 8a8a8a8a8b8b8b8b...		!byte $8A,$8A,$8A,$8A,$8B,$8B,$8B,$8B,$8B
    20                          }
    21                          
    22                          ;---------- 64 characters wide
    23                          !IF COLUMNS=64 {
    24                          CLine_Addr_Lo	!byte $00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0,$00,$40,$80,$c0
    25                          		!byte $00,$40,$80,$c0,$00,$40,$80,$c0,$00
    26                          CLine_Addr_Hi	!byte $88,$88,$88,$88,$89,$89,$89,$89,$8a,$8a,$8a,$8a,$8b,$8b,$8b,$8b
    27                          		!byte $8c,$8c,$8c,$8c,$8d,$8d,$8d,$8d,$8e
    28                          }
    29                          
    30                          ;---------- 80 characters wide 
    31                          !IF COLUMNS=80 {
    32                          CLine_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0,$20,$70,$c0,$10,$60,$b0
    33                          		!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80
    34                          CLine_Addr_Hi	!byte $88,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a,$8b,$8b,$8b,$8c,$8c,$8c
    35                          		!byte $8d,$8d,$8d,$8d,$8e,$8e,$8e,$8f,$8f
    36                          }
    37                          
    38                          ; 90 characters wide not applicable

; ******** Source: editrom_hi.asm
    71                          }
    72                           		}
    73                          
    74                          		!IF SS40 = 1 {
    75                          			!SOURCE "editsoft40.asm"
    76                          			!IF CODEBASE=0 {
    77                          				!SOURCE "editrom40link.asm"	; Relocate linking code here to make space in main.
    78                          				!SOURCE "editrom40scrollup.asm"	; Relocate scroll up code here to make space in main.
    79                          				JMP CHECK_SCROLL_CONTROL	; Jump back to main.
    80                          			}
    81                          		}
    82                          	}
    83                          
    84                          	;----- These features can stand alone
    85                          
    86                          	!IF KEYSCAN=3	  { !SOURCE "keyboard-tables3.asm" }	; C64 Keyboard Scanning Tables

; ******** Source: editreboot.asm
     1                          ; PET/CBM EDIT ROM - Soft Reboot (C)2013 Steve J. Gray
     2                          ; ================
     3                          ; Soft Reboot - Hold down a combination of keys to reset the computer.
     4                          ; The RebootCodes table holds 10 or 16 values, one for each keyboard ROW. All
     5                          ; values must match to trigger the reset. Note the values are RAW Keyboard
     6                          ; column bits NOT PETSCII. When a key is DOWN the bit in that column is ZERO.
     7                          ; IE, $FF means NO keys are down. Do not fill table with all $FF's or the 
     8                          ; machine will reboot constantly.
     9                          ;
    10                          ; OPTIONS: KEYBOARD selects reboot matrix
    11                          
    12                          CheckReboot
    13                          		!IF KEYBOARD=8 {
    14                          			LDY #15				; ROW=15
    15                          		} ELSE {
    16  ef24 a009               			LDY #9				; ROW=9
    17                          		}
    18                          CheckLoop
    19  ef26 8c10e8             		STY PIA1_Port_A 			; Keyboard row select
    20  ef29 ad12e8             		LDA PIA1_Port_B				; Keyboard col - keypressed
    21  ef2c d938ef             		CMP RebootCodes,Y
    22  ef2f d006               		BNE CheckOut				; Exit if no match
    23  ef31 88                 		DEY					; ROW=ROW-1
    24  ef32 10f2               		BPL CheckLoop				; Get more if not <0
    25                          
    26                          		!IF UPET=1 {
    27  ef34 4c57ef             			JMP RebootUPet
    28                          		} ELSE {
    29                          			JMP ($FFFC)			; All keys match, so reset!
    30                          		}
    31                          
    32  ef37 60                 CheckOut	RTS
    33                          
    34                          ;-------------- Reboot Code Table
    35                          ;
    36                          ; Note: Rows are entered in reverse order compared to the keyboard matrix
    37                          ; IMPORTANT!: Be aware of keyboard "ghosting", which means pressing multiple keys
    38                          ; can sometimes cause other keys to appear pressed.
    39                          
    40                          RebootCodes
    41                          ;		----------------- Normal/Graphic Keyboard: @-SHIFT-SHIFT-DEL
    42                          !if (KEYBOARD=0) OR (KEYBOARD=5) OR (KEYBOARD=9) {
    43                          		!byte %11111111	; ROW 9 - No keys
    44                          		!byte %01111111	; ROW 8 - <DEL>
    45                          		!byte %11111111	; ROW 7 - No keys
    46                          		!byte %11111111	; ROW 6 - No keys
    47                          		!byte %11111111	; ROW 5 - No keys
    48                          		!byte %11111111	; ROW 4 - No keys
    49                          		!byte %11111111	; ROW 3 - No keys
    50                          		!byte %11111111	; ROW 2 - No keys
    51                          		!byte %11011100	; ROW 1 - @ + Both Shifts
    52                          		!byte %11111111	; ROW 0 - No keys
    53                          }
    54                          
    55                          ;		----------------- Business Keyboard: ESC-SHIFT-SHIFT-DEL
    56                          !if (KEYBOARD=1) OR (KEYBOARD=4) OR (KEYBOARD=6) OR (KEYBOARD=7) {
    57  ef38 ff                 		!byte %11111111	; ROW 9
    58  ef39 ff                 		!byte %11111111	; ROW 8
    59  ef3a be                 		!byte %10111110	; ROW 7 - (ghost), ESC
    60  ef3b ff                 		!byte %11111111	; ROW 6
    61  ef3c 7f                 		!byte %01111111	; ROW 5 - DEL
    62  ef3d ff                 		!byte %11111111	; ROW 4
    63  ef3e be                 		!byte %10111110	; ROW 3 - SHIFT, SHIFT
    64  ef3f ff                 		!byte %11111111	; ROW 2
    65  ef40 ff                 		!byte %11111111	; ROW 1
    66  ef41 ff                 		!byte %11111111	; ROW 0
    67                          }
    68                          
    69                          ;		----------------- DIN Keyboard: ESC-SHIFT-SHIFT-DEL
    70                          !if KEYBOARD=2 { 
    71                          		!byte %11011111	; ROW 9 - DEL
    72                          		!byte %11111111	; ROW 8
    73                          		!byte %10111110	; ROW 7 - (ghost), ESC
    74                          		!byte %11111111	; ROW 6
    75                          		!byte %11111111	; ROW 5
    76                          		!byte %11111111	; ROW 4
    77                          		!byte %10111110	; ROW 3 - SHIFT, SHIFT
    78                          		!byte %11111111	; ROW 2
    79                          		!byte %11111111	; ROW 1
    80                          		!byte %11111111	; ROW 0
    81                          }
    82                          
    83                          ;		--------------- C64 Keyboard: CTRL-SHIFT-SHIFT-DEL
    84                          !if KEYBOARD=3 { 
    85                          		!byte %01111111	; ROW 9 - DEL
    86                          		!byte %11111111	; ROW 8
    87                          		!byte %11111110	; ROW 7 - CTRL
    88                          		!byte %11111101	; ROW 6 - SHIFT
    89                          		!byte %10111111	; ROW 5 - SHIFT
    90                          		!byte %11111111	; ROW 4
    91                          		!byte %11111111	; ROW 3
    92                          		!byte %11111111	; ROW 2
    93                          		!byte %11111111	; ROW 1 - row not connected
    94                          		!byte %11111111	; ROW 0 - row not connected
    95                          }
    96                          
    97                          ;		--------------- B modified Keyboard: ESC-SHIFT-SHIFT-DEL
    98                          !if KEYBOARD=4 { 
    99                          		!byte %11111111	; ROW 9
   100                          		!byte %11111111	; ROW 8
   101                          		!byte %11111111	; ROW 7
   102                          		!byte %11111111	; ROW 6
   103                          		!byte %11111111	; ROW 5
   104                          		!byte %11111111	; ROW 4
   105                          		!byte %10101110	; ROW 3 - SHIFT, (ghost), SHIFT
   106                          		!byte %11111111	; ROW 2
   107                          		!byte %11111111	; ROW 1
   108                          		!byte %10101110	; ROW 0 - (ghost), DEL, ESC
   109                          }
   110                          
   111                          ;		--------------- CBM-II Keyboard (16 ROWS): ?
   112                          ;		Note: The CBM-II keyboard is 16x6. Two columns are not connected
   113                          ;		TODO: Development is in progress; wiring is TBD
   114                          !if KEYBOARD=8 { 
   115                          		!byte %11111111	; ROW 15
   116                          		!byte %11111111	; ROW 14
   117                          		!byte %11111111	; ROW 13
   118                          		!byte %11111111	; ROW 12
   119                          		!byte %11111111	; ROW 11
   120                          		!byte %11111111	; ROW 10
   121                          		!byte %11111111	; ROW 9
   122                          		!byte %11111111	; ROW 8
   123                          		!byte %11111111	; ROW 7
   124                          		!byte %11111111	; ROW 6
   125                          		!byte %11111111	; ROW 5
   126                          		!byte %11111111	; ROW 4
   127                          		!byte %11111111	; ROW 3
   128                          		!byte %11111111	; ROW 2
   129                          		!byte %11111111	; ROW 1
   130                          		!byte %11111111	; ROW 0
   131                          }

; ******** Source: editrom_hi.asm
    87                          }		; Keyboard Reset Code

; ******** Source: editbarrow.asm
     1                          ; PET/CBM EDIT ROM - BackArrow Hack/Patch
     2                          ; ================ - Adapted from 8096 edit rom found at World of Commodore 2015
     3                          ;
     4                          ; The BACKACTION variable determines which action code is included:
     5                          ; 0=Toggle Screen Text/Graphic Font
     6                          ; 1=Toggle 40/80 Column Mode (either soft40 or hardware 40/80)
     7                          
     8                          TestBackArrow
     9                          !IF KEYBOARD=0 {                        ; Graphics keyboard -> "@" as top left key
    10                                                                  ; Note: scanner clears KEYFLAGS, so can only be seen on bit 7 set
    11                          		CMP #$c0		; Is it (shifted) "@" key? (top left key).
    12                          					; NOTE: this is a graphics character. It will get discarded!
    13                          
    14                          } ELSE {
    15                                                        		; others use left arrow as top left key
    16  ef42 a498               		LDY KEYFLAGS		; Is it a Shifted Char?
    17  ef44 f004               		BEQ TestBAExit		; No, so exit and store key
    18  ef46 c95f               		CMP #$5F		; Is it BackArrow key?
    19                          }
    20  ef48 f004               		BEQ DoBackArrow		; Yes, perform the action then RETURN (do not store key!)
    21                          
    22  ef4a e8                 TestBAExit	INX			; No, treat it as a normal key and store it, then increment char count
    23  ef4b 869e               		STX CharsInBuffer	; Num Chars in Keyboard Buffer
    24  ef4d 60                 		RTS
    25                          
    26                          ;---------------------------------------- Do the action
    27                          ; BACKACTION=0 to toggle Text/Graphics mode
    28                          ; BACKACTION=1 to toggle 40/80 column
    29                          
    30                          DoBackArrow:
    31                          
    32                          !IF BACKACTION=0 {
    33  ef4e ad4ce8             		LDA VIA_PCR 		; VIA PCR - Reg#C
    34  ef51 4902               		EOR #$02		; toggle bit 1 (graphic/text mode bit)
    35  ef53 8d4ce8             		STA VIA_PCR 		; VIA PCR - Reg#C
    36  ef56 60                 		RTS
    37                          }
    38                          
    39                          !IF BACKACTION=1 {
    40                          		JMP SS40_SwapModes	; Swap 40/80 mode
    41                          }

; ******** Source: editrom_hi.asm
    88                          }		; Back Arrow "hack" Code
    89                          	!IF EXECUDESK > 0 { !SOURCE "execudesk.asm" }		; Execudesk Code

; ******** Source: upet.asm
     1                          ; PET/CBM EDIT ROM - Micro-PET Extensions (C)2021 Andre Fachat
     2                          ; ================
     3                          ; Editor-ROM extensions for the Ultra-PET/Micro-PET:
     4                          ; 
     5                          ; Currently only a hook into the Soft Reboot is used, to get to the Micro-PET
     6                          ; Boot screen, where the actual type of PET can be selected.
     7                          ;
     8                          ; Some future extensions could be graphics options menu, or a speed selector
     9                          
    10                          !IF KEYRESET=1 {
    11                          
    12                          SPEED=$e803
    13                          LOW32K=$e802
    14                          MEMMAP=$e801
    15                          VCTRL=$e800
    16                          
    17                          SPI=$e808
    18                          SPIDATA=$e809
    19                          
    20                          FLASH=$01
    21                          
    22                          RebootUPet
    23  ef57 78                 		sei
    24                          
    25  ef58 a900               		lda #0
    26  ef5a 8d03e8             		sta SPEED	; 1MHz to make sure not to overrun SPI
    27  ef5d 8d01e8             		sta MEMMAP	; all RAM (writeable)
    28  ef60 8d00e8             		sta VCTRL
    29  ef63 8d02e8             		sta LOW32K	
    30                          
    31  ef66 a901               		lda #FLASH
    32  ef68 8d08e8             		sta SPI
    33  ef6b a903               		lda #3		; SPI Flash READ
    34  ef6d 8d09e8             		sta SPIDATA
    35  ef70 a900               		lda #0
    36  ef72 8d09e8             		sta SPIDATA
    37  ef75 8d09e8             		sta SPIDATA
    38  ef78 8d09e8             		sta SPIDATA
    39  ef7b ad09e8             		lda SPIDATA	; trigger first byte
    40                          
    41  ef7e a200               		ldx #0
    42  ef80 ad09e8             loop		lda SPIDATA
    43  ef83 9d00ff             		sta $ff00,x
    44  ef86 e8                 		inx
    45  ef87 d0f7               		bne loop
    46                          
    47  ef89 8e08e8             		stx SPI
    48                          
    49  ef8c 6cfcff             		JMP ($FFFC)
    50                          
    51                          
    52                          }
    53                          
    54                          

; ******** Source: editrom_hi.asm
    90                          }		; UltraPET Code (Andre Fachat)
    91                          
    92                          ;=========================================================================================================
    93                          ; INFOSTRING
    94                          ;=========================================================================================================
    95                          ; Used to include project INFO into the code area so it can be used with ESC-BackArrow
    96                          ; This string can be included twice:
    97                          ;   1. In hidden I/O area from $E800-E8FF.
    98                          ;   2. Here at end of EXT binary (which needs a label so it can be printed).
    99                          
   100                          INFOSTRING
   101                          	!IF INFO > 0      { !SOURCE "info.asm" }
   102                          
   103                          ;=========================================================================================================
   104                          ; END OF CODE
   105                          ;=========================================================================================================
   106                          ; We finish off by padding the binary to exactly 4K bytes.
   107                          ;#########################################################################################################
   108                          
   109                          	!IF OPTROM=0 {
   110  ef8f ffffffffffffffff...		!IF NOFILL=0 { !FILL $F000-*,$FF }		; PAD to 4K ######################
   111                          	}				
   112                          
   113                          ; This is the end of the EXT code.
   114                          ; Do not place code below this point!

; ******** Source: editrom.asm
    51                          
    52                          	}
    53                          
    54                          ; Do not place code below this point!
